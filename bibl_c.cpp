#include <stdio.h>
#include <stdlib.h>
#include <math.h>


/////////////////////////////////////////////////////////////////////////////
//////   ФУНКЦИЯ ПОИСКА АБСАЛЮТНОГО ЗНАЧЕНИЯ ВЕЩЕСТВЕННОГО АРГУМЕНТА  ///////
//
//    Параметры :   x - Вещественное число
//
//    Функция возвращает абсалютное значение вещественного аргумента .
//

double fabs( double x )

{
if (x<0) return -x;
return x;
}

//////////////////////////////////////////////////////////////////////////////
/***************  ПОИСК МАТЕМАТИЧЕСКОГО ОЖИДАНИЯ МАССИВА ******************/
/*
   Параметры :
	       * mas - Указатель на массив мат. ожидание которого надо наити.

		   N - Количество элементов в массиве.

   Функция возвращает  мат. ожидание массива.

*/

double sred( double * mas, long N )

{

double s;
long i;

for(s=0,i=0;i<N;i++ ) s+=mas[i];
if (N>0) return s/N;
return 0;

}

/**************************************************************************/
/**********************  ПОИСК ДИСПЕРСИИ МАССИВА **************************/
/*
   Параметры :
	       * mas - Указатель на массив дисперсию которого надо наити.

		   N - Количество элементов в массиве.

   Функция возвращает дисперсию массива.

*/

double disp( double * mas , long N )

{

double mo,otkl_sr,d;
long i;


mo=sred(mas,N);

for(i=0,d=0;i<N;i++)
  {
   otkl_sr=mas[i]-mo;
   d+=otkl_sr*otkl_sr;
  }

if (N>1) return d/(N-1);

return 0;

}

/**************************************************************************/
/************  ПОИСК КОЭФФИЦИЕНТА КОРРЕЛЯЦИИ МЕЖДУ ДВУМЯ МАССИВАМИ ********/
/*
    Параметры :
		* mas1 - Указатель на первый массив.

		    N1 - Количество элементов в первом массиве.

		* mas2 - Указатель на второй массив.

		    N2 - Количество элементов во втором масссиве.

   Функция возвращает коэффициент корреляции между двумя массивами.

*/

double korr( double * mas1 , long N1 , double * mas2 , long N2 )

{

long N,i;
double mo1, mo2, otk1, otk2, s, d1, d2, otkl_sr ;


/* Определить длину обрабатываемого участка  */
if (N1<N2) N=N1; else N=N2;

/* Найти мат.ожидание 1 го массива */
mo1=sred(mas1,N);

/* Найти мат.ожидание 2 го массива */
mo2=sred(mas2,N);

/* Найти сумму произведений отклонений 1 го  и  2 го массивов
   от своих средних    */
for(s=0,i=0;i<N;i++)
 {
  otk1=mas1[i]-mo1;
  otk2=mas2[i]-mo2;
  s+=otk1*otk2;
 }

/* Найти дисперсию 1 го массива  */
for(d1=0,i=0;i<N;i++)
  {
   otkl_sr=mas1[i]-mo1;
   d1+=otkl_sr*otkl_sr;
  }
d1=sqrt(d1);

/* Найти дисперсию 2 го массива  */
for(d2=0,i=0;i<N;i++)
  {
   otkl_sr=mas2[i]-mo2;
   d2+=otkl_sr*otkl_sr;
  }
d2=sqrt(d2);

if (N>0) return s/(d1*d2);
return 0;

}

/****************************************************************************/
/****************  ФУНКЦИЯ ПОСТРОЕНИЯ КОВАРИЦИОННОЙ МАТРИЦЫ  ****************/
/*
    Параметры :   * matr1 - Указатель на начало блока памяти в котором
			    располагается матрица N 1 для которой нужно
			    построить ковариационную матрицу.

		       N1 - Количество столбцов в матрице N 1.

		       M1 - Количество строк в матрице N 1.

	    * * ad_uk_cov - Адрес по которому располагается указатель
			    на блок памяти в котором храниться ковари-
			    ционная матрица.

		 uk_N_cov - Указатель на переменную в которой записано
			    количество столбцов в ковариационной матрице.

		 uk_M_cov - Указатель на переменную в которой записано
			    количество строк в ковариационной матрице.


 ПРИМЕЧАНИЕ : Внутри функции COVAR происходит выделение динамической памяти
	      для хранения ковариационной матрицы которая строиться внутри
	      этой функции. После использования ковариационной матрицы в
	      вызывающей программе необходимо освободить блок динамической
	      памяти выделенный	 под ее хранение.
*/

void covar( double * matr1, long N1, long M1, double * * ad_uk_cov,
	    long * uk_N_cov, long * uk_M_cov )

{

double * mo, * dsp, s, d, otkl ;

long i, j, st1, st2;


/* Задание длины и ширины ковариационной матрицы */
* uk_N_cov = N1 ;
* uk_M_cov = M1 ;

/* Выделение динамической памяти под хранение ковариационной матрицы */
* ad_uk_cov = ( double * ) malloc( (* uk_N_cov)*(* uk_M_cov)*sizeof(double) );

/* Выделение динамической памяти под хранение массива мат.ожиданий */
mo = ( double * ) malloc( N1*sizeof(double) ) ;

/* Выделение динамической памяти под хранение массива дисперсий */
dsp = ( double * ) malloc( N1*sizeof(double) ) ;


/* Определить математичкеские ожидания всех столбцов матрицы N 1 и
   записать их в массив мат. ожиданий */
for (i=0; i<N1; i++)
  {
   for (s=0,j=0; j<M1; j++) s+=*(matr1+N1*j+i);
   mo[i]=s/M1;
  }


/* Определить дисперсии всех столбцов матрицы N 1 и записать их в
   массив дисперсий. */
for (i=0; i<N1; i++)
  {
   for (d=0,j=0; j<M1; j++)
     {
       otkl=( *(matr1+N1*j+i)-mo[i] );
       d+=otkl*otkl;
     }
   dsp[i]=sqrt(d);
  }


/* Перебор сочетаний каждого столбца с каждым и определение коэффициента
   корреляции между ними.  */
for (st1=0; st1<N1-1; st1++)
  for (st2=st1+1; st2<N1; st2++)
     {
      /* Найти сумму произведений отклонений столбца N st1 и  столбца N st2
	 от своих средних */
      for (s=0,j=0; j<M1; j++) s+=( *(matr1+N1*j+st1)-mo[st1] )*( *(matr1+N1*j+st2)-mo[st2] );

      /* В элементы st1,st2 и st2,st1 ковариационной матрицы записываем
	 коэффициент корреляции между столбцами st1 и st2  */
      *(*ad_uk_cov+N1*st2+st1) = *(*ad_uk_cov+N1*st1+st2) = s/( dsp[st1] * dsp[st2] );

     }

/*  Простановка единиц по диагонали ковариационной матрицы */
for (st1=0; st1<N1; st1++)  *(*ad_uk_cov+N1*st1+st1) = 1 ;


/* Освободить блок памяти выделенный под хранение массива мат.ожиданий  */
free(mo);

/* Освободить блок памяти выделенный под хранение массива дисперсий  */
free(dsp);


}

/****************************************************************************/
/*************  ФУНКЦИЯ ПОИСКА АВТОКОРРЕЛЯЦИОННОГО КОЭФФИЦИЕНТА *************/
/*

    Параметры :    * mas - Указатель на массив.

		       N - Количество элементов в массиве.

		   sdwig - Сдвиг


    Примечание : Функция autokorr() возвращает коэффициент корреляции
		 массива mas() самого с собой сдвинутым на sdwig .

*/

double autokorr( double * mas , long N , long sdwig )
{

double * mas1 , * mas2 ;
long N1 , N2 ;

if (N>sdwig)
 {
  /* Количество элементов в массиве больше чем сдвиг */
  if (sdwig>=0)
    { /* Сдвиг неотрицательный  */
     mas1=mas;
     mas2=mas+sdwig;
     N1=N2=N-sdwig;
    }
  else
    { /* Сдвиг отрицательный  */
     mas1=mas-sdwig;
     mas2=mas;
     N1=N2=N+sdwig;
    }

  return korr(mas1,N1,mas2,N2);
 }

return 0;

}

/****************************************************************************/
/**********  РЕШЕНИЕ СИСТЕМЫ ЛИНЕЙНЫХ УРАВНЕНИЙ МЕТОДОМ ГАУСА ***************/
/*
    Параметры : * matr1 - Адрес начиная с которого в памяти располагается
			  матрица коэффициентов системы линейных уравнений.

	       * stolb1 - Адрес начиная с которого в памяти располагается
			  столбец свободных членов системы линейных урав-
			  нений.

		  * * x - Адрес по которому храниться указатель на начало
			  блока памяти в котором храниться список корней
			  системы линейных уравнений.

		      r - Кол-во элементов в массиве stolb1 , x , кол-во
			  строк и  столбцов в квадратной  матрице matr.

   Функция возвращает значение определителя матрицы matr.

   Примечание : Внутри функции GAUS происходит выделение динамической
		памяти под хранение списка корней решаемой системы линейных
		уравнений , и если значение определителя матрицы возвращаемое
		функцией GAUS() не равно 0 тогда после использования списка
		корней в головной программе необходимо освободить блок дина-
		мической памяти выделенной под ее хранение .
*/

double gaus( double * matr1 , double * stolb1 , double * * x , long r )

{

long i1, rr;
long * prstn, gl_str, ch_per, j, i, jj, ii, znak;
double hr, * matr, * stolb, a, sum, opr ;


// Выделение блока памяти под массив храняший таблицу перестановок 
prstn = (long *) malloc(r*2*sizeof(long));
if (prstn == NULL)
{
	// Ошибка при выделении блока памяти для хранения таблицы перестановок	
	// Выход из функции с возвратом признака ошибки.	
	return 0;	
} 


// Определить размер блока памяти для хранения матрицы коэффициентов системы линейных уравнений.
rr=r*r;

// Выделение блока памяти для хранение матрицы коэффициентов системы линейных уравнений 
matr = (double*) malloc(rr*sizeof(double));
if (matr == NULL)
{
	// Ошибка при выделении блока памяти для хранения матрицы коэффициентов системы линейных уравнений. 

	// Освободить ранее выделенные блоки памяти.
	free(prstn);

	// Выход из функции с возвратом признака ошибки.	
	return 0;	
} 


// Копирование матрицы коэффициентов системы линейных уравнений в блок памяти адресуемый указателем matr 
for(i1=0;i1<rr;i1++) *(matr+i1)=*(matr1+i1);


// Выделение блока памяти под хранение столбца свободных членов системы линейных уравнений  
stolb = (double *) malloc(r*sizeof(double));
if (stolb == NULL)
{
	// Ошибка при выделении блока памяти для хранения столбца свободных членов системы линейных уравнений. 	

	// Освободить ранее выделенные блоки памяти.
	free(prstn);
	free(matr);

	// Выход из функции с возвратом признака ошибки.	
	return 0;	
}


// Копирование столбца свободных членов системы линейных уравнений в блок паияти адресуемый указателем stolb. 
for(i1=0;i1<r;i1++) *(stolb+i1)=*(stolb1+i1);

/* Обнуление счетчика перестановок */
ch_per=0;

/* Приведение матрицы к треугольному виду.*/
for ( gl_str=0; gl_str<r-1; gl_str++ )
  {
    if ( fabs(*(matr+gl_str*r+gl_str))<0.00000000001 )
    {
       /* Диаганальный элемент в главной строке = 0 .
	  Просматривая элементы вдоль главной строки начиная от следующего
	  за диаганальным ищем ненулевой элемент. */
	for(jj=gl_str+1;(jj<r)&&(fabs(*(matr+gl_str*r+jj))<0.00000000001);jj++);

	/* Если в главной строке нет ненулевых элементов тогда освободить
	   память выделенную под хранение таблицы перестановок , под хра-
	   нение матрицы коэффициентов , под хранение столбца свободных
	   членов , cчитать что определитель матрицы == 0 , и дальнейшие
	   вычисления прекратить. */
	if (jj==r)
	{
	    free(prstn);
	    free(stolb);
	    free(matr);
	    return 0;
	}
	/* Если какой либо элемент главной строки отличен от нуля тогда
	   поменять местами столбец в котором располагается этот элемент
	   и текущий столбец имеющий номер gl_str. */
	for(ii=0;ii<r;ii++)
	{
	   hr=*(matr+ii*r+gl_str);
	   *(matr+ii*r+gl_str)=*(matr+ii*r+jj);
	   *(matr+ii*r+jj)=hr;
	}
	// Сделать запись о сделанной перестановке. 
	ch_per++;
	*(prstn+ch_per-1)=gl_str;
	*(prstn+r+ch_per-1)=jj;
    }

    /* Вычитание из всех строк находящихся ниже главной , главную строку
       умноженную на коэффициент */
    for (j=gl_str+1;j<r;j++)
      {
	a=*(matr+j*r+gl_str);
	if (fabs(a)<0.00000000001) continue ;
	a/= *(matr+gl_str*r+gl_str);

	/* Вычесть из j тной строки находящейся ниже главной , главную. */
	for(jj=gl_str;jj<r;jj++) *(matr+j*r+jj)-= *(matr+gl_str*r+jj)*a;
	stolb[j]-=stolb[gl_str]*a;
      }
  }


if (fabs( *(matr+r*(r-1)+(r-1)) )<0.00000000001)
{
	// Диагональный элемент в самой нижней строке = 0  
	// освободить память выделенную под хранение таблицы перестановок,
	// под хранение матрицы коэффициентов , под хранение столбца свободных членов, 
	// cчитать что определитель матрицы == 0 , и дальнейшие вычисления прекратить. 

	// Освободить ранее выделенные блоки памяти.
	free(prstn);
	free(stolb);
	free(matr);

	// Выход из функции с возвратом признака ошибки
	return 0;
}


// Выделение блока памяти для хранения массива корней системы линейных уравнений.
* x = (double *) malloc(r*sizeof(double));

if (* x == NULL)
{
	// Ошибка при выделении блока памяти для хранения массива корней системы линейных уравнений.

	// Освободить ранее выделенные блоки памяти.
	free(prstn);
	free(stolb);
	free(matr);

	// Выход из функции с возвратом признака ошибки
	return 0;
}

// Обратный ход метода Гаусса с вычислением корней системы линейных уравнений 
for (j=r-1;j>=0;j--)
{
    sum=0;
    for (i=j+1;i<r;i++) sum+= *(matr+j*r+i)* *(*x+i) ;
    *(*x+j)=(stolb[j]-sum)/ *( matr+j*r+j);
}

// Проделать все перестановки в обратном порядке  
for ( i=ch_per-1; i>=0; i-- )
{
    hr=*(*x+ *(prstn+i));
    *(*x+ *(prstn+i))= *(*x+ *(prstn+r+i));
    *(*x+ *(prstn+r+i))=hr;
}

//  Нахождение определителя матрицы matr  
opr=1;
for(i=0;i<r;i++) opr*= *(matr+i*r+i);
znak=1;
for(i=0;i<ch_per;i++) znak*=(-1);

// Освободить блоки памяти выделенные под хранение матрицы коэффициентов
// системы линейных уравнений , столбца свободных членов , таблицы пере-
// становок и списка корней системы в том случае если ее определитель == 0 
free(matr);
free(stolb);
free(prstn);
if (opr==0) free(*x);


return opr*znak;

}

/**************************************************************************/
/***************** ФУНКЦИЯ ОБРАЩЕНИЯ КВАДРАТНОЙ МАТРИЦЫ *******************/
/*
    Параметры :         * matr - Адрес начиная с которого в памяти располага-
				 ется матрица которую надо обратить.

		 * * ad_uk_obr - Адрес по которому находиться указатель
				 на начало блока памяти в котором храни-
				 ться обратная матрица.

			     R - Количество столбцов и строк в исходной
				 и обращенной матрице.


    Функция возвращает 1 если обратная матрица найдена  или 0 если обрат-
    ная матрица не найдена.

    Примечание : Внутри функции OBR_MATR происходит выделение динамической
		 памяти под хранение обратной матрицы , если обращение
		 матрицы прошло удачно тогда после ее использования  в
		 головной программе необходимо освободить блок динамиче-
		 ской памяти выделенной под хранение обратной матрицы .
*/

long obr_matr(double * matr, double * * ad_uk_obr, long R )

{

long i,j;

double * stolb, * x ;

/* Выделение блока динамической памяти под хранение обратной матрицы */
*ad_uk_obr=( double * )malloc(R*R*sizeof(double));

/* Выделение блока динамической памяти под хранение столбца свободных
   членов системы линейных уравнений. */
stolb=( double * )malloc( R*sizeof(double) );


/* Формирование обратной матрицы  */

for(j=0; j<R; j++)
  {
    /* Формирование очередного j тного столбца обратной матрицы */

    /* Формирование столбца свободных членов для сис.лин.ур. */
    for(i=0; i<R; i++) stolb[i]=0;
    stolb[j]=1;

    /* Решение системы линейных уравнений  */
    if ( gaus(matr,stolb,&x,R)!=0 )
      {
	/* Решение сис.лин.ур. прошло удачно */

	/* Переписывание решения системы линейных уравнений в j тный столбец
	   формируемой обратной матрицы */
	for(i=0;i<R;i++) *(*ad_uk_obr+i*R+j)=x[i];

	// Освобождение области памяти выделенной под хранение решения сис.лин.ур.
	free(x);
      }
    else
      {
	/* Решение сис.лин.ур. прошло не удачно обращение матрицы не возможно.*/

	/* Освобождение блоков динамической памяти выделенного под хранение
	   столбца свободных членов сис.лин.ур. и обратной матрицы */
	free(stolb);
	free(*ad_uk_obr);

	/* Выход из функции обращения матрицы с признаком не удачи . */
	return 0;
      }
  }

/* Освобождение блока динамической памяти выделенного под хранение столбца
   свободных членов системы линейных уравнений */
free(stolb);

/* Выход из функции обращения матрицы с признаком удачи . */
return 1;

}

/**************************************************************************/
/********************* ФУНКЦИЯ ВВОДА МАТРИЦЫ ******************************/
/*
    Параметры :  * * ad_uk_matr - Адрес по которому находиться указатель
				  на начало блока памяти в котором хранить-
				  ся матрица.

			  uk_N  - Указатель на переменную хранящую количество
				  столбцов в матрице.

			  uk_M  - Указатель на переменную хранящую количество
				  строк в матрице.


   Примечание : Внутри функции WWOD_MATR происходит выделение динамической
		памяти под хранение вводимой матрицы , после использования
		матрицы в головной программе необходимо освободить блок ди-
		намической памяти выделенной под ее хранение .

*/

void wwod_matr( double * * ad_uk_matr, long * uk_N, long * uk_M )

{

long i,j;
double  * uk_matr1;

/* Ввод размеров матрицы */
printf(" \n Введите количество столбцов  : ");
scanf(" %ld",uk_N);

printf(" \n Введите количество строк : ");
scanf(" %ld",uk_M);

/* Выделение блока динамической памяти под хранение матрицы */
* ad_uk_matr=( double * )malloc((*uk_N)*(* uk_M)*sizeof(double));
uk_matr1=* ad_uk_matr;

/* Ввод матрицы  */
for (j=0;j<*uk_M;j++)
  {
   printf("\n");
   for (i=0;i<*uk_N;i++)
     {
      printf(" Адрес : %10p    A [%ld] [%ld] = ",uk_matr1,i+1,j+1);
      scanf("%lf",uk_matr1++);
     }
  }

}


/****************************************************************************/
/*******************  ФУНКЦИЯ ВЫВОДА МАТРИЦЫ ********************************/
/*
    Параметры :   * matr - Указатель на начало блока памяти в котором
			   храниться матрица.

		      N  - Количество столбцов в матрице.

		      M  - Количество строк в матрице.

*/

void wyw_matr( double * matr , long N, long M )

{

long i,j;

for (j=0;j<M;j++)
 {
  printf("\n");
  for (i=0;i<N;i++)
   {
    printf(" %20.16lf", *(matr+j*N+i) );
  }

 }

}

/***************************************************************************/
/**************** ФУНКЦИЯ СУММИРОВАНИЯ ДВУХ МАТРИЦ *************************/
/*
      При удачном суммировании матриц функция возвращает " 1 " ,
      при неудачном " 0 " .

      Параметры :  * matr1 - Указатель на начало блока памяти в котором
			     храниться матрица N 1.

		       N1  - Количество столбцов в матрице N 1.

		       M1  - Количество строк в матрице N 1.

		   * matr2 - Указатель на начало блока памяти в котором
			     храниться матрица N 2.

		       N2  - Количество столбцов в матрице N 2.

		       M2  - Количество строк в матрице N 2.

	   * * ad_uk_matr3 - Адрес указателя на начало блока памяти в котором
			     храниться матрица N 3 , которая является
			     суммой матрицы N 1 и матрицы N 2

		   * uk_N3 - Указатель на переменную хранящую количество
			     столбцов в матрице N 3.

		   * uk_M3 - Указательь на переменную хранящую количество
			     строк в матрице N 3.

   Примечание : Внутри функции SUM_MATR происходит  выделение  динамической
		памяти под хранение матрицы N 3 , после использования матри-
		ицы N 3 в головной программе необходимо освободить блок ди-
		намической памяти выделенной под хранение матрицы N 3
*/


long sum_matr( double * matr1, long N1, long M1, double * matr2, long N2, long M2,
	      double * * ad_uk_matr3, long * uk_N3, long * uk_M3 )

{

long i,nm;
double * uk_matr3;

/* Если длина матрицы N1 не равна длине матрицы N2 или ширина матрицы N1
   не равна ширине матрицы N2 тогда сложение матриц не возможно. */
if ( (N1!=N2) || (M1!=M2) )  return 0;

/* Задание размеров марицы N3 */
* uk_N3=N1;
* uk_M3=M1;

/* Выделение динамической памяти для матрицы N 3 */
* ad_uk_matr3=( double * )malloc((*uk_N3)*(*uk_M3)*sizeof(double));
uk_matr3= * ad_uk_matr3;

/* Суммирование матрицы N1 и матрицы N2 и получение матрицы N3  */
nm=(* uk_N3) * (* uk_M3);
for (i=0;i<nm;i++) *uk_matr3++ = *matr1++ + *matr2++;


return 1;

}

/****************************************************************************/
/*****************  ФУНКЦИЯ ПЕРЕМНОЖЕНИЯ МАТРИЦ  ****************************/
/*

      При удачном перемножении матриц функция возвращает " 1 " ,
      при неудачном " 0 " .

      Параметры :  * matr1 - Указатель на начало блока памяти в котором
			     храниться матрица N 1.

		       N1  - Количество столбцов в матрице N 1.

		       M1  - Количество строк в матрице N 1.

		   * matr2 - Указатель на начало блока памяти в котором
			     храниться матрица N 2.

		       N2  - Количество столбцов в матрице N 2.

		       M2  - Количество строк в матрице N 2.

	   * * ad_uk_matr3 - Адрес указателя на начало блока памяти в котором
			     храниться матрица N 3 , которая является
			     произведением матрицы N 1 и матрицы N 2

		   * uk_N3 - Указатель на переменную хранящую количество
			     столбцов в матрице N 3.

		   * uk_M3 - Указательь на переменную хранящую количество
			     строк в матрице N 3.

   Примечание : Внутри функции UMN_MATR происходит  выделение  динамической
		памяти под хранение матрицы N 3 , после использования матри-
		ицы N 3 в головной программе необходимо освободить блок ди-
		намической памяти выделенной под хранение матрицы N 3
*/

long umn_matr( double * matr1, long N1, long M1, double * matr2, long N2, long M2,
	      double * * ad_uk_matr3, long * uk_N3, long * uk_M3 )

{

long i,j,k;
double * uk_m3;

/* Если длина матрицы N 1 не равна ширине матрицы N 2 тогда перемножение
   матриц не возможно. */
if (N1!=M2) return 0;

/* Определение размеров матрицы N 3 */
* uk_N3 = N2;
* uk_M3 = M1;

/* Выделение динамической памяти для  матрицы N 3 */
* ad_uk_matr3=( double * )malloc((*uk_N3)*(*uk_M3)*sizeof(double));

/* Перемножение матрицы N 1  и  матрицы N 2  и получение  матрицы N 3 */
for (j=0;j<*uk_M3 ;j++)
  for (i=0;i<*uk_N3 ;i++)
    {
     uk_m3=(* ad_uk_matr3)+j*(*uk_N3)+i;
     *(uk_m3)=0;
     for (k=0;k<N1;k++) *(uk_m3)+= *(matr1+j*N1+k) * *(matr2+k*N2+i);
    }

return 1;
}

/****************************************************************************/
/******************* ФУНКЦИЯ ТРАНСПОНИРОВАНИЯ МАТРИЦЫ ***********************/
/*
      Параметры :  * matr1 - Указатель на начало блока памяти в котором
			     храниться матрица N 1.

		       N1  - Количество столбцов в матрице N 1.

		       M1  - Количество строк в матрице N 1.


	   * * ad_uk_matr2 - Адрес указателя на начало блока памяти в котором
			     храниться матрица N 2 , которая является
			     результатом транспонирования  матрицы N 1

		   * uk_N2 - Указатель на переменную хранящую количество
			     столбцов в матрице N 2.

		   * uk_M2 - Указательь на переменную хранящую количество
			     строк в матрице N 2.

   Примечание : Внутри функции TRANS происходит  выделение  динамической
		памяти под хранение матрицы N 2 , после использования матри-
		ицы N 2 в головной программе необходимо освободить блок ди-
		намической памяти выделенной под хранение матрицы N 2 .

*/

void trans( double * matr1, long N1, long M1, double * * ad_uk_matr2, long * uk_N2, long * uk_M2 )

{

long i,j;


/*  Определение длины и ширины матрицы N 2 */
* uk_N2 = M1;
* uk_M2 = N1;

/* Выделение динамической памяти для матрицы N 2 */
* ad_uk_matr2=( double * )malloc((*uk_N2)*(*uk_M2)*sizeof(double));

/* Транспонирование матрицы N 1 и получение матрицы N 2 */
for(j=0;j<M1;j++) for(i=0;i<N1;i++) *(*ad_uk_matr2+i*(*uk_N2)+j)= *(matr1+j*N1+i);

}

//////////////////////////////////////////////////////////////////////////////////////////////////
////////////  	ФУНКЦИЯ ПОИСКА ОЦЕНОК КОЭФФИЦИЕНТОВ ЛИНЕЙНОЙ ФУНКЦИИ ПО МНК 	//////////////////
///
///
///   Параметры :   * S -   Указатель  на начало блока памяти  в котором
///			    храниться матрица содержащая измерения входных
///			    параметров.
///			      Каждому  столбцу  этой матрицы соответствует
///			    набор значений одного параметра для нескольких
///			    измерений , причем количесто элементов столбца
///			    равно количеству измерений.
///			      Каждой  строке  матрицы  соответсвует  набор
///			    значений  всех  рассматриваемых параметров для
///			    одного измерения , причем количество элементов
///			    строки равно количеству параметров.
///
///
///		    N_s -  Количество столбцов в матрице S равное количеству
///			   измеряемых параметров.
///
///
///		    M_s -  Количество строк в матрице S равное количеству
///			   измерений.
///
///
///		    * Y -  Указатель на начало блока памяти в котором
///			   храниться столбец содержащий измерения выход-
///			   ного параметра.
///
///
///		    N_y - Количество столбцов в матрице Y равное 1.
///
///
///		    M_y - Количество строк в матрице Y  равное
///			  количеству измерений должно быть равно M_s .
///
///
///	       * * uk_c - Адрес указателя на начало блока памяти в котором
///			  храниться столбец коэффицинтов, получаемых по МНК.
///
///
///	       * uk_N_c - Указатель на переменную хранящую количество
///			  столбцов в матрице uk_c , должно быть равно 1.
///
///
///	       * uk_M_c - Указатель на переменную хранящую количество
///			  элементов в найденном столбце коэффициентов ,
///			  должно равняться количеству параметров N_s
///			  т. к. каждому параметру соответствует свой
///			  коэффициент.
///
///
///
///  Функция возвращает код результата поиска. Если поиск прошел удачно
///  тогда функция возвращает 1 , иначе 0.
///
///
///							  ^      т     -1    т
///  Примечания : Функция реализует вычисления по формуле :  C = [ S * S ]   * S * Y
///
///	 где  S - матрица измерений входных параметров где каждому столбцу
///		  соответствует набор значений одного параметра во всех
///		  измерениях, а каждой строке набор значений всех параметров
///		  в одном измерении.
///
///	      Y - Столбец измерений выходного параметра.
///
///
///	      ^
///	      C - Оценки коэффициентов линейной функции по МНК .




long mnk( double * S, long N_s, long M_s, double * Y, long N_y, long M_y,
	  double * * uk_c , long * uk_N_c, long * uk_M_c )

{

double * St, * StS, * obr_StS, * obr_StS_St ;

long N_st, M_st, N_sts, M_sts, N_obr_sts, M_obr_sts, N_obr_sts_st,
     M_obr_sts_st, rezult ;

/// Транспонирование матрицы S и получение матрицы St  
trans( S, N_s, M_s, &St, &N_st, &M_st );

/// Перемножение матрицы St и матрицы S и получение матрицы StS  
if ( umn_matr(St,N_st,M_st,S,N_s,M_s,&StS,&N_sts,&M_sts)==0 )
  {
   /// Перемножение матриц прошло не удачно , освободить блок памяти выделенный под хранение матрицы St 
   free(St);

   /// Завершить работу функции с признаком не удачи МНК преобразования 
   return 0;
  }

/* Обращение матрицы StS и получение матрицы obr_StS  */
if ( obr_matr(StS,&obr_StS,N_sts)==0  )
  {
   /* Обращение матрицы StS прошло не удачно , освободить блоки памяти
      выделенные под хранение матриц St и StS */
   free(St);
   free(StS);

   /* Завершить работу функции с признаком не удачи МНК преобразования */
   return 0;
  }

// Задание размеров матрицы obr_StS 
N_obr_sts=M_obr_sts=N_sts;

// Освободить блок памяти выделенный под хранение матрицы StS 
free(StS);

// Перемножение матриц  obr_StS и St и получение матрицы obr_StS_St 
rezult=umn_matr(obr_StS,N_obr_sts,M_obr_sts,St,N_st,M_st,&obr_StS_St,&N_obr_sts_st,&M_obr_sts_st);

// Освободить блок памяти выделенный под хранение матрицы obr_StS  
free(obr_StS);

// Освободить блок памяти выделенный под хранение матрицы St 
free(St);

if ( rezult==0 )
  {
   // Если перемножение матриц прошло не удачно тогда завершить работу
   // функции с признаком не удачи МНК преобразования. 
   return 0;
  }

// Перемножение матриц obr_StS_St и Y и получение матрицы C 
rezult=umn_matr( obr_StS_St, N_obr_sts_st, M_obr_sts_st, Y, N_y, M_y, uk_c, uk_N_c, uk_M_c);


/////////////////////////////
//printf("\n  Третье умножение прошло ");
////////////////////////////


/* Освободить блок памяти выделенный под хранение матрицы obr_StS_St  */
free(obr_StS_St);

if (rezult==0)  return 0;

return 1;

}

/****************************************************************************/
/**************  ФУНКЦИЯ ЦЕНТРИРОВАНИЯ МАТРИЦЫ ПО СТОЛБЦАМ ******************/
/*
    Параметры :  * matr - Указатель на начало блока памяти  в котором лежит
			  матрица которую  нужно центрировать  по столбцам.
			  Отцентрированная матрица  являющаяся  результатом
			  работы функции записывается в этот же блок памяти
			  затирая старую матрицу.

		      N - Количество столбцов в матрице.

		      M - Количество строк в матрице.

   Примечание : Данная функция перебирает все столбцы матрицы , для каждого
		столбца находит среднее по столбцу , и затем вычитает его
		из всех элементов этого столбца. После работы данной функ-
		ции среднее по столбцу равно 0 .
*/

void centr( double * matr, long N, long M )

{

double sr;
long i,j;

for(i=0;i<N;i++)
  {
   /* Рассматриваем очередной iтый столбец матрицы.  */

   /*  Вычисляем среднее по столбцу.  */
   for(sr=0,j=0;j<M;j++) sr+=*(matr+j*N+i);
   sr/=M;

   /*  Вычитаем среднее из всех элементов столбца. */
   for(j=0;j<M;j++) *(matr+j*N+i)-=sr;
  }

}

/****************************************************************************/
/*******  ФУНКЦИЯ ПОИСКА КОЭФФИЦИЕНТОВ СТЕПЕННОГО ПОЛИНОМА  ПО М.Н.К. *******/
/*
    Параметры :  * x - Указатель на начало блока памяти в котором располагае-
		       тся массив значений входной переменной.

		 * y - Указатель на начало блока памяти в котором располагае-
		       тся массив значений выходной переменной.

		step - Степень полинома который надо создать.

		   M - Количество измерений в массивах x и y.

 * * adr_koeff_polin - Адрес по которому храниться указатель на начало блока
		       памяти в котором располагается массив коэффициентов
		       созданного полинома, если полином был создан.
		       Блок памяти выделяется внутри функции.

  Функция возвращает код результата создания. Если создание прошло удачно
  тогда функция возвращает 1 , иначе 0.

*/


long polinom (double * x, double * y, long step, long M, double * * adr_koeff_polin)

{

double * koeff_polin, * S, * sred_S, * c, sr, sr_y, sum ;

long i, j, rez_mnk, rezult, M_c, N_c ;


/* Выделение блока динамической памяти под хранение массива коэффициентов
   полинома. Количество коэффициетов на 1 больше чем степень полинома т.к.
   всегда присутствует коэффициент при 0 вой степени. */
* adr_koeff_polin = ( double * ) malloc( (step+1)*sizeof(double) );
koeff_polin = * adr_koeff_polin ;

if (step>0)
  {
    /* Создание полинома степень которого больше 0 */

    /* Выделение блока динамической памяти под хранение матрицы результатов
       возведения в степень измерений вх.параметров в различные моменты времени.*/
    S = (double *) malloc( M * step * sizeof(double) );

    /* Выделение блока динамической памяти для хранения массива средних
       значений по столбцам матрицы S. */
    sred_S = (double *) malloc( step * sizeof(double) ) ;

    /* Формирование матрицы, элементами строки которой являются результаты
       возведения в степень значения вх.параметра. Каждой строке соответс-
       твует значение вх.параметра в определенный момент времени */
    for (j=0; j<M; j++)
      for (i=0; i<step; i++)
	if ( x[j]==0 )
	  {
	    /* Если значение вх.параметра= 0  тогда записать в матрицу 0 */
	    *(S+j*step+i)=0 ;
	  }
	else
	  {
	    if ((x[j]<0) && ((i+1)%2!=0))
	      {
		/* Если значение вх.параметра отрицательно и степень в которую
		   оно возводиться нечетная тогда результат отрицательный. */
		*(S+j*step+i) = (double) -exp((i+1)*log(abs(x[j]))) ;
	      }
	    else
	      {
		/* Иначе результат возведения значения вх.параметра в степень
		   положительный. */
		*(S+j*step+i) = exp((i+1)*log(abs(x[j]))) ;
	      }
	  }



    /* Поиск средних по столбцам и центрирование матрицы. */
    /* Перебор всех столбцов матрицы */
    for (i=0; i<step; i++)
      {
       /* Найти среднее по i тному столбцу матрицы. */
       for (sr=0,j=0; j<M; j++) sr+=*(S+j*step+i);
       sr/=M;

       /* Запомнить найденное среднее значение по i тной столбцу матрицы S
	  в массиве средних значений по столбцам матрицы S. */
       sred_S[i] = sr;

       /* Среднее по столбцу вычесть из всех элементов столбца */
       for (j=0; j<M; j++) *(S+j*step+i)-=sr;
      }


    /* Центрирование массива содержащего значения выходного параметра */

    /* Наити среднее по массиву y */
    for (sr_y=0,j=0; j<M; j++) sr_y+=y[j];
    sr_y/=M;


    /* Вычесть найденное среднее из всех элементов массива y */
    for (j=0; j<M; j++) y[j]-=sr_y;

    /* Поиск коэффициентов полинома по МНК */
    rez_mnk=mnk(S, step, M, y, 1, M, &c, &N_c, &M_c);


    if (rez_mnk==1)
      {
       /* Поиск коэффициентов полинома по МНК прошел успешно */
       for (sum=0,i=0; i<step; i++) sum+=sred_S[i]*c[i];
       koeff_polin[0]=sr_y-sum;
       for (i=1; i<=step; i++) koeff_polin[i]=c[i-1];

       /* Освобождение блока памяти выделенного под массив с. */
       free(c);

       /* Установить код удачи работы функции */
       rezult=1;

      }

    else
      {
       /* Поиск коэффициентов полинома по МНК прошел не удачно, установить
	  код неудачи работы функции */
       rezult=0;
      }


    /* Освобождение блока динамической памяти содержащего матрицу результатов
       измерения входных параметров в различные моменты времени. */
    free(S);


    /* Освобождение блока динамической памяти содержащего средние значения
       по столбцам матрицы S */
    free(sred_S);


    /* Выход из функции поиска коэффициентов полинома */
    return rezult;

  }

else
  {

    if (step==0)
      {
	/* Создать полином 0 вой степени .  Для этого вычислить  среднее по
	   массиву значений выходного параметра и считать его коэффициентом
	   при 0 вой степени полинома. */
	for(sr=0,i=0;i<M;i++) sr+=*(y+i);
	sr/=M;
	koeff_polin[0]=sr;
	return 1;
      }

    else
      {
	/* Задана отрицательная степень полинома. Выход из функции
	   с признаком неудачи построения полинома. */
	return 0;
      }

  }

}


/****************************************************************************/
/***  ФУНКЦИЯ ПОИСКА КОЭФФИЦИЕНТОВ АВТОРЕГРЕССИОННОГО УРАВНЕНИЯ ПО М.Н.К. ***/
/*

  Параметры :       * Y - Указатель на начало блока памяти в котором записан
			  массив содержащий значения выходного параметра.


		      N - Количество элементов в массиве  * Y.


		      M - Глубина авторегрессии.


  * * adr_koeff_autoreg - Адрес по которому  храниться  указатель  на  начало
			  блока памяти  в котором  располагается массив коэф-
			  фициентов   авторегрессионного   выражения  ,  если
			  поиск прошел успешно. Блок памяти выделяется внутри
			  функции.

    * wys_koeff_autoreg - Количество элементов в массиве авторегрессионных
			  коэффициентов.


  Функция возвращает код результата своей работы. Если поиск коэффициентов
  авторегрессионного  выражения  прошел успешно тогда функция возвращает 1,
  иначе 0.

*/

long autoregres ( double * Y, long N, long M, double * * adr_koeff_autoreg,
		  long * wys_koeff_autoreg )

{

double * S, * Y1 ;

long k, i, l, j, dl_koeff_autoreg, rez_mnk ;


/* Определить количество строк матрицы  S */
k=N-M;

/* Выделение блока динамической памяти для хранения матрицы S */
S = (double *) malloc(k*M*sizeof(double)) ;

/* Выделение блока динамической памяти для хранения столбца Y1 */
Y1 = (double *) malloc(k*sizeof(double)) ;


/* Построение матрицы S и столбца Y1 на основе столбца Y */
for (i=0,l=M; i<k; i++,l++)
  {
    Y1[i]=Y[l];
    for (j=0; j<M; j++) S[i*M+j]=Y[i+j];
  }

/* Вывод на экран матрицы S и столбца Y */
wyw_matr( S, M, k);
printf("\n\n");

wyw_matr( Y1, 1, k);
printf("\n\n");


/* Поиск коэффициентотв авторегрессионного уравнения по МНК */
rez_mnk=mnk(S, M, k, Y1, 1, k, adr_koeff_autoreg, &dl_koeff_autoreg, wys_koeff_autoreg);

/* Освободить блок динамической памяти выделенный для столбца Y1 */
free(Y1);

/* Освободить блок динамической памяти выделенный для матрицы S */
free(S);

return rez_mnk;

}

//////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////   ФУНКЦИЯ ВОЗВЕДЕНИЯ В КВАДРАТ   ////////////////////////////////////////
//
//
//	Входной параметры : 	X - Вещественное число
//
//	Функция возводит в квадрат в входной параметр и возвращает полученный результат.
//
//


double sqr(double x)
{

return x*x;

}


//////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////  РЕШЕНИЕ СИСТЕМЫ ЛИНЕЙНЫХ УРАВНЕНИЙ МЕТОДОМ ЗЕЙДЕЛЯ //////////////////
//
//    Параметры : * a - Адрес начиная с которого в памяти располагается матрица коэффициентов 
//			системы линейных уравнений.
//
//	          * b - Адрес начиная с которого в памяти располагается столбец свободных членов системы 
//			линейных уравнений.
//
//		* * x - Адрес по которому храниться указатель на начало блока памяти в котором храниться 
//			список корней системы линейных уравнений.
//
//		    r - Количество элементов в массиве b, x, количество строк и столбцов в квадратной  матрице a.
//
//  Функция возвращает значение  1 - если решение найдено, и 0 - если решение не найдено.
//
//   Примечание : Внутри функции "zeidel()" происходит выделение динамической памяти под хранение 
//		  массива корней решаемой системы линейных уравнений после использования массива 
//		  корней в головной программе необходимо освободить блок динамической памяти 
//		  выделенной под ее хранение.
//


double zeidel( double * a , double * b , double * * x , long r )

{


double * a1;		// Измененная матрица коэффициентов системы линейных уравнений.
double * b1;		// Измененный столбец свободных членов системы лиенйных уравнений.
double * x1;		// Вспомогательный массив

double a_i_j;		// Вспомогательная переменная для хранения диагонального элемента матрицы

long i, j;		// Счетчики цикла
long nom_it;		// Счетчик итераций

double s;		// Вспомогательные переменная используемая для вычитания из своб.члена суммы произведений коэфф. лин.уравнения на корни.
double s1;		// Среднее квадратичное отклонение системы линейных уравнений.
double s2;		// Отклонение одного уравнения системы.

double sum_kv_b;	// Сумма квадратов столбца свободных членов системы линейных уравнений.
double eps;		// Максим.допустимое  среднее квадр.отклонение  матрицы коэффициентов умноженной на столбец решений от столбца свободных членов системы линейных уравнений.

double summa_stroki;	// Сумма абсалютных значений элементов строки измененной матрицы
double max_sum_stroki;	// Первая норма матрицы - максимальная сумма абсолютных значений элементов строки. 

double sum_stolb;	// Сумма абсалютных значений элементов столбца измененной матрицы
double max_sum_stolb;	// Вторая норма матрицы - максимальная сумма абсолютных значений элементов столбца.
double koren_sum_kv; 	// Вычислить третью норму матрицы  -  корень из суммы квадратов элементов матрицы.




// Выделить область памяти для хранения измененной матрицы коэффициентов системы линейных уравнений.
a1 = (double *) malloc( r * r * sizeof(double));
if (a1 == NULL)
{
	// Ошибка при выделении памяти для хранения измененной матрицы коэффициентов системы линейных уравнений.

	// Выход из функции с возвратом признака ошибки.
	return 0;
}


// Выделить область памяти для хранения измененного столбца свободных членов системы линейных уравнений.
b1 = (double *) malloc( r * sizeof(double)); 
if (b1 == NULL)
{
	// Ошибка при выделении памяти для хранения измененного столбца коэффициентов системы линейных уравнений.	

	// Освободить ранее выделенные блоки памяти.
	free(a1);

	// Выход из функции с возвратом признака ошибки.
	return 0;
}


// Выделение блока памяти для хранения массива корней системы линейных уравнений.
*x = (double *) malloc(r*sizeof(double));
if (*x == NULL)
{
	// Ошибка при выделении блока памяти для хранения массива корней системы линейных уравнений.

	// Освободить ранее выделенные блоки памяти.
	free(a1);
	free(b1);

	// Выход из функции с возвратом признака ошибки
	return 0;
}


// Выделить блока памяти для хранения вспомогательного массива
x1 = (double *) malloc( r * sizeof(double) );
if (x1 == NULL)
{
	// Ошибка при выделении блока памяти для хранения вспомогательного массива

	// Освободить ранее выделенные блоки памяти.
	free(a1);
	free(b1);
	free(*x);

	// Выход из функции с возвратом признака ошибки
	return 0;
}

// Максимальное допустимое  среднее квадратичное отклонение  матрицы коэффициентов умноженной на столбец решений от столбца свободных членов системы линейных уравнений
eps = 0.00001;


// Определить сумму квадратов свободных членов системы линейных уравнений.
sum_kv_b = 0;
for (i=0; i<r; i++) sum_kv_b += sqr(*(b+i));


// Построение измененной матрицы и измененного столбца свободных членов используемых в итерационном процессе нахождения 
// корней системы линейных уравнений методом Зейделя.
//
for (i=0; i<r; i++)
{
	// Взять очередной диагональный элемент матрицы коэффициентов системы линейных уравнений.
	a_i_j = *(a+i*r+i);

	// Получить измененный элемент столбца свободных членов.
	*(b1+i) = *(b+i)/a_i_j;

	// Получить измененные элементы матрицы коэффициентов системы линейных уравнений.
	for (j=0; j<r; j++)  if (i==j) *(a1+i*r+j)=0; else *(a1+i*r+j)= *(a+i*r+j)/a_i_j*(-1);
}

// Выдать измененную матрицу коэффициентов системы линейных уравнений. 
printf("\n  Izmenennaja matrica systemy lin uravnenii i stolbec swobodnyh chlenov  \n\n ");
wyw_matr(a1, r, r );
printf("\n\n ");

// Выдать измененный столбец свободных членов системы линейных уравнений.
wyw_matr(b1, 1, r );
printf("\n\n ");

// Вычислить первую норму матрицы - максимальную сумму абсолютных значений элементов строки. 
max_sum_stroki = 0;
for (i=0; i<r; i++)
{
	summa_stroki = 0;
	for (j=0; j<r; j++)  summa_stroki += fabs(*(a1+i*r+j));
	if (summa_stroki > max_sum_stroki) max_sum_stroki=summa_stroki; 
}

// Выдать на экран первую норму матрицы.
printf("\n  1 norma matric  = %10.3f   ",max_sum_stroki);

if (max_sum_stroki >= 1.00)
{ 
	// Первая норма матрицы больше 1.

	// Вычислить вторую норму матрицы - максимальную сумму абсолютных значений элементов столбца.
	max_sum_stolb = 0;
	for (j=0; j<r; j++)
	{
		sum_stolb = 0;
		for (i=0; i<r; i++) sum_stolb += fabs(*(a1+i*r+j));
		if (sum_stolb > max_sum_stolb) max_sum_stolb=sum_stolb;
	}

	// Выдать на экран вторую норму матрицы.
	printf("\n  2 norma matric   = %10.3f   ", max_sum_stolb);

	if (max_sum_stolb >= 1.00)
	{
		// Вторая норма матрицы больше 1.

		// Вычислить третью норму матрицы  -  корень из суммы квадратов элементов матрицы.
		koren_sum_kv = 0;
		for (i=0; i<r; i++)  for (j=0; j<r; j++)  koren_sum_kv += sqr(*(a1+i*r+j));
		koren_sum_kv  = sqrt(koren_sum_kv);

		// Выдать на экран третью норму матрицы.
		printf("\n  3 norma matric   = %10.3f   ",koren_sum_kv );
		
		if (koren_sum_kv >= 1.00)
		{
			// Третья норма матрицы больше 1.
			// Система линейных уравнений не решается методом Зейделя.			
			
			// Освободить ранее выделенные блоки памяти.
			free(a1);
			free(b1);
			free(*x);
			free(x1);

			// Выход из функции с возвратом признака ошибки
			return 0;
		}
	}
}


// Задаем начальное приближение неизвестных 
for (j=0; j<r; j++) *(*x+j) = 0;

// Присвоить начальное значение счетчику итераций.
nom_it = 1;

// Итерационный процесс нахождения корней системы линейных уравнений.
while (1)
{
	// Выдать массив решений на текущей итерации.
	wyw_matr( *x, 1, r );
	printf("\n\n ");
	
	// Умножение матрицы коэффициентов линейного уравнения на столбец неизвестных
	for (i=0; i<r; i++)
	{
		s = *(b1+i);
		for (j=0; j<r; j++) s+= *(a1+i*r+j) * *(*x+j);
		*(x1+i) = s;
		*(*x+i) = *(x1+i);
	}

	// Определить среднее квадратичное отклонение  матрицы коэффициентов умноженной на столбец решений от столбца свободных членов системы линейных уравнений
	s1=0;
	for (i=0; i<r; i++)
	{
		s2=0;
		for (j=0; j<r; j++) s2+= *(a+i*r+j) * *(x1+j);
		s2 -= *(b+i);
		s1 += sqr(s2);
	}
	s1 /= sum_kv_b;

	// Выдать найденное среднеквадратичное отклонение решения на текущей итерации от решения на предыдущей итерации.
	printf("\n Iteracija № %d     Sred.kvadr.otklonenie %10.6f \n ",nom_it, s1);

	// Если среднеквадратичное отклонение  матрицы коэффициентов умноженной на столбец решений от столбца свободных членов системы линейных уравнений
  	// полученное на текущей итерации меньше допустимого значения отклонения тогда выход из итерационного цикла.
	if (s1 < eps) break;

	// Нарастить счетчик итераций
	nom_it++;
} 

// Выдать на экран найденное решение системы линейных уравнений.
printf("\n\n Reshenie naideno za %d iteracii !!! \n", nom_it);
wyw_matr( *x, 1, r );


// Освободить область памяти выделенную для хранения вспомогательного массива
free(x1);


// Освободить область памяти выделенную для хранения измененной матрицы коэффициентов системы линейных уравнений.
free(a1);


// Освободить область памяти выделенную для хранения измененного столбца свободных членов.
free(b1);



// Выход из функции с возвратом признака удачного завершения.
return 1;


}


//////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////		ВОЗВЕДЕНИЕ В СТЕПЕНЬ		//////////////////	
//
//	Входные параметры :	
//
//		a - Число которое надо возвести в степень
//		b - Степень
//
// 	Возвращаемое значение :	
//		Число возведенное в степень


double step(double a, double b)
{

double step;

if (a>0) 
{
	step = exp( b * log(a));
}
else
{
	if (a<0) 
	{
		step = exp( b * log(fabs(a)));
	}
	else
	{
		if (b==0)
		{
			step = 1.0;
		}
		else
		{
			step = 0.0;
		}
	}
}

return step;

}


///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////	ФУНКЦИЯ ВЫПОЛНЯЮЩАЯ ПОИСК ВЕЩЕСТВЕННЫХ ЧИСЕЛ В СТРОКЕ И ВЫДАЕТ ИХ		///////////////////
//
//
//
//	Входные параметры : 			stroka - Указатель на начало строки
//										 N - Количество элементов в строке	
//						* * ad_u_mas_value - Адрес по которому записан указатель на область памяти в которой
//											 расположен возвращаемый массив вещественных значений. 
//
//     Выходные параметры :			u_mas  - Указатель на массив в который записаны найденные
//											 в строке вещественные значения	
//			
//  Возвращаемое значение :				M  - Количество обнаруженных вещественных значений в строке	
//
//


int string_float( char * stroka, int N, double * * ad_u_mas_value )

{

// Структура используемая для хранения считанных из строки вещественных значений. 
struct list_float_value
{
	double value;					// Вещественное значение
	struct list_float_value * next;	// Указатель на следующий элемент списка считанных из строки вещественных значений.
};

int M;				// Количество обнаруженных вещественных значений в строке
int poz, poz1;		// Номер позиции в строке 
int i;				// Счетчик цикла

double mng;			// Множетель
double cel;			// Целая часть вещественного числа
double drob;		// Дробная часть вещественного числа
double pokaz_step;	// Показатель степени

int znak;				// Знак числа	
int znak_pokaz_step;	// Знак показателя степени	
int kol_poz_pokaz_step;	// Количество позиций в показателе степени
int pn0;				// Признак наличия незначащих нулей в показателе степени

int priz_cifr_cel_drob;	// Признак наличия циферного символа в целой и дробной части.

double mng_pokaz_step;	// Множетель показателя степени
double value;			// Найденное в строке вещественное значение

struct list_float_value * u_nach;	// Указатель на начало списка вещественных значений
struct list_float_value * u_new;	// Указатель на новый элемент списка вещественных значений.
struct list_float_value * u_tek;	// Указатель на текущий элемент списка вещественных значений.
struct list_float_value * u_next;	// Указатель на следующий элемент списка (вспомогательная переменная).

double * mas_value;					// Указатель на массив вещественных чисел считанный из строки.


// Установить пустую ссылку в качестве указателя на начало списка вещественных значений.
u_nach = NULL;

// Обнулить счетчик обнаруженных вещественных значений.
M=0;

// Перебор в цикле всех символов строки
poz=0;

while (poz < N)
{
	if (*(stroka+poz) == '.')
	{
		// Текущим символом является точка "." разделитель целой и дробной части

		// Сброс признака присутствия цифрового символа в целой или дробной части
		priz_cifr_cel_drob = 0;

		// Встать на позицию разделителя целой и дробной части.
		poz1 = poz;

		// Перейти на одну позицию назад.
		poz1--;
		
		// Прочитать целую часть вещественного числа.
		cel = 0;
		mng = 1;

		while ((poz1>=0) && (*(stroka+poz1)>='0') && (*(stroka+poz1)<='9'))
		{
			cel += (double) (*(stroka+poz1) - 48)*mng;
			priz_cifr_cel_drob = 1;
			mng *= 10;
			poz1--;				
		}

		// Считать знак перед вещественным числом.
		znak = 1;
		if ((poz1>=0) && (*(stroka+poz1)=='-'))	znak = -1;  

		// Встать на позицию разделителя целой и дробной части.
		poz1 = poz;

		// Перейти на одну позицию вперед.
		poz1++;

		// Прочитать дробную часть вещественного числа.
		drob = 0;
		mng = 0.1;		

		while  ((poz1 < N) && (*(stroka+poz1)>='0') && (*(stroka+poz1)<='9'))
		{
			drob += (double) (*(stroka+poz1) - 48)*mng;
			priz_cifr_cel_drob = 1;			
			mng /= 10;
			poz1++;				
		} 

		// Установить в "0" показатель степени.
		pokaz_step = 0;

		if ( (poz1 < N) && ((*(stroka+poz1) == 'E') || (*(stroka+poz1) == 'e')) )
		{
			// Строка не кончилась и следующий символ "E" или "e" 

			// Перейти на один символ вперед
			poz1++;							

			if ((poz1 < N) && ((*(stroka+poz1) == ' ') || (*(stroka+poz1) == '+') || (*(stroka+poz1) == '-')))
			{
				// Строка не кончилась и текущий символ ' ' или '+' или '-'

				// считать знак показателя степени
				znak_pokaz_step = 1;
				if (*(stroka+poz1) == '-') znak_pokaz_step=-1;

				// Перейдти на один символ вперед
				poz1++;							

				// Обнулить счетчик действенных разрядов в показателе степени. 
				kol_poz_pokaz_step = 0;

				// Установить паризнак наличия незначащих нулей в показателе степени
				pn0 = 1;
				
				// Прочитать показатель степени 
				mng = 1;	

				while ((poz1 < N) && (*(stroka+poz1)>='0') && (*(stroka+poz1)<='9'))
				{
					// Если в показателе степени попадается символ ненулевой символ тогда сброс признака незначащих нулей.
					if (*(stroka+poz1)!='0') pn0 = 0;

					// Считать очередной символ показателя степени.
					pokaz_step += (*(stroka+poz1) - 48)*mng;

					if (!pn0) 
					{
						// Текущий символ не является незначащим нулем.
						// Нарастить счетчик символов в показателе степени.						
						kol_poz_pokaz_step++;

						// Разделить на 10 множетель 
						mng /= 10;
					}

					// Переход к следующей позицмм
					poz1++;					
				}
				
				// Определить множитель на который надо умножить показатель степени.
				mng_pokaz_step = step(10, (double)(kol_poz_pokaz_step-1));
				mng_pokaz_step *= (double) znak_pokaz_step;  

				// Умножить показатель степени на полученный множетель
				pokaz_step *= mng_pokaz_step;
			}
		}

		if (priz_cifr_cel_drob)
		{
			// Присутствует хотя бы один цифровой символ в целой или дробной части.

			// Получить вещественное число 
			value = (double) znak * (cel + drob) * step(10.0, pokaz_step);

			// Выдать вещественное число
			//printf("\n value = %25.13f ", value);

			// Выделить область памяти для хранения нового элемента списка.
			u_new = (struct list_float_value *) malloc(sizeof(struct list_float_value));

			// В поле "value" нового элемента списка записать полученное вещественное значение.
			u_new->value = value;

			// В поле "next" нового элемента списка записать пустую ссылку.
			u_new->next = NULL;

			if (u_nach == NULL)
			{
				// Список найденных вещественных значений пуст.
				// Установить новый элемент, первым элементом списка вещественных значений.
				u_nach = u_new;
			}
			else
			{
				// Список найденных вещественных значений не пуст.
				// В поле "next" текущего элемента списка записать ссылку на новый элемент.
				u_tek->next = u_new;
			}

			// Считать новый элемент текущим.
			u_tek = u_new;

			// Нарастить счетчик найденных вещественных чисел
			M++;
		}

		// Установить позицию с которой продолжиться рассмотрение строки.
		poz = poz1;
	}
	else
	{
		// Текущий символ не разделитель целой и дробной части.
		// Переход к следующей позиции в строке.
		poz++;
	}		
}

// Выделить область памяти для хранения массива вещественных чисел считанных из строки.
mas_value = (double *) malloc(M * sizeof(double));

// Переписать спискок найденных вещественных значений в массив.
i=0;
u_tek = u_nach;
while (u_tek != NULL)
{
	//printf("\n value = %25.13f ", u_tek->value);
	*(mas_value+i) = u_tek->value;
	u_tek = u_tek->next;
	i++;
}

// Освободить область памяти выделенную для хранения списка вещественнхы значений.
u_tek = u_nach;
while (u_tek != NULL)
{
	u_next = u_tek->next; 	
	free(u_tek);
	u_tek = u_next;	
}

// Записать адрес начала массива вещественных чисел считанных из строки в выходной параметр.
* ad_u_mas_value = mas_value;


// Выход из функции с возвратом количества найденных в строке вещественных чисел.
return M;

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




///****************************************************************************/
//
//void main1()
//
//{
//
//long M1,M1,M2,M2,M3,M3;
//
//double * matr1, * matr2, * matr3  ;
//
///* Ввод матрицы M 1 */
//printf("\n  Ввод матрицы M 1  \n");
//wwod_matr( &matr1, &M1, &M1 );
//
//
///* Ввод матрицы M 2 */
//printf("\n  Ввод матрицы M 2  \n");
//wwod_matr( &matr2, &M2, &M2 );
//
///* Вывод матрицы M 1  */
//printf("\n  Вывод матрицы M 1  \n");
//wyw_matr( matr1, M1, M1 );
//
///* Вывод матрицы M 2  */
//printf("\n  Вывод матрицы M 2  \n");
//wyw_matr( matr2, M2, M2 );
//
//
///* Суммирование матрицы M1 и M2. */
//if ( sum_matr(matr1,M1,M1,matr2,M2,M2,&matr3,&M3,&M3)==1);
//
///* Перемножение матрицы M1 и матрицы M2 */
///*if ( umn_matr(matr1,M1,M1,matr2,M2,M2,&matr3,&M3,&M3)==1 ) */
//  {
//   /* Вывод матрицы M 3  */
//   printf("\n  Вывод матрицы M 3  \n");
//   wyw_matr( matr3, M3, M3 );
//
//   /* Освобождение участка памяти выделенного для матрицы M 3 */
//   free(matr3);
//
//  }
//
///* Освобождение участка памяти выделенного для матрицы M 1 */
//free(matr1);
//
///* Освобождение участка памяти выделенного для матрицы M 2 */
//free(matr2);
//
//
//}
//
///****************************************************************************/
//
//void main2()
//
//{
//
//long M1, M1, M2, M2 ;
//double * matr, * stolb, * x, opr;
//
///*  Ввод матрицы коэффициентов   */
//printf("\n  Ввод матрицы коэффициентов  \n");
//wwod_matr( &matr, &M1, &M1 );
//
//if (M1==M1)
//  { /* Если длина равна ширине  */
//
//    /* Ввод столбца свободных членов */
//    printf("\n  Ввод столбца свободных членов \n");
//    wwod_matr( &stolb, &M2, &M2 );
//
//    if ((M2==1) && (M1==M2))
//      {
//	/* Вывод на экран матрицы коэффициентов и столбца свободных членов */
//	printf("\n   Просмотр матрицы коэффициентов.  \n");
//	wyw_matr( matr, M1, M1 );
//	printf("\n   Просмотр столбца свободных членов.  \n");
//	wyw_matr( stolb, M2, M2 );
//
//	/* Решение системы линейных уравнений */
//	opr=gaus( matr, stolb, &x, M1 );
//
//	if (opr!=0)
//	  {
//	   /* Если определитель не равен 0 тогда , вывод на экран
//	      решения системы линейных уравнений */
//	   printf("\n  Определитель = %7.3lf   \n",opr);
//	   wyw_matr( x, 1, M1 );
//
//	   /* Освободить блок памяти выделенный под хранение столбца решений */
//	   free(x);
//	  }
//	else
//	  {
//	   printf("\n  Определитель =  0  \n");
//	  }
//
//      }
//
//    /* Освободить блок памяти выделенный под хранение столбца свободных
//       членов */
//    free(stolb);
//  }
//
///* Освободить блок памяти выделенный под хранение матрицы коэффициентов */
//free(matr);
//
//}
//
//
///***************************************************************************/
//void main3()
//
//{
//
//long M1, M1, M2, M2, M3, M3 ;
//double * matr1, * matr2, * matr3 ;
//
///*  Ввод матрицы M 1  */
//printf("\n  Ввод матрицы коэффициентов  \n");
//wwod_matr( &matr1, &M1, &M1 );
//
///* Вывод на экран матрицы M 1 */
//printf("\n   Просмотр исходной матрицы .  \n");
//wyw_matr( matr1, M1, M1 );
//
//
//if (M1==M1)
//  {
//    /* Если длина равна ширине */
//
//    /* Поиск обратной матрицы */
//    if ( obr_matr( matr1, &matr2, M1 )==1 )
//      {
//       /* Если обратная матрица найдена
//
//       /* Задание размеров обращенной маатрицы */
//       M2=M2=M1;
//
//       /* Вывод обратной матрицы на экран */
//       printf("\n \n  Просмотр обратной матрицы .  \n");
//       wyw_matr( matr2, M2, M2 );
//
//
//       /* Перемножение прямой и обратной матрицы */
//
//      if ( umn_matr(matr1,M1,M1,matr2,M2,M2,&matr3,&M3,&M3)==1 )
//	{
//	/* Вывод на экран результата перемножения прямой и обратной матрицы */
//	printf("\n \n  Просмотр результата перемножения прямой и обратной матрицы . \n");
//	wyw_matr( matr3, M3, M3 );
//
//	/* Освобождение блока памяти выделенного под хранение результата пере-
//	   множения прямой и обратной матрицы */
//	free(matr3);
//
//	}
//
//       /* Освобождение блока памяти выделенного под хранение обратной матрицы */
//       free(matr2);
//
//      }
//  }
//
//
//
///* Освободить блок памяти выделенный под хранение матрицы M 1 */
//free(matr1);
//
//}
//
//***************************************************************************/
//
//void main4()
//
//{
//
//double * mas , mo , d ;
//
//long M, M;
//
///*  Ввод массива  */
//printf("\n \n  Ввод массива  \n");
//wwod_matr( &mas, &M, &M );
//
///*  Выдача массива на экран  */
//printf("\n \n  Просмотр массива  \n");
//wyw_matr( mas, M, M );
//
///*  Поиск мат. ожидания массива и выдача его на экран  */
//mo=sred(mas,M*M);
//printf("\n \n    М.О. = %5.2lf \n ",mo );
//
//
///*  Поиск дисперсии массива и выдача ее на экран  */
//d=disp(mas,M*M);
//printf("\n \n    Дисперсия  = %5.2lf \n ",d );
//
//
///* Освобождение блока памяти выделенного под хранение массива  */
//free(mas);
//
//
//}
//
///****************************************************************************/
//
//void main5()
//
//{
//
//long M1, M1, M2, M2 ;
//double * matr1, * matr2 ;
//
///*  Ввод матрицы M 1  */
//printf("\n  Ввод матрицы коэффициентов  \n");
//wwod_matr( &matr1, &M1, &M1 );
//
///* Вывод на экран матрицы M 1 */
//printf("\n   Просмотр исходной матрицы .  \n");
//wyw_matr( matr1, M1, M1 );
//
//
///* Вызов процедуры транспонирования матрицы */
//trans( matr1, M1, M1, &matr2, &M2, &M2 );
//
///* Вывод на экран транспонированной матрицы */
//printf("\n  \n  Просмотр транспонированной матрицы .  \n");
//wyw_matr( matr2, M2, M2 );
//
//
///* Освободить блок памяти выделенный под хранение матрицы M 1 */
//free(matr1);
//
//
///* Освободить блок памяти выделенный под хранение матрицы M 2 */
//free(matr2);
//
//}
//
///***************************************************************************/
//
//void main6()
//
//{
//double * mas1 , * mas2 , k ;
//long M1, M1, M2, M2;
//
//
///*  Ввод массива M 1 */
//printf("\n \n  Ввод массива  M 1 \n");
//wwod_matr( &mas1, &M1, &M1 );
//
///*  Выдача массива M 1 на экран  */
//printf("\n \n  Просмотр массива M 1 \n");
//wyw_matr( mas1, M1, M1 );
//
///*  Ввод массива M 2 */
//printf("\n \n  Ввод массива  M 2  \n");
//wwod_matr( &mas2, &M2, &M2 );
//
///*  Выдача массива M 2 на экран  */
//printf("\n \n  Просмотр массива M 2  \n");
//wyw_matr( mas2, M2, M2 );
//
///*  Поиск коэффициента корреляции между двумя массивами */
//k=korr(mas1,M1*M1,mas2,M2*M2);
//
///*  Выдача коэффициента корреляции на экран  */
//printf("\n \n    К.К. = %5.2lf \n ",k );
//
//
///* Освобождение блока памяти выделенного под хранение массива M 1 */
//free(mas1);
//
///* Освобождение блока памяти выделенного под хранение массива M 2 */
//free(mas2);
//
//}
//
///***************************************************************************/
//void main7()
//
//{
//
//double * matr, * stolb, * c ;
//long M_m, M_m, M_st, M_st, M_c, M_c, rezult ;
//
//
///* Ввод матрицы содержащей результаты измерений входных параметров  */
//printf("\n \n Ввод матрицы содержащей результаты измерений входных параметров \n ");
//wwod_matr( &matr, &M_m, &M_m );
//
//
///* Вывод матрицы содержащей результаты измерений входных параметров  */
//printf("\n \n  Смотри матрицу измерений входных параметров   \n ");
//wyw_matr(matr,M_m,M_m);
//
//
///* Ввод столбца содержащего результаты измерений выходных параметров  */
//printf("\n \n Ввод матрицы содержащей результаты измерений выходных параметров \n ");
//wwod_matr( &stolb, &M_st, &M_st );
//
//
///* Вывод столбца содержащего результаты измерений выходных параметров  */
//printf(" \n \n  Смотри матрицу измерений выходных параметров  \n ");
//wyw_matr(stolb,M_st,M_st);
//
//
//if ( (M_st!=1) || (M_m!=M_st) )
//  {
//   printf("\n \n  Для заданных размеров матрицы входных параметров и столбца выходных выходных ");
//   printf(" \n  параметров МНК преобразование невозможно !!! \n ");
//   return;
//  }
//
///* Поиск коэффициентов линейной функции по МНК */
//rezult=mnk(matr,M_m,M_m,stolb,M_st,M_st,&c,&M_c,&M_c);
//
//if (rezult==1)
//  {
//   /* Если МНК преобразование прошло удачно тогда вывод найденных
//      коэффициентов линейной функции */
//   printf("\n \n  Смотри найденные коэффициеты линейного уравнения ");
//   wyw_matr( c, M_c, M_c );
//
//   /* Освобождение блока памяти выделенного под хранение коэффициентов */
//   free(c);
//
//  }
//
//else
//  {
//   /* При неудачном МНК преобразовании выдать предупреждающее сообщение */
//   printf(" \n \n  Не удача МНК преобразования  \n ");
//  }
//
//
///* Освобождение блока памяти выделенного под хранение матрицы содержащей
//   результаты измерения входных параметров  */
//free(matr);
//
//
///* Освобождение блока памяти выделенного под хранение столбца содержащего
//   результаты измерения выходных параметров  */
//free(stolb);
//
//
//}
//
///***************************************************************************/
//
//void main8()
//
//{
//
//double * mas , k ;
//long M, M, sdw ;
//
//
///*  Ввод массива  */
//printf("\n \n  Ввод массива  \n");
//wwod_matr( &mas, &M, &M );
//
//
///*  Выдача массива на экран  */
//printf("\n \n  Просмотр массива \n");
//wyw_matr( mas, M*M, 1 );
//
//
//for(sdw=-M*M;sdw<=M*M;sdw++)
// {
//  /* Поиск коэффициента корреляции для сдвига */
//  k=autokorr(mas,M*M,sdw);
//
//  /*  Выдача коэффициента корреляции на экран  */
//  printf("\n \n  Сдвиг = %ld      К.К. = %5.2lf \n ",sdw ,k );
// }
//
//
///* Освобождение блока памяти выделенного под хранение массива mas  */
//free(mas);
//
//
//}
//
///***************************************************************************/
//void main9()
//
//{
//
//double * matr;
//long M,M;
//
//
///*  Ввод матрицы  */
//printf("\n \n  Ввод матрицы  \n");
//wwod_matr( &matr, &M, &M );
//
//
///* Вывод матрицы  */
//printf("\n \n  Вывод матрицы  \n");
//wyw_matr( matr, M, M );
//
//
///* Центрирование матрицы */
//centr( matr, M, M );
//
//
///* Вывод матрицы  */
//printf("\n \n  Вывод матрицы  \n");
//wyw_matr( matr, M, M );
//
//
///* Освобождение блока памяти выделенного под хранение матрицы matr */
//free(matr);
//
//
//
//}
//
///***************************************************************************/
//
//void main10()
//
//{
//
//double * matr, * matr_cov;
//
//long M, M, M_cov, M_cov;
//
//
///*  Ввод матрицы  */
//printf("\n \n  Ввод исходной матрицы  \n");
//wwod_matr( &matr, &M, &M );
//
///* Вывод матрицы  */
//printf("\n \n  Просмотр исходной матрицы  \n");
//wyw_matr( matr, M, M );
//
///* Построение ковариационной матрицы  */
//covar( matr, M, M, &matr_cov, &M_cov, &M_cov  );
//
///* Просмотр ковариационной матрицы  */
//printf("\n \n  Просмотр ковариационной матрицы  \n");
//wyw_matr( matr_cov, M_cov, M_cov );
//
//}
//
///***************************************************************************/
//
//void main11()
//
//{
//
//long i, M, step_polin, rezult ;
//
//double * x, * y, * a ;
//
//
///* Задание количества измерений и степени полинома. */
//M=40;
//step_polin=7;
//
//
///* Выделение динамической памяти для хранения массивов входных и выходных измерений */
//x = ( double * ) malloc( M * sizeof(double) ) ;
//y = ( double * ) malloc( M * sizeof(double) ) ;
//
//
///* Задание значений массива входных и выходных параметров */
//
//
// x[ 0]=-20;   y[ 0]=              -636811957.5000000000;
// x[ 1]=-19;   y[ 1]=              -444470018.5000000000;
// x[ 2]=-18;   y[ 2]=              -304229157.5000000000;
// x[ 3]=-17;   y[ 3]=              -203756812.5000000000;
// x[ 4]=-16;   y[ 4]=              -133175261.5000000000;
// x[ 5]=-15;   y[ 5]=               -84675342.5000000000;
// x[ 6]=-14;   y[ 6]=               -52173013.5000000000;
// x[ 7]=-13;   y[ 7]=               -31006232.5000000000;
// x[ 8]=-12;   y[ 8]=               -17669637.5000000000;
// x[ 9]=-11;   y[ 9]=                -9584506.5000000000;
// x[10]=-10;   y[10]=                -4901477.5000000000;
// x[11]= -9;   y[11]=                -2333508.5000000000;
// x[12]= -8;   y[12]=                -1016557.5000000000;
// x[13]= -7;   y[13]=                 -395462.5000000000;
// x[14]= -6;   y[14]=                 -132501.5000000000;
// x[15]= -5;   y[15]=                  -36112.5000000000;
// x[16]= -4;   y[16]=                   -7253.5000000000;
// x[17]= -3;   y[17]=                    -882.5000000000;
// x[18]= -2;   y[18]=                     -37.5000000000;
// x[19]= -1;   y[19]=                       3.5000000000;
// x[20]=  0;   y[20]=                       2.5000000000;
// x[21]=  1;   y[21]=                       1.5000000000;
// x[22]=  2;   y[22]=                      42.5000000000;
// x[23]=  3;   y[23]=                     887.5000000000;
// x[24]=  4;   y[24]=                    7258.5000000000;
// x[25]=  5;   y[25]=                   36117.5000000000;
// x[26]=  6;   y[26]=                  132506.5000000000;
// x[27]=  7;   y[27]=                  395467.5000000000;
// x[28]=  8;   y[28]=                 1016562.5000000000;
// x[29]=  9;   y[29]=                 2333513.5000000000;
// x[30]= 10;   y[30]=                 4901482.5000000000;
// x[31]= 11;   y[31]=                 9584511.5000000000;
// x[32]= 12;   y[32]=                17669642.5000000000;
// x[33]= 13;   y[33]=                31006237.5000000000;
// x[34]= 14;   y[34]=                52173018.5000000000;
// x[35]= 15;   y[35]=                84675347.5000000000;
// x[36]= 16;   y[36]=               133175266.5000000000;
// x[37]= 17;   y[37]=               203756817.5000000000;
// x[38]= 18;   y[38]=               304229162.5000000000;
// x[39]= 19;   y[39]=               444470023.5000000000;
//
//
//
//
///* Поиск коэффициентоов полинома по МНК */
//rezult=polinom( x, y, step_polin, M, &a );
//
//if (rezult==1)
//  {
//   /* Поиск коэффициентов полинома прошел успешно. */
//   /* Вывод на экран найденных коэффициентов полинома */
//   printf("\n                                                              ");
//   printf("\n                                                              ");
//   printf("\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
//   printf("\n            Просмотр найденных коэффициентов полинома         ");
//
//   for (i=0; i<=step_polin; i++) printf(" \n  a[ %ld ] = %12.5lf ",i, a[i]);
//
//   /* Освобождение блока динамической памяти выделенной под хранение массива
//      коэффициентов полинома. */
//   free(a);
//  }
//
//else
//  {
//   /* Поиск коэффициентов полинома прошел неудачно. Вывод на экран
//      предупреждающего сообщения.  */
//   printf("\n                                                              ");
//   printf("\n                                                              ");
//   printf("\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
//   printf("\n              Коэффициенты полинома не найдены !!!            ");
//  }
//
//
///* Освобождение блока динамической памяти выделенной под хранение массивов
//   измерений входных и выходных значений. */
//free(x);
//free(y);
//
//
//}

/***************************************************************************/

//
//void main()
//
//{
//
//long N, kol_koeff, gl, rez, i, j;
//
//double * y, * a, s, skv, max_otkl, otkl;
//
//
///* Задание количества измерений параметра Y */
//N=30;
//
///* Задание глубины авторегрессии */
//gl=14;
//
//
///* Выделение динамической памяти для массива хранящего результаты измерений
//   параметра y */
//y = ( double * ) malloc( N * sizeof(double) ) ;
//
//
///* Задание значения массива содержащего результаты измерений параметра y */
//
///* Слабокоррелированный сам с собой временной ряд имеющий резкие скачки */
///*
//y[0]=17 ;
//y[1]=19 ;
//y[2]=20 ;
//y[3]=15 ;
//y[4]=13 ;
//y[5]=14 ;
//y[6]=14 ;
//y[7]=14 ;
//y[8]=14 ;
//y[9]=11 ;
//
//y[10]=16 ;
//y[11]=19 ;
//y[12]=23 ;
//y[13]=18 ;
//y[14]=17 ;
//y[15]=20 ;
//y[16]=20 ;
//y[17]=18 ;
//y[18]=14 ;
//y[19]=16 ;
//
//y[20]=21 ;
//y[21]=24 ;
//y[22]=15 ;
//y[23]=16 ;
//y[24]=20 ;
//y[25]=14 ;
//y[26]=16 ;
//y[27]=25.5 ;
//y[28]=25.8 ;
//y[29]=26 ;
//
//y[30]=26 ;
//y[31]=29 ;
//y[32]=20 ;
//y[33]=18 ;
//y[34]=16 ;
//y[35]=22 ;
//y[36]=22 ;
//y[37]=16 ;
//y[38]=19 ;
//y[39]=17 ;
//
//y[40]=17 ;
//y[41]=19 ;
//y[42]=20 ;
//y[43]=24 ;
//y[44]=28 ;
//y[45]=36 ;
//y[46]=20 ;
//y[47]=14 ;
//y[48]=18 ;
//y[49]=27 ;
//
//y[50]=29 ;
//y[51]=36 ;
//y[52]=29 ;
//y[53]=27 ;
//y[54]=30 ;
//y[55]=38 ;
//y[56]=50 ;
//y[57]=24 ;
//y[58]=25 ;
//y[59]=30 ;
//
//y[60]=31 ;
//y[61]=37 ;
//y[62]=41 ;
//y[63]=36 ;
//y[64]=32 ;
//y[65]=47 ;
//y[66]=42 ;
//y[67]=37 ;
//y[68]=34 ;
//y[69]=36 ;
//
//y[70]=43 ;
//y[71]=55 ;
//y[72]=64 ;
//y[73]=79 ;
//y[74]=59 ;
//y[75]=47 ;
//y[76]=48 ;
//y[77]=49 ;
//y[78]=45 ;
//y[79]=53 ;
//
//y[80]=55 ;
//y[81]=55 ;
//y[82]=54 ;
//y[83]=56 ;
//y[84]=52 ;
//y[85]=76 ;
//y[86]=113 ;
//y[87]=68 ;
//y[88]=59 ;
//y[89]=74 ;
//
//y[90]=78 ;
//y[91]=69 ;
//y[92]=78 ;
//y[93]=73 ;
//y[94]=88 ;
//y[95]=98 ;
//y[96]=109 ;
//y[97]=106 ;
//y[98]=87 ;
//y[99]=77 ;
//
//*/
/**************************************************************************/

/* Солнечная активность */
/*
//y[0]=80.9   ;
//y[1]=83.4   ;
//y[2]=47.7   ;
//y[3]=47.8   ;
//y[4]=30.7   ;
//y[5]=12.2   ;
//y[6]=9.6    ;
//y[7]=10.2   ;
//y[8]=32.4   ;
//y[9]=47.6   ;
//
//y[10]=54.0  ;
//y[11]=62.9  ;
//y[12]=85.9  ;
//y[13]=61.2  ;
//y[14]=45.1  ;
//y[15]=36.4  ;
//y[16]=20.9  ;
//y[17]=11.4  ;
//y[18]=37.8  ;
//y[19]=69.8  ;
//
//y[20]=106.1 ;
//y[21]=100.8 ;
//y[22]=81.6  ;
//y[23]=66.5  ;
//y[24]=34.8  ;
//y[25]=30.6  ;
//y[26]=7.0   ;
//y[27]=19.8  ;
//y[28]=92.5  ;
//y[29]=154.4 ;
//
//y[30]=125.9 ;
//y[31]=84.8  ;
//y[32]=68.1  ;
//y[33]=38.5  ;
//y[34]=22.8  ;
//y[35]=10.2  ;
//y[36]=24.1  ;
//y[37]=82.9  ;
//y[38]=132.0 ;
//y[39]=130.9 ;
//
//y[40]=118.1 ;
//y[41]=89.9  ;
//y[42]=66.6  ;
//y[43]=60.0  ;
//y[44]=46.9  ;
//y[45]=41.0  ;
//y[46]=21.3  ;
//y[47]=16.0  ;
//y[48]=6.4   ;
//y[49]=4.1   ;
//
//y[50]=6.8   ;
//y[51]=14.5  ;
//y[52]=34.0  ;
//y[53]=45.0  ;
//y[54]=43.1  ;
//y[55]=47.5  ;
//y[56]=42.2  ;
//y[57]=28.1  ;
//y[58]=10.1  ;
//y[59]=8.1   ;
//
//y[60]=2.5   ;
//y[61]=0.0   ;
//y[62]=1.4   ;
//y[63]=5.0   ;
//y[64]=12.2  ;
//y[65]=13.9  ;
//y[66]=35.4  ;
//y[67]=45.8  ;
//y[68]=41.1  ;
//y[69]=30.4  ;
//
//y[70]=23.9  ;
//y[71]=15.7  ;
//y[72]=6.6   ;
//y[73]=4.0   ;
//y[74]=1.8   ;
//y[75]=8.5   ;
//y[76]=16.6  ;
//y[77]=36.3  ;
//y[78]=49.7  ;
//y[79]=62.5  ;
//
//y[80]=67.0  ;
//y[81]=71.0  ;
//y[82]=47.8  ;
//y[83]=27.5  ;
//y[84]=8.5   ;
//y[85]=13.2  ;
//y[86]=56.9  ;
//y[87]=121.5 ;
//y[88]=138.3 ;
//y[89]=103.2 ;
//
//y[90]=85.8  ;
//y[91]=63.2  ;
//y[92]=36.8  ;
//y[93]=24.2  ;
//y[94]=10.7  ;
//y[95]=15.0  ;
//y[96]=40.1  ;
//y[97]=61.5  ;
//y[98]=98.5  ;
//y[99]=124.3 ;
//
//
//y[100]=95.9 ;
//y[101]=66.5 ;
//y[102]=64.5 ;
//y[103]=54.2 ;
//y[104]=39.0 ;
//y[105]=20.6 ;
//y[106]=6.7  ;
//y[107]=4.3  ;
//y[108]=22.8 ;
//y[109]=54.8 ;
//
//y[110]=93.8 ;
//y[111]=95.7 ;
//y[112]=77.2 ;
//y[113]=59.1 ;
//y[114]=44.0 ;
//y[115]=47.0 ;
//y[116]=30.5 ;
//y[117]=16.3 ;
//y[118]=7.3  ;
//y[119]=37.3 ;
//*/
//
//
/****************************************************************************/
/* Отгрузка подшипников 1 группы в условных ценах */


//y[0]=232   ;
//y[1]=874   ;
//y[2]=1309   ;
//y[3]=1168   ;
//y[4]=1257   ;
//y[5]=1669   ;
//y[6]=2339   ;
//y[7]=2262   ;
//y[8]=1298   ;
//y[9]=1454   ;
//
//y[10]=2306  ;
//y[11]=1946  ;
//y[12]=2198  ;
//y[13]=1861  ;
//y[14]=2174  ;
//y[15]=2961  ;
//y[16]=2472  ;
//y[17]=3519  ;
//y[18]=3056  ;
//y[19]=2719  ;
//
//y[20]=2054  ;
//y[21]=2707  ;
//y[22]=2687  ;
//y[23]=2439  ;
//y[24]=2397  ;
//y[25]=2214  ;
//y[26]=2123  ;
//y[27]=1797  ;
//y[28]=1426  ;
//y[29]=1711  ;
//
//
/* Поиск коэффициентов авторегрессионной модели по МНК */
//rez = autoregres(y, N, gl, &a, &kol_koeff ) ;
//
//
//if (rez==1)
//  {
//    /* Поиск коэффициентов авторегрессионной модели прошел удачно.*/
//
//    /* Вывод на экран найденных коэффициентов авторегрессионной модели */
//    printf("\n\n");
//    for (i=0; i<kol_koeff; i++) printf("\n  a[ %ld ] = %12.7lf", i+1, a[i] );
//
//
//    /* Вывод на экран реальных значений временного ряда и значений предсказанных
//       авторегрессионным уравнением, вычисление среднеквадратичного отклоне-
//       ния реального временного ряда от предсказанного авторегрессионным
//       уравнением , вычисление максимального отклонения реального временного
//       ряда от предсказанного авторегрессионныи уравнением */
//
//   for (j=kol_koeff, skv=0, max_otkl=0; j<N; j++)
//     {
//
////       for (i=0,s=0; i<kol_koeff; i++) s+=y[j-i-1]*a[i];
//
//
//       for (i=0,s=0; i<kol_koeff; i++) s+=y[j-i-1]*a[kol_koeff-1-i];
//
//       printf("\n y[ %ld ] = %12.5lf  Prdsk = %12.5lf    ", j, y[j], s);
//       otkl=fabs(y[j]-s);
//       skv+=otkl*otkl;
//       if (max_otkl<otkl) max_otkl=otkl;
//     }
//
//     skv/=(N-kol_koeff);
//     skv=sqrt(skv);
//
//    /* Выдать среднеквадратичного отклонение реального временного ряда от
//       предсказанного авторегрессионным уравнением */
//    printf(" \n\n  skv = %12.5lf  ",skv);
//    printf(" \n   max_otkl = %12.5lf  ",max_otkl);
//
//
//    /* Освободить блок памяти выделенный для хранения массива коэффициентов */
//    free(a);
//  }
//
//else
//  {
//    /* Поиск коэффициентов авторегрессионной модели прошел не удачно.
//       Выдача на экран предупреждающего сообщения.*/
//    printf("\n\n Коэффициенты авторегрессионной модели не найдены !!! \n\n");
//
//  }
//
//
//
///* Освободить блок динамической памяти хранящий результаты измерения
//   параметра y */
//free(y);
//
//
//}
//

