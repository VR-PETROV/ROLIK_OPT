/// Оптимизация роликового подшипника
///
///  Виды профилей задаются в файле исходных данных :
///
/// 	1. Цилиндрический с бомбиной и фаской
/// 	2. Лундберга
/// 	3. Апроксимации профиля Лундберга двумя окружностями
///	4. Цилиндрический с двумя бомбинами и фаской
///
///
/// Дополнительное увеличение ширины участка в стр.3738  на 6.
/// Вкл/выкл окаймление в стр.745

#include <stdio.h>
#include "bibl_c.cpp"
#include <string.h>


/// Описание глобальных констант
double 	pi = 3.14159;
double 	ak = 0.000305;	// Постоянная в зависимости между усилием и деформацией для стальных деталей.	?????????????

/////////////////////////////////////////////////////////////////////////////////////////////
///
int Kol_Param  = 100;	// Количество параметров целевой функции "rol_max_napr()".
///
/////////////////////////////////////////////////////////////////////////////////////////////

double XI_vk_v = 0.6;	// Коэффициент учитывающий разность длин сопрягаемого внутреннего кольца и вала
double XI_nk_k = 1.0;	// Коэффициент учитывающий разность длин сопрягаемого наружного кольца и корпуса
double G = 9810;	// Ускорение свободного падения в мм/с2
double Lambda;		// Коэффициент применяемый для расчёта долговечности по контактному напряжению

/// Описание глобальных переменных
FILE * f2;		// Дескриптор файла в который записываются протокол расчёта № 2.
FILE * f3;		// Дескриптор файла в который записываются протокол расчёта № 1.
double D1H;		// Диаметр подшипника внутренний в мм.
double DT;		// Диаметр подшипника наружный в мм.
double DM;		// Диаметр окружности по которой двигаются центры роликов в мм.
double Pm;		// Номинальный радиальный зазор в мм.
double P;		// Радиальный зазор в рабочих условиях в мм.	
int Priz_P_rab;		// Признак расчета радиального зазора в рабочих условиях.

int Z;			// Количество роликов в подшипнике.

double Dw;		// Диаметр ролика в мм.
double Rw;		// Радиус ролика в мм.
		
double Lw;		// Полная длина ролика в мм.
int vid_profil;		// Вид профиля ролика (1-Цилиндрический с бомбиной и фаской, 2-Лундберга, 3-Апроксимация профиля Лундберга 2 окружностями, 4- Цилиндрический с двумя бомбинами и фаской) 
double PBO;		// Свес бомбины в мм.
double R;		// Радиус кривизны бомбины ролика
int Priz_R_faska;	// Признак задания радиуса фаски
double dFx;		// Длина фаски
double dFy;		// Высота фаски
double Rf;		// Радиус кривизны фаски
double Q_Lund;		// Усилие в контакте используемое для формирования профиля Лундберга
double b_Lund;		// Половина длины полосы контакта используемая для формирования профиля Лундберга
double a_Lund;		// Половина ширины полосы контакта используемая для формирования профиля Лундберга
double S_d1_d2;		// Координата точки сопряжения дуг
double R_Lund_1;	// Радиус 1ой окружности апроксимирующей профиль Лундберга на участке 0 - S_d1_d2.
double R_Lund_2;	// Радиус 2ой окружности апроксимирующей профиль Лундберга на участке S_d1_d2 - Lw/2.
double koeff_toch_soprag;// Коэффициент используемый для определения точки сопряжения окружностей апроксимирующих профиль Лундберга.
double Xc1, Yc1;	// Координаты центра 1ой окружности апроксимирующей профиль Лундберга на участке 0 - S_d1_d2.
double Xc2, Yc2;	// Координаты центра 2ой окружности апроксимирующей профиль Лундберга на участке S_d1_d2.- Lw/2
double SL;		// Длина цилиндрической части ролика в мм.
double RL;		// Длина ролика без фасок в мм.
double DL_b1;		// Длина бомбины № 1
double PBO1;		// Свес бомбины  № 1
double SDW_B2;		// Сдвиг бомбины прямой линии на которой расположен центр кривизны бомбины № 2 относительно вертикальной средней линии ролика.
double PBO2;		// Свес бомбины № 2
double Rb1;		// Радиус кривизны бомбины № 1
double Rb2;		// Радиус кривизны бомбины № 2
double Xb2_c, Yb2_c;	// Координаты для центра кривизны бомбины № 2
double Xbf, Ybf;	// Координаты точки сопряжения бомбины и фаски.
double Xft, Yft;	// Координаты точки сопряжения торца и фаски.
double L1;		// Расстояние по оси Х от центра ролика до точки сопряжения бомбины № 1 и бомбины № 2
double Xfc,Yfc;		// Центр кривизны правой фаски ролика.			

double Bcs;		// Ширина перемычки сепаратора в мм.

double Rci;		// Внутренний радиус сепаратора  в мм.
double Dci;		// Димаметр внутренней цилиндрической поверхности сепаратора в мм.

double Rco;		// Наружный радиус сепаратора  в мм.
double Dco;		// Димаметр наружной цилиндрической поверхности сепаратора в мм.

double RM_sep;		// Средний радиус сепаратора в мм.

double Lc;		// Ширина сепаратора в мм

double Dcb;		// Диаметр центрирующей поверхности сепаратора (полосков) в мм с учетом распухания от действия центробежной силы м температурного расширения
double Lcb;		// Суммарная ширина обоих центрирующих полосков сепаратора в мм

double Okno_sep_H1;	// Ширина окна сепаратора в мм.
double Okno_sep_H2;	// Длина окна сепаратора в мм.

double Dbort;		// Диаметр бортика в мм.
double Cw;		// Средний зазор ролика в межколечном пространстве в мм.

double Rvk;		// Радиус дорожки качения внутреннего кольца в мм. 
double Dvk;		// Диаметр дорожки качения внутреннего кольца в мм.

double Rnk;		// Радиус дорожки качения наружного кольца в мм.
double Dnk;		// Диаметр дорожки качения наружного кольца в мм.

double Dc;		// Диаметр поверхности на дорожке качения кольца (наружного или внутреннего)  которая центрирует сепаратор в мм.

double RZM;		// Радиус дорожки качения внутреннего кольца без отклонения от идеальной формы (без сплюснутости).
double APO;		// Большая полуось эллипса профиля дорожки качения внутреннего кольца в мм. 
double BPO;		// Малая полуось эллипса профиля дорожки качения внутреннего кольца в мм. 
double FTT;		// Угол между малой полуосью эллипса профиля дорожки качения внутреннего кольца и направлением радиальной нагрузки в МИНУТАХ
double DZ;		// Диаметр отверстия полого вала в мм.	
double DDZ;		// Наружный диаметр корпуса в мм.	
double Rv_v;		// Внутренний радиус вала в мм.
double Rv_n;		// Наружный радиус вала в мм.
double Rvk_v;		// Внутренний радиус внутреннего кольца = наружному радиусу вала  в мм.
double Rnk_n;		// Наружный радиус наружного кольца = Наружный диаметр подшипника деленный на 2 = Диаметру посадочному отверстию корпуса деленному на 2  в мм.
double Rk_v;		// Внутренний радиус корпуса = наружному радиусу наружного кольца = наружному диаметру подшипника деленному на 2   в мм.
double Rk_n;		// Наружный радиус корпуса  в мм.

double RO_w;		// Плотность материала ролика в граммах/см3.
double RO_vk;		// Плотность материала внутреннего кольца в граммах/см3.
double RO_nk;		// Плотность материала наружного кольца в граммах/см3.
double RO_sep;		// Плотность материала сепаратора в граммах/см3
double RO_v;		// Плотность материала вала в граммах/см3.
double RO_k;		// Плотность материала корпуса в граммах/см3.

double RO1_w;		// Плотность материала ролика в кг/мм3
double RO1_vk;		// Плотность материала внутреннего кольца в кг/мм3
double RO1_nk;		// Плотность материала наружного кольца в кг/мм3
double RO1_sep;		// Плотность материала сепаратора в кг/мм3	
double RO1_v;		// Плотность материала вала в кг/мм3
double RO1_k;		// Плотность материала корпуса в кг/мм3

double RO1_maslo;	// Плотность масла в кг/мм3
double RO1_smes_rol;	// Плотность масловоздушной смеси для роликов в кг/мм3
double RO1_smes_sep;	// Плотность масловоздушной смеси для сепаратора в кг/мм3

double M_sep_kg;	// Масса сепаратора в кг.

double E_w;		// Модуль упругости материала ролика в кг/мм2
double E_vk;		// Модуль упругости материала внутреннего кольца в кг/мм2
double E_nk;		// Модуль упругости материала наружного кольца в кг/мм2
double E_sep;		// Модуль упругости материала сепаратора в кг/мм2

double E_v;		// Модуль упругости материала вала в кг/мм2
double E_k;		// Модуль упругости материала корпуса в кг/мм2

double EP_w;		// Коэффициент Пуассона материала ролика
double EP_vk;		// Коэффициент Пуассона материала внутреннего кольца
double EP_nk;		// Коэффициент Пуассона материала наружного кольца
double EP_sep;		// Коэффициент Пуассона материала сепаратора

double EP_v;		// Коэффициент Пуассона материала вала.
double EP_k;		// Коэффициент Пуассона материала корпуса

double E1_rol_vk;	// Эффективный модуль упругости для контакта ролика с дорожкой качения внутреннего кольца
double E1_rol_nk;	// Эффективный модуль упругости для контакта ролика с дорожкой качения наружного кольца

double At_r;		// Коэффициент температурного расширения материала ролика в 1/градус	
double At_vk;		// Коэффициент температурного расширения материала внутреннего кольца в 1/градус	
double At_nk;		// Коэффициент температурного расширения материала наружного кольца в 1/градус	
double At_sep;		// Коэффициент температурного расширения материала сепаратора в 1/градус

double At_v;		// Коэффициент температурного расширения материала вала 1/градус
double At_k;		// Коэффициент температурного расширения материала корпуса 1/градус

double Jw;		// Момент инерции ролика

double HB;		// Натяг в соединении вал-подшипник при монтаже в мм	
double HK;		// Натяг в соединении подшипник-корпус при монтаже в мм	

double RZB;		// Чистота обработки поверхности вала в мм	
double RZK;		// Чистота обработки поверхности корпуса в мм	 

double B_N;		// Частота вращения внутреннего кольца и вала в оборотах/минута	
double W_vk;		// Угловая скорость вращения внутреннего кольца и вала в радианах/секунда

double N_N;		// Частота вращения наружного кольца в оборотах/имнута
double W_nk;		// Угловая скорость вращения наружного кольца в радианах/секунда


double TN_epicikl;	// Частота вращения сепаратора эпициклическая в оборотах/минута.
double W_sep_epicikl;	// Угловая скорость вращения сепаратора эпициклическая в радианах/секунда

double N_w_epicikl;	// Частота вращения ролика в оборотах/минута эпициклическая 
double W_w_epicikl;	// Угловая скорость вращения ролика в радиан/секунда эпициклическая
	
double FR;		// Радиальная нагрузка в КГС
double FA;		// Осевая нагрузка в КГС

double TT;		// Угол перекоса внутреннего кольца 

double T_w;		// Рабочая температура ролика в градусах Цельсия
double T_vk;		// Рабочая температура внутреннего кольца в градусах Цельсия
double T_nk;		// Рабочая температура наружного кольца в градусах Цельсия
double T_v;		// Рабочая температура вала в градусах Цельсия.
double T_k;		// Рабочая температура корпуса в градусах Цельсия.

double T_maslo_vh;	// Температура масла на входе в подшипник в градусах Цельсия
double Tm;		// Температура монтажа подшипника в градусах Цельсия.

int Maslo;		// Номер масла
double Doly;		// Объемная доля масла в масловоздушной смеси
int vid_aprox;		// Номер вида апроксимации таблицы вязкости смазки в зависимости от температуры ( 1- Полином Лагранжа, 2- Формула Баруса, 3- Формула Роландса)
double N0;		// Динамическая вязкость смазки в кг*с/мм2  при нулевом давлении и начальной температуре (используется для определения вязкости в формуле Роландса).
double T0;		// Начальная температура (использщуется для определения вязкости в формуле Роландса)
double SS0;		// Термовязкостный параметр (используется для определения вязкости в формуле Роландса)
double Z1;		// Пъезовязкостный параметр (используется для определения вязкости в формуле Роландса)
double Patm;		// Атмосферное давление в кг/мм2 (используется для определения вязкости при атмосферном давлении в формуле Роландса)
double Gsdw;		// Модуль сдвига смазки в кг/мм2
double Pezo_koeff;	// Пъезокоэффициент вязкости смазки. Показывает зависимость вязкости от давления.

int N;				// Количество участков на которые разбита полная длина ролика.
double OM;			// Длина участка на которые разбита полная длина ролика.

int priz_sliyan_uch;		// Признак слияния участков накоторых мало изменяется деформация для уменьшения общего количества участков и увеличения скорости работы программы.
int Priz_napr_kray_effect;	// Признак определения напряжений в контакте ролика с дорожками качения наружного и внутреннего колец с учетом краевых эффектов
int Priz_profil_nk;		// Признак чтения профиля дорожки качения наружного кольца из файла PROF_NK.DAT
int kol_toch_profil_nk;		// Количество точек описывающих профиль дорожки качения наружного кольца

double koeff_shag_1;		// Коэффициент на который умножается шаг при шагании по методу Ньютона при решении уравнения равновесия ролика.
double koeff_shag_2;		// Коэффициент на который умножается шаг при шагании по методу Ньютона при решении уравнения равновесия внутр.кольца.
double koeff_shag_3;		// Коэффициент на который умножается шаг при шагании по методу Ньютона при нахождении распределения напряжений 

double Yb_cel;			// Значение целевой функции в базовой точке
double Y_cel;			// Значение целевой функции в текущей точке

int kol_wych_Y_cel;		// Количество вычислений целевой функции
int kol_popyt_wych_Y_cel;	// Количество попыток вычисления целевой функции 
int * priz_var_param = NULL;	// Указатель на область памяти в которой расположен массив признаков варируемых параметров.

double * xx = NULL;		// Указатель на область памяти в которой расположен массив параметров подшипника
double * hh = NULL;		// Указатель на область памяти в которой расположен массив величин шага изменения параметров подшипника.

double * xx_min = NULL;		// Указатель на область памяти в которой расположен массив нижних границ области изменения параметров подшипника.
double * xx_max = NULL;		// Указатель на область памяти в которой расположен массив верхних границ области изменения параметров подшипника.

double * xx_b = NULL;		// Указатель на область памяти в которой расположен массив базовых значений параметров подшипника.

double * QJ = NULL;		// Указатель на массив усилий в контакте всех роликов с внутренним кольцом.
double * QHU = NULL;		// Указатель на массив усилий в контакте всех роликов с наружным кольцом.

double * DEC = NULL;		// Указатель на массив эксцентриситетов нагрузки для всех роликов (Расcтояние от центра ролика до центра приложения нагрузки).

double * F1X = NULL;		// Указатель на массив сближений ролика с наружным кольцом.
double * F2X = NULL;		// Указатель на массив углов перекоса роликов в минутах.

double * F1V = NULL;		// Указатель на массив невязок уравнений равновесия сил действующих на ролик.
double * F2V = NULL;		// Указатель на массив невязок уравнений равновесия моментов действующих на ролик.

double * DB = NULL;		// Указатель на одномерный массив деформаций на участках контакта роликов с внутренним кольцом.
double * DH = NULL;		// Указатель на одномерный массив деформаций на участках контакта роликов с наружным кольцом.

double * Bv = NULL;		// Указатель на массив ширин вдоль полоски контакта ролика с внутренним кольцом.
double * Bn = NULL;		// Указатель на массив ширин вдоль полоски контакта ролика с наружным кольцом.

double * BVmax = NULL;		// Указатель на массив в котором записаны максимальные ширины полос контактов всех роликов с дорожкой качения внутреннего кольца
double * BNmax = NULL;		// Указатель на массив в котором записаны максимальные ширины полос контактов всех роликов с дорожкой качения наружного кольца 

double * Q_centr_0_I			= NULL;		// Указатель на массив нормальных усилий на участках центральной полосы 0 го ролика с дорожкой качения внутреннего кольца в кг.
double * P_centr_0_I			= NULL;		// Указатель на массив нормальных напряжений на участках центральной полосы 0 го ролика с дорожкой качения внутреннего кольца в кг/мм2
double * V_skol_poverh_centr_0_I	= NULL;		// Указатель на массив скоростей скольжения поверхностей на участках центральной полосы 0 го ролика с дорожкой качения внутреннего кольца в мм/сек.
double * U_kach_centr_0_I		= NULL;		// Указатель на массив скоростей качения на участках центральной полосы 0 го ролика с дорожкой качения внутреннего кольца в мм/сек.
double * t_centr_0_I			= NULL;		// Указатель на массив напряжений на участках центральной полосы 0 го ролика с дорожкой качения внутреннего кольца в кг/мм2
double * h_centr_0_I			= NULL;		// Указатель на массив толщин смазочной плёнки на участках центральной полосы 0 го ролика с дорожкой качения внутреннего кольца в мм.
double * Nr_centr_0_I			= NULL;		// Указатель на массив динамической вязкости на участках центральной полосы 0 го ролика с дорожкой качения внутреннего кольца в кг*сек/мм2
double * Def_0_I			= NULL;		// Указатель на массив деформаций на участках центральной полосы 0 го ролика с дорожкой качения внутреннего кольца в мм.

double * Q_centr_0_O			= NULL;		// Указатель на массив нормальных усилий на участках центральной полосы 0 го ролика с дорожкой качения наружного кольца в кг.
double * P_centr_0_O			= NULL;		// Указатель на массив нормальных напряжений на участках центральной полосы 0 го ролика с дорожкой качения наружного кольца в кг/мм2
double * V_skol_poverh_centr_0_O	= NULL;		// Указатель на массив скоростей скольжения поверхностей на участках центральной полосы 0 го ролика с дорожкой качения наружного кольца  в мм/сек.
double * U_kach_centr_0_O		= NULL;		// Указатель на массив скоростей качения на участках центральной полосы 0 го ролика с дорожкой качения наружного кольца в мм/сек.
double * t_centr_0_O			= NULL;		// Указатель на массив напряжений на участках центральной полосы 0 го ролика с дорожкой качения наружного кольца  в кг/мм2
double * h_centr_0_O			= NULL;		// Указатель на массив толщин смазочной плёнки на участках центральной полосы 0 го ролика с дорожкой качения наружного кольца  в мм.
double * Nr_centr_0_O			= NULL;		// Указатель на массив динамической вязкости на участках центральной полосы 0 го ролика с дорожкой качения наружного кольца в кг*сек/мм2
double * Def_0_O			= NULL;		// Указатель на массив деформаций на участках центральной полосы 0 го ролика с дорожкой качения наружного кольца в мм.

double * Vyaz_smazka			= NULL;		// Указатель на массив хранящий вязкость смазки при различных температурах.
double * Pezo_smazka			= NULL;		// Указатель на массив хранящий пъезокоэффициент вязкости смазки при различных температурах.	   	
double * Temp_smazka			= NULL;		// Указатель на массив хранящий ряд значений температур. 

double * k_lagr_vyaz			= NULL;		// Указатель на массив хранящий коэффициенты полинома Лагранжа задающего вязкость смазки при различных температурах
double * k_lagr_pezo			= NULL;		// Указатель на массив хранящий коэффициенты полинома Лагранжа задающего пъезокоэффициент вязкости смазки при различных температурах

/////////////////////////////////////////////////////////////////////////////////////////////////
///
double * Energ_def_rol			= NULL;		// Указатель на массив хранящий энергии деформации роликов
double * Dop_usil_sep			= NULL;		// Указатель на массив хранящий дополнительные усилия на перемычку сепаратора при втаскивании ролика в клин.
///
////////////////////////////////////////////////////////////////////////////////////////////////

int kol_toch_temp 	= 7;		// Количество значений температуры при которых измерена вязкость смазки и пъезокоэффициент

double 	* DB2 		= NULL;		// Указатель на двухмерный массив деформаций на участках контакта роликов с внутренним кольцом.
double 	* DH2 		= NULL;		// Указатель на двухмерный массив деформаций на участках контакта роликов с наружным кольцом.

double 	* SIGI 		= NULL;		// Указатель на одномерный массив средних напряжений на участках контакта всех роликов с внутренним кольцом.
double 	* SIGO 		= NULL;		// Указатель на одномерный массив средних напряжений на участках контакта всех роликов с наружным кольцом.

int 	* priz_uch 	= NULL;		// Указатель на массив признаков использования участков.
double 	* FCOP 	   	= NULL;		// Указатель на массив значений центробежныой сиды действующей на ролики.

double 	* SIGI_max 	= NULL;		// Указатель на массив максимальных напряжений в контакте всех роликов с внутренним кольцом (используется для случая когда зона контакта накрыта полоской).
double 	* SIGO_max 	= NULL;		// Указатель на массив максимальных напряжений в контакте всех роликов с наружным кольцом (используется для случая когда зона контакта накрыта полоской).

double 	* SIGI_max_u 	= NULL;		// Указатель на массив максимальных напряжений на участках в контакте всех роликов с внутренним кольцом.
double 	* SIGO_max_u 	= NULL;		// Указатель на массив максимальных напряжений на участках в контакте всех роликов с наружным кольцом.

double 	* SIGI2 	= NULL;		// Указатель на двухмерный массив напряжений на участках контакта всех роликов с внутреннего кольцом.
double 	* SIGO2 	= NULL;		// Указатель на двухмерный массив напряжений на участках контакта всех роликов с наружным кольцом.

int 	* k_sl 		= NULL;		// Указатель на массив коэффициентов слияния для участков исходного равномерного разбиения
int 	* k_sl1 	= NULL;		// Указатель на вспомогательный массив коэффициентов слияния

int 	* priz_uch_neravn = NULL;	// Указатель на массив признаков использования неравномерных участков.
double 	* NAPR_neravn 	  = NULL;	// Указатель на массив напряжений на неравномерных участках.
double 	* profil 	  = NULL;	// Указатель на массив в котором записан профиль ролика
double 	* F_rol_sep 	  = NULL;	// Указатель на массив в который записываются силы действующие на перемычку сепаратора со стороны роликов
double 	* F_tr_rol_sep 	  = NULL;	// Указатель на массив в который записываются силы трения в контактах роликов с перемычками сепаратора

double 	k_rast0[20];			// Коэффициенты для пересчета расстояния участка от самого до себя для участков различной кратной длины.
double 	B;				// Начальное приближение угла перекоса ролика.
double 	DF;				// Начальное приближение сближения ролика с наружным кольцом.
int 	Kol_Var_Param;			// Количество варьируемых параметров 
int 	max_nom_okaim;			// Толщина окаймления.
int 	nom_tab=1;			// Номер таблицы

int 	* kol_neravn_uch_polosa = NULL;	// Указатель на массив для записи количества участков на полосе при новом неравномерном разбиении.
int 	* swaz_neravn_ravn 	= NULL;	// Указатель на массив устанавливающий связь между участками при равномерном и неравномерном разбиении.
double 	* prav_gr_neravn_uch 	= NULL;	// Указатель на массив правых границ неравномерных участков на которые разбивается полоса 
double 	* DEF_neravn 		= NULL;	// Указатель на массив деформаций на неравномерных участках.

double * matr_mnk  = NULL;		/// Указатель на матрицу используемую для поиска термокоэффициента формулы Баруса с помощью МНК
double * stolb_mnk = NULL;		/// Указатель на столбец используемый для поиска термокоэффициента формулы Баруса с помощью МНК
double * koeff_mnk = NULL;		/// Указатель на столбец коэффициентов найденных по МНК	

long	N_matr_mnk = 1;				/// Длина матрицы "matr_mnk"   (должна быть равна 1).
long	M_matr_mnk = (long) kol_toch_temp;	/// Высота матрицы "matr_mnk"  (количество строк в матрице, количество измерений температуры).

long	N_stolb_mnk = 1;		/// Длина столбца "stolb_mnk"  (должна быть равна 1)
long    M_stolb_mnk = kol_toch_temp;	/// Высота столбца "stolb_mnk" (равно количеству столбцов в матрице "matr_mnk", количество измерений температуры)  	

long	N_koeff_mnk;			/// Количество столбцов в "koeff_mnk" (должно быть равно 1)	 
long	M_koeff_mnk;			/// Количество строк в "koeff_mnk"

double Termo_koeff_Barus = 0.0;		/// Термокоэффициент формулы Баруса
double Koeff_exp_pezo	 = 0.0;		/// Коэффициент на который умножается степень экспоненты используемой для поиска пъезокоэффицента формула Баруса

int kol_uch_shirina;			/// Количество участков накрывающих ширину области контакта.
int kol_uch_polushirina;		/// Количество участков накрывающих полуширину области контакта.

int nom_centr_polosy_zona_kontakt;	/// Номер центральной полосы области контакта, где самые большие деформации

struct rezult_Ycel 			/// Структура используемая для хранения значения аргументов и значения целевой функции
{
	double Ycel;			/// Значение целевой функции
	double * xx;			/// Ссылка на массив вещеcтвенных чисел из Kol_Param элементов в котором записываются аргументы целевой функции
	struct rezult_Ycel * next;	/// Ссылка на следующий элемент списка структур "rezult_Ycel"
};

struct rezult_Ycel * u_nach;		/// Указатель на начало списка значений целевой функции

double * profil_nk 		= NULL;		/// Указатель на массив в который записывается профиль дорожки качения наружного кольца
double * aa	   		= NULL;		/// Указатель на массив в который записываются коэффициенты ряда Фурье описывающего профиль дорожки качения наружного кольца	
double * sum_fure_profil_nk 	= NULL;		/// Указатель на массив в который записываются сумма ряда Фурье описывающего профиль дорожки качения наружного кольца.  	
double	sred_R_nk_fure;                 	/// Средний радиус наружного кольца определённый как сумма ряда Фурье описывающего профиль

int 	nom_rolik_QJ_max;			/// Номер самого нагруженного ролика в контакте с дорожкой качения внутреннего кольца
double	QJ_max;					/// Нагрузка в кг в контакте самого нагруженного ролика с дорожкой качения внутреннего кольца



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////    ФУНКЦИЯ ВЫПОЛНЯЮЩАЯ БЫСТРОЕ ПРЕОБРАЗОВАНИЕ ФУРЬЕ    //////////////////////////////////////////////////////////////////
///
///		Входные параметры :		a - 	Указатель на массив содержащий отсчеты исходной последовательности 
///							предназначенной для преобразованимя Фурье
///
///						a[0] = Отсчет № 0   
///						a[1] = 0.0
///
///						a[2] = Отсчет № 1   
///						a[3] = 0.0
///
///						a[4] = Отсчет № 2   
///						a[5] = 0.0
///
///						a[6] = Отсчет № 3   
///						a[7] = 0.0
///
///						. . . . . . . . . .
///
///						a[2*MAX_SIZE_OBR-2] = Отсчет № N-1   
///						a[2*MAX_SIZE_OBR-1] = 0.0
///
///		
///						MAX_SIZE_OBR - Количество отсчетов 
///		
///						
///		Выходные параметры :		a - Указатель на массив содержащий результаты БПФ (коэффициенты ряда Фурье)	
///
///						a[0] - Свободный член      
///						a[1] - ????	
///
///						a[2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 1 )
///						a[3] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 1 )	
///		
///						a[4] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 2 )
///						a[5] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 2 )	
///
///						a[6] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 3 )
///						a[7] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 3 )	
///		
///						. . . . . . . . . .
///
///						a[2*MAX_SIZE_OBR-2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * (N-1) )
///						a[2*MAX_SIZE_OBR-1] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * (N-1) )	
///
///
///	Возвращаемое значекние	:	Нет
///
///

void bpf( double * a, unsigned long MAX_SIZE_OBR)
{

double drob_chast_kol_etapov, kol_etapov_double;
unsigned long kol_etap, j, m, i, k, nom_etap, razm_uchast, pol_razm_uchast, kol_uchast, nom_uchast, ukaz_el1, ukaz_el2 ; 
double a0, a1, pi_2_del_razm_uchast, pi_2_k_del_razm_uchast;

// Определить число этапов БПФ.
drob_chast_kol_etapov = modf(log(MAX_SIZE_OBR)/log(2.0),&kol_etapov_double);
kol_etap= (unsigned long) kol_etapov_double;
if (drob_chast_kol_etapov>0.98) kol_etap++;


/// Выполнить двоично-инверсную перестановку элементов массива a[][] содержащего входную последовательность.
j=0;
m = (unsigned long) MAX_SIZE_OBR/2;

for (i=0; i<MAX_SIZE_OBR; i++)
{
	if (j>i)
	{
		a0= *(a+j*2);
		*(a+j*2) = *(a+i*2);
		*(a+i*2) = a0; 
	}

	k=m;

	while ((j>=k) && !((j==0)&&(k==0)))
	{
		j-=k;
		k/=2;
	}

	j+=k;
}

/// Выполнить БПФ над последовательностью записанной в массиве a[][].
for (nom_etap=1, razm_uchast=2; nom_etap<=kol_etap; nom_etap++, razm_uchast*=2)
{
	pol_razm_uchast=razm_uchast/2;
	kol_uchast=MAX_SIZE_OBR/razm_uchast;
	pi_2_del_razm_uchast= (double) pi /(double) razm_uchast * 2;

	for (nom_uchast=0; nom_uchast<kol_uchast; nom_uchast++)
	{
		for (k=0,ukaz_el2=nom_uchast*razm_uchast+pol_razm_uchast; k<pol_razm_uchast; k++, ukaz_el2++)
		{
			pi_2_k_del_razm_uchast= pi_2_del_razm_uchast*k;
			a0= *(a+ukaz_el2*2);
			*(a+ukaz_el2*2) = *(a+ukaz_el2*2)* cos(pi_2_k_del_razm_uchast)+ *(a+ukaz_el2*2+1)* sin(pi_2_k_del_razm_uchast);
			*(a+ukaz_el2*2+1) = *(a+ukaz_el2*2+1)*cos(pi_2_k_del_razm_uchast)-a0*sin(pi_2_k_del_razm_uchast);
		}

		for (k=0,ukaz_el1=nom_uchast*razm_uchast,ukaz_el2=ukaz_el1+pol_razm_uchast; k<pol_razm_uchast; k++,ukaz_el1++,ukaz_el2++)
		{
			a0 = *(a+ukaz_el1*2);
			a1 = *(a+ukaz_el1*2+1);
			*(a+ukaz_el1*2) += *(a+ukaz_el2*2);
			*(a+ukaz_el1*2+1) += *(a+ukaz_el2*2+1);
			*(a+ukaz_el2*2) = a0 - *(a+ukaz_el2*2);
			*(a+ukaz_el2*2+1) = a1 - *(a+ukaz_el2*2+1);
		}
	}
}


/// Найденные  коэффициенты ряда Фурье разделить на MAX_SIZE_OBR и MAX_SIZE_OBR/2
for (i=0; i< MAX_SIZE_OBR/2; i++)
{
	a[i*2]	 =  2.0 * a[i*2]   / (double) MAX_SIZE_OBR ;
	a[i*2+1] = -2.0 * a[i*2+1] / (double) MAX_SIZE_OBR ;
}

return;		/// Выход из процедуры БПФ

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////     ФУНКЦИЯ ВЫЧИСЛЯЮЩАЯ СУММУ РЯДА ФУРЬЕ	  /////////////////////////////////////////////////////
///
///		Входные параметры :	a - Указатель на массив содержащий коэффициенты ряда Фурье
///
///					a[0] - Свободный член      
///					a[1] - ????	
///
///					a[2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 1 )
///					a[3] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 1 )	
///		
///					a[4] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 2 )
///					a[5] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 2 )	
///                                     
///					a[6] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 3 )
///					a[7] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 3 )	
///		
///					. . . . . . . . . .
///
///					a[2*MAX_SIZE_OBR-2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * (N-1) )
///					a[2*MAX_SIZE_OBR-1] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * (N-1) )	
///
///
///					N - Количество отсчетов на интервале разложения функции в ряд Фурье
///
///				        X - Номер отсчета для которого надо найти сумму ряда Фурье (вещественное число)
///								
///
///		Выходные параметры :	Нет	
///
///	     Возвращаемое значение :	Сумма ряда Фурье для отсчёта № X
///
///

double fure(double * a, int N, double X )
{

int k;		// Счетчик цикла
double S;	// Сумма ряда Фурье

// Подсчет суммы ряда Фурье для отсчета X
S=0.0;
S += a[0]/2.0;
for (k=1; k<N/2; k++) S += (a[k*2] * cos(2*pi* (double) k / (double) N * X ) + a[k*2+1] * sin(2*pi* (double) k / (double) N * X) );

// Выход из функции с возвратом найденной суммы ряда Фурье
return S;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////			ФУНКЦИЯ ВЫЧИСЛЯЮЩАЯ СРЕДНЕЕ РАССТОЯНИЕ ПРЯМОУГОЛЬНОЙ ЗОНЫ ОТ САМОЙ ДО СЕБЯ					///////
///
///	Входные параметры :	l - Длина зоны
///				m - Ширина зоны
///				N - Количество участков по длине зоны		
///				M - Количество участков по ширине зоны						
///
///	Возвращаемое значение : r0 - Среднее растояние зоны самой от себя.
///
///

double rastoyan0( double l, double m, int N, int M )
{

double Xc, Yc;	// Коордитнаты центра участка
double dx;	// Длина участка вдоль оси Х
double dy;	// Длина участка вдоль оси Y
double r0;	// Расстоянте участка от самого до себя.
int i, j;	// Счетчики

// Определить координаты центра участка
Xc = l/2;
Yc = m/2;

// Определить длину участка по горизонтали
dx = l/N;

// Определить длину участка по вертикали
dy = m/M;

// Обнулить расстояние зоны самой от себя.
r0 = 0;

// Определить сумму от центра зоны до всех узлов решетки
for (i=0; i<N; i++)
	for (j=0; j<M; j++)
		r0 += sqrt(sqr(i*dx-Xc) + sqr(j*dy-Yc));

r0 /= (N*M);

// Возврат среднего расстояния зоны самой от себя
return r0;

}

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////  ФУНКЦИЯ ВЫВОДА МАТРИЦЫ ///////////////////////////////////
//
//    Параметры :   * matr - Указатель на начало блока памяти в котором
//							 храниться матрица.
//
//			N  - Количество столбцов в матрице.
//
//			M  - Количество строк в матрице.
//
//

void wyw_matr_file( double * matr , long N, long M )

{

long i,j;

for (j=0;j<M;j++)
 {
	fprintf(f2,"\n");
	for (i=0;i<N;i++)
	{
		fprintf(f2," %7.3f", *(matr+j*N+i) );
	}

 }

}


////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////		РАСЧЕТ РАДИАЛЬНОГО ЗАЗОРА В РАБОЧИХ УСЛОВИЯХ		////////////////////////
//
//
//	Входные параметры : 
//
//	Rv1	- Внутренний радиус вала								/ мм / 
//	Rn1	- Наружный радиус вала (посадочный на внутреннее кольцо)				/ мм / 
//	EP1	- Коэффициент Пуассона материала вала.
//	E1	- Модуль упругости материала вала							/ кгс/мм2 /
//	RO1	- Плотность материала вала								/ кг/мм3 /
//	A1	- Коэффициент линейного теплового расширения вала					/ 1/Градус C /
//	T1	- Температура вала в рабочих условиях в градусах Цельсия				/ Градус C /
//
//	Rv2	- Внутренний радиус внутреннего кольца (посадочный на вал)				/ мм /
//	Rn2	- Наружный радиус внутреннего кольца   (радиус дорожки качения внутреннего кольца)	/ мм /
//	EP2 	- Коэффициент Пуассона материала внутреннего кольца
//	E2	- Модуль упругости материала внутреннего кольца						/ кгс/мм2 /
//	RO2	- Плотность материала внутреннего кольца						/ кг/мм3 /
//	A2	- Коэффициент линейного теплового расширения внутреннего кольца				/ 1/Градус C /
//	T2	- Температура внутреннего кольца в рабочих условиях в градусах Цельсия			/ Градус C /
//
//	Rv3	- Внутренний радиус наружного кольца  (радиус дорожки качения наружного кольца)		/ мм /
//	Rn3	- Наружный радиус наружного кольца (посадочный в корпус)				/ мм /
//	EP3 	- Коэффициент Пуассона материала наружного кольца
//	E3	- Модуль упругости материала наружного кольца						/ кгс/мм2 /
//	RO3	- Плотность материала наружного кольца							/ кг/мм3 /
//	A3	- Коэффициент линейного теплового расширения наружного кольца				/ 1/Градус C /
//	T3	- Температура наружного кольца в рабочих условиях в градусах Цельсия			/ Градус C /
//
//	D4	- Диаметр тела качения									/ мм /
//	EP4	- Коэффициент Пуассона материала тел качения				
//	E4	- Модуль упругости материала тел качения						/ кгс/мм2 /
//	RO4	- Плотность материала  тел качения							/ кг/мм3 /
//	A4	- Коэффициент линейного теплового расширения тел качения				/ 1/Градус C /
//	T4	- Температура тел качения в рабочих условиях в градусах Цельсия				/ Градус C /
//
//	Rv5	- Внутренний радиус корпуса (посадочный на наружное кольцо)				/ мм /
//	Rn5	- Наружный радиус корпуса								/ мм /
//	EP5	- Коэффициент Пуассона материала корпуса				
//	E5	- Модуль упругости материала корпуса							/ кгс/мм2 /
//	RO5	- Плотность материала корпуса								/ кг/мм3 /
//	A5	- Коэффициент линейного теплового расширения материала корпуса				/ 1/Градус C /	
//	T5	- Температура корпуса в рабочих условиях в градусах Цельсия				/ Градус C /
//
//	XI12	- Коэффициент учитывающий разность длин сопрягаемого внутреннего кольца и вала	
//	XI35	- Коэффициент учитывающий разность длин сопрягаемого наружного кольца и корпуса	
//
//	G	- Ускорение свободного падения								/ мм/с2	/ 
//	W12	- Частота вращения вала и внутреннего кольца						/ радиан/секунда / 
//  	W35	- Частота вращения наружного кольца 							/ радиан/секунда / 
//	D12	- Натяг в месте посадки внутреннего кольца на вал при монтаже				/ мм /
//	D35	- Натяг в месте посадки наружного кольца в корпус при монтаже				/ мм /
//	DEO	- Номинальный радиальный зазор в подшипнике						/ мм /
//	Tm	- Температура монтажа в градусах Цельсия						/ Градус C /
//
//
//
// Возвращаемое значение :	Радиальный зазор в подшипнике в рабочих условиях / мм /
//	
//	

double Rab_rad_zazor(	double Rv1, double Rn1, double EP1, double E1,	double RO1, double A1, 	double T1,					 
						double Rv2, double Rn2, double EP2, double E2,	double RO2, double A2, 	double T2,
						double Rv3, double Rn3, double EP3, double E3,	double RO3, double A3, 	double T3,
						double D4, 		double EP4, double E4,	double RO4, double A4, 	double T4,
						double Rv5, double Rn5,	double EP5, double E5,	double RO5, double A5, 	double T5,	
						double XI12,double XI35,double G,   double W12, double W35, double D12, double D35, double DEO, double Tm )

{

double R1;	// Срединный радиус вала
double R2;	// Срединный радиус внутреннего кольца
double R3;	// Срединный радиус наружного кольца
double R4;	// Радиус тела качения
double R5;	// Срединный радиус корпуса

double k1;	// Коэффициент толстостенности вала
double k2;	// Коэффициент толстостенности внутреннего кольца
double k3;	// Коэффициент толстостенности наружного кольца
double k5;	// Коэффициент толстостенности корпуса

double Comp1;	// Вспомогательная константа материала вала.
double Comp2;	// Вспомогательная константа материала внутреннего кольца
double Comp3;	// Вспомогательная константа материала наружного кольца.
double Comp5;	// Вспомогательная константа материала корпуса.

double Uw1;	// Радиальное перемещение вала от действия центробежной силы (распухание вала)
double Ut1;	// Радиальное перемещение вала от нагрева (тепловое расширение вала)
double Up1;	// Радиальное перемещение вала от давления со стороны внутреннего кольца (при посадке с натягом)

double Uw2;	// Радиальное перемещение внутреннего кольца от действия центробежной силы (распухание)
double Ut2;	// Радиальное перемещение внутреннего кольца от нагрева (тепловое расширение внутреннего кольца)
double Up2;	// Радиальное перемещение внутреннего кольца от давления со стороны вала  (при посадке с натягом)
double U2;	// Радиальное смещение внутреннего кольца (с учетом влияния вала)

double Y12;	// Натяг в месте посадки внутреннего кольца на вал /мм/.
double p12;	// Давление от натяга при посадке внутреннего кольца на вал.

double Y35;	// Нагяг в месте посадки наружного кольца в корпус /мм/.
double p35;	// Давление от натяга при посадке наружного кольца в корпус.
double Uw3;	// Радиальное перемещение наружного кольца от действия центробежной силы (распухание)

double Ut3;	// Радиальное перемещение наружного кольца из за действия температуры (тепловое расширение наружного кольца). 
double Up3;	// Радиальное перемещение наружного кольца от давления со стороны корпуса (при посадке с натягом наружного кольца в корпус).
double U3;	// Полное радиальное перемещение наружного кольца. 

double U4;	// Приращение радиуса тел качения из за действия температуры
double DE;	// Рабочий радиальный зазор в подшианике
double Uw5;	// Радиальное перемещение корпуса от действия центробежной силы (распухание)


double Ut5;	// Радиальное перемещение корпуса от нагрева (тепловое расширение корпуса).
double Up5;	// Радиальное перемещение корпуса от давления со стороны наружного кольца (при посадке с натягом наружного кольца в корпус).

double DELT1;	// Разность температуры вала в рабочих условиях и при монтаже 
double DELT2;	// Разность температуры внутреннего кольца в рабочих условиях и при монтаже
double DELT3;	// Разность температуры наружного кольца в рабочих условиях и при монтаже.
double DELT4;	// Разность температыры тел качения в рабочих условиях и при монтаже.
double DELT5;	// Разность температур корпуса в рабочих условиях и при монтаже.


// Разность температур вала в рабочих условиях и при монтаже.
DELT1 = T1 - Tm;

// Разность температур внутреннего кольца в рабочих условиях и при монтаже.
DELT2 =	T2 - Tm;

// Разность температур наружного кольца в рабочих условиях и при монтаже.
DELT3 = T3 - Tm;

// Разность температур тел качения в рабочих условиях и при монтаже.
DELT4 = T4 - Tm;

// Разность температур корпуса в рабочих условиях и при монтаже.
DELT5 = T5 - Tm;


// Определить срединный радиус вала
R1 = 0.5*(Rv1+Rn1);

// Опредилить срединный радиус внутреннего кольца.
R2 = 0.5*(Rv2+Rn2);

// Опредилить срединный радиус наружного кольца.
R3 = 0.5*(Rv3+Rn3);

// Определить радиус тела качения.
R4 = 0.5*D4;

// Определить срединный радиус корпуса.
R5 = 0.5*(Rv5+Rn5);



// Определить коэффициент толстостенности вала.
k1 = Rv1/Rn1;

// Определить коэффициент толстостенности внутреннего кольца.
k2 = Rv2/Rn2;

// Определить коэффициент толстостенности наружного кольца.
k3 = Rv3/Rn3;

// Определить коэффициент толстостенности корпуса.
k5 = Rv5/Rn5;



// Определить вспомогательную константу материала вала.
Comp1 = (1+k1*k1)/(1-k1*k1)-EP1;

// Определить вспомогательную константу материала внутреннего кольца.
Comp2 = (1+k2*k2)/(1-k2*k2)+EP2;

// Определить вспомогательную константу материала наружного кольца.
Comp3 = (1+k3*k3)/(1-k3*k3)-EP3;

// Определить вспомогательную константу материала корпуса.
Comp5 = (1+k5*k5)/(1-k5*k5)+EP5;


// Определить радиальное перемещение вала от действия центробежной силы (распухание вала) формула (3.2)
Uw1 = (RO1*W12*W12*R1*R1*R1)/(4*G*E1)*(1-EP1+(3+EP1)*k1*k1);

// Определить радиальное перемещение вала от нагрева (тепловое расширение вала) формула (3.3)
Ut1 = A1 * R1 * DELT1;

// Определить радиальное перемещение внутреннего кольца от действия центробежной силы (распухание) формула (3.5)
Uw2 = (RO2*W12*W12*R2*R2*R2)/(G*E2);

// Определить радиальное перемещение внутреннего кольца от нагрева (тепловое расширение внутреннего кольца) формула (3.6)
Ut2 = A2 * R2 * DELT2;

// Определить натяг в рабочих условиях в месте посадки внутреннего кольца на вал. формула (2.1)
Y12 = 0.5*D12 + (Uw1 + Ut1 - Uw2 - Ut2);


if (Y12 > 0)
{
	// Есть натяг в месте посадки внутреннего кольца на вал.

	// Определить давление от натяга при посадке внутреннего кольца на вал.
	p12 = Y12/(Rv2/E2*Comp2 + XI12*Rn1/E1*Comp1);

	// Определить радиальное перемещение вала от давления со стороны внутреннего кольца (при посадке с натягом)
	// формула (3.1) ???? должно равняться Up2 по модулю.
	Up1 = -XI12*p12*Rn1/E1*Comp1;

	// Определить радиальное перемещение внутреннего кольца от давления со стороны вала  (при посадке с натягом)
	// формула (3.4)
	Up2 = p12*Rv2/E2*Comp2;
}
else
{
	// Нет натяга (есть зазор) в месте посадки внутреннего кольца на вал.

	// Отсуствует давление от натяга при посадке внутреннего кольца на вал
	p12 = 0.0;

	// Отсуствует радиальное перемещение вала от давления со стороны внутреннего кольца
	Up1 = 0.0;

	// Отсуствует радиальное перемещение внутреннего кольца от давления со стороны вала.
	Up2 = 0.0;
}


// Определить полное радиальное смещение внутреннего кольца  с учетом влияния вала формула 2.3  или 
// без учета влияния вала формула 3.7.
U2 = Up2 + Uw2 + Ut2;

// Определить радиальное перемещение наружного кольца от действия центробежной силы
Uw3 = (RO3*W35*W35*R3*R3*R3)/(G*E3);

// Определить радиальное перемещение наружного кольца из за действия температуры 
// (тепловое расширение наружного кольца) формула 3.10
Ut3 = A3 * R3 * DELT3;

// Определить приращение радиуса тел качения из за действия температуры формула похожая на (3.9)
U4 = A4 * R4 * DELT4;

// ????? Почему нет приращения радиуса тел качения из за действия центробежной силы


// Определить радиальное перемещение корпуса от действия центробежной силы (распухание корпуса).
Uw5 = (RO5*W35*W35*R5*R5*R5)/(4*G*E5)*(1-EP5+(3+EP5)*k5*k5);

// Определить радиальное перемещение корпуса от нагрева (тепловое расширение корпуса).
Ut5 = A5 * R5 * DELT5;

// Определить натяг в рабочих условиях в месте посадки наружного кольца в корпус. 
Y35 = 0.5*D35 + Uw3 + Ut3 - Uw5 - Ut5;


if (Y35 > 0)
{
	// Есть натяг в месте посадки наружного кольца в корпус.

	// Определить давление от натяга при посадке наружного кольца в корпус.
	p35 = Y35/(Rv5/E5*Comp5 + XI35*Rn3/E3*Comp3);

	// Определить радиальное перемещение наружного кольца от давления со стороны корпуса (при посадке с натягом)
	Up3 = -XI35*p35*Rn3/E3*Comp3;		

	// Определить радиальное перемещение корпуса от давления со стороны наружного кольца (при посадке с натягом).
	Up5 = p35*Rv5/E5*Comp5;
}
else
{
	// Нет натяга (есть зазор) в месте посадки наружного кольца в корпус.

	// Отсуствует давление от натяга при посадке наружного кольца в корпус.
	p35 = 0.0;
	
	// Отсуствует радиальное перемещение наружного кольца от давления со стороны корпуса.
	Up3 = 0.0;

	// Отсуствует радиальное перемещение корпуса от давления со стороны наружного кольца.
	Up5 = 0.0;
}


// Определить полное радиальное перемещение наружного кольца.
U3 = Up3 + Uw3 + Ut3;

// Определить рабочий радиальный зазор в подшипнике
DE = DEO + 2*U3 - 2*U2 - 4*U4;


// Выдать результаты расчета
fprintf(f2,"\n													");
fprintf(f2,"\n						Результаты расчета радиального зазора     		");
fprintf(f2,"\n					---------------------------------------------	   		");
fprintf(f2,"\n Разность температур вала в раб.усл.и при монтаже            / Градус C / DELT1 = %8.5f ", DELT1);
fprintf(f2,"\n Рад.перемещение вала от центробежной силы (распухание вала) / мм /       Uw1   = %8.5f ", Uw1);
fprintf(f2,"\n Рад.перемещение вала от нагрева (тепловое расширение вала)  / мм /       Ut1   = %8.5f ", Ut1);
fprintf(f2,"\n Рад.перемещение вала от давления со стороны внутр.кольца    / мм /       Up1   = %8.5f ", Up1);
fprintf(f2,"\n Натяг в раб.условиях в месте посадки внутр.кольца на вал    / мм /       Y12   = %8.5f ", Y12);
fprintf(f2,"\n Давление от натяга при посадке внутреннего кольца на вал    / ?? /       p12   = %8.5f ", p12);
fprintf(f2,"\n													  ");	
fprintf(f2,"\n Разность температур внутр.кольца в раб.усл.и при монтаже    / Градус C / DELT2 = %8.5f ", DELT2);
fprintf(f2,"\n Рад.перемещение внутр.кольца от действия центробежной силы  / мм /       Uw2   = %8.5f ", Uw2);
fprintf(f2,"\n Рад.перемещение внутр.кольца от нагрева (тепл.расширение)   / мм /       Ut2   = %8.5f ", Ut2);
fprintf(f2,"\n Рад.перемещение внутр.кольца от давления со стороны вала    / мм /       Up2   = %8.5f ", Up2);
fprintf(f2,"\n Полное радиальное смещение внутр.кольца                     / мм /       U2    = %8.5f ", U2);
fprintf(f2,"\n													  ");	
fprintf(f2,"\n Разность температур наруж.кольца в раб.усл.и при монтаже    / Градус C / DELT3 = %8.5f ", DELT3);
fprintf(f2,"\n Рад.перемещение наруж.кольца от действия центробежной силы  / мм /       Uw3   = %8.5f ", Uw3);
fprintf(f2,"\n Рад.перемещение наруж.кольца от нагрева (тепл.расширение)   / мм /       Ut3   = %8.5f ", Ut3); 
fprintf(f2,"\n Рад.перемещение наруж.кольца от давления со стороны корпуса / мм /       Up3   = %8.5f ", Up3);
fprintf(f2,"\n Полное радиальное перемещение наружного кольца              / мм /       U3    = %8.5f ", U3); 
fprintf(f2,"\n													     ");	
fprintf(f2,"\n Радиус тела качения                                         / мм /       R4    = %8.5f ", R4);
fprintf(f2,"\n Разность температур тел качения в раб.усл.и при монтаже     / Градус C / DELT4 = %8.5f ", DELT4);
fprintf(f2,"\n Изменение радиуса тел качения от нагрева                    / мм /       U4    = %8.5f ", U4);
fprintf(f2,"\n													     ");	
fprintf(f2,"\n Разность температур корпуса в раб.усл. и при монтаже        / Градус C / DELT5 = %8.5f ", DELT5);
fprintf(f2,"\n Рад.перемещение корпуса от центробежной силы (распухание)   / мм /   	Uw5   = %8.5f ", Uw5);
fprintf(f2,"\n Рад.перемещение корпуса от давления со стороны наруж.кольца / мм /       Up5   = %8.5f ", Up5);
fprintf(f2,"\n Рад.перемещение корпуса от нагрева (тепл.расширение)        / мм /       Ut5   = %8.5f ", Ut5); 
fprintf(f2,"\n Натяг в рабочих условиях в месте наружного кольца в корпус  / мм /       Y35   = %8.5f ", Y35);
fprintf(f2,"\n Давление от натяга при посадке наружного кольца в корпус    / ?? /       p35   = %8.5f ", p35);
fprintf(f2,"\n													     ");	
fprintf(f2,"\n Раб.радиал.зазор в подшипнике  DE = DEO+2*U3-2*U2-4*U4;     / мм /       DE    = %9.6f ", DE);
fprintf(f2,"\n\n												     ");	

// Получить диаметр ролика с учетом теплового расширения
//* Drol = 2*R4 + 2*U4;


// Возвратить расcчитанный рабочий радиальный зазор
return DE;

}

////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////			ВЫЧИСЛЕНИЕ ФУНКЦИИ ЛУНДБЕРГА		////////////////////////////
//
//
//	Входные параметры :	Q - Усилие в контакте
//						L - Рабочая длина ролика
//						a - Полуширина полосы контакта
//						b - Полудлина полосы контакта
//						y - Координата точки			
//

double Lundberg( double Q, double L, double a, double b, double y)
{
	double P;

	P = 2*Q*(1-EP_w*EP_w)/(pi*L*E_w)*log(1/(1-(1-EP_w*a/b)*sqr(2*y/L)));
	return P;
}

//////////////////////////////////////////////////////////////////////////////////////////
/////////////	ФУНКЦИЯ ПОИСКА ТОЧЕК ПЕРЕСЕЧЕНИЯ ДВУХ ОКРУЖНОСТЕЙ	//////////////////
//
//	Входные параметры:	X1,Y1	- Координаты центра 1ой окружности
//							R1	- Радиус 1ой окружности	
//
//				X2,Y2	- Координаты центра 2ой окружности	
//					R2	- Радиус 2ой окружности	
//
//
//	Выходные параметры:	Xc1,Yc1 - Координаты первой точки пересечения двух окружностей
//						Xc2,Yc2 - Координаты второй точки пересечения двух окружностей		
//
//
//	Возвращаемое значение :	Количество точек пересечения ( 0-2 )
//
//

int poisk_peresech_dvuh_okrug( double X1, double Y1, double R1, double X2, double Y2, double R2, double * Xc1, double * Yc1, double * Xc2, double * Yc2)
{

double D;	// Растояние между центрами 1ой  и 2ой окружностей
double B;	// Длина 1го катера второго прямоугольного треугольника
double A;	// Длина 1го катета первого прямоугольного треугольника
double X0;	// Координата Х центральной точки
double Y0;	// Координата Y центральной точки
double H;	// Длина 2го катета (общего для первого и второго прямоугольного треугольника)

// Определить расстояние между центрами 1ой и 2ой окружности.
D = sqrt(sqr(X1-X2) + sqr(Y1-Y2)); 

if ((R1+R2) < D)
{
	// Нет точек пересечения  1ой и 2ой окружности.

	// Выход из программы с возвратом 0.
	return 0;	
}

// Определить 1ый катет 2го треугольника.
B = (sqr(R2)-sqr(R1)+sqr(D))/(2*D);

// Определить 1ый катет 1го треугольника.
A = D-B;

// Найти координаты центральной точки.
X0 = (X2-X1)*A/D+X1;
Y0 = (Y2-Y1)*A/D+Y1;

if ((R1+R2) == D)
{
	// Существует одна точка пересечения   1ой и 2ой окружности.

	// Записать найденную точку пересечения в выходной параметр.
	*Xc1 = X0;
	*Yc1 = Y0;		

	// Выход из программы с возвратом 1.
	return 1;	
}

// Существует две точки пересечения 1ой и 2ой окружности.

// Определить 2ой катет (общий для 1го и 2го треугольников).
H = sqrt(sqr(R1)-sqr(A));

// Записать две точки пересечения в выходные параметры.
*Xc1 = X0+H/B*(Y0-Y2);
*Yc1 = Y0+H/B*(X2-X0);

*Xc2 = X0-H/B*(Y0-Y2);
*Yc2 = Y0-H/B*(X2-X0);

// Выход из программы с возвратом 2.
return 2;

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ОПРЕДЕЛЕНИЕ НАПРЯЖЕНИЙ И УСИЛИЙ НА УЧАСТКАХ КОНТАКТА РОЛИКА С ДОРОЖКОЙ КАЧЕНИЯ (ВНУТРЕННЕГО ИЛИ НАРУЖНОГО) КОЛЬЦА 
//	(ОБЛАСТЬ КОНТАКТА НАКРЫТА НЕРАВНОМЕРНОЙ СЕТКОЙ)		
//
//
// Входные параметры :	
//	* DEF	  	- Указатель на массив деформаций на равномерных участках контакта роликов с кольцом. 
//	  NOM	  	- Номер ролика
//	* SHIRINA 	- Указатель на массив ширин участка контакта роликов с кольцом	
//	  RAST0	  	- Коэффициент влияния участка самого на себя
//	  Er_   	- Модуль упругости материала ролика
//	  EPr_		- Коэффициент Пуассона материала ролика
//	  Ek_		- Модуль упругости материала кольца (наружного или внутреннего).
//	  EPk_		- Коэффициент Пуассона материала кольца (наружного или внутреннего).
//
// Выходные параметры :
//	 * NAPR	  - Указатель на массив средних напряжений на равномерных участках контакта роликов и кольца.
//
// Возвращаемое значение : 
//	 Суммарное усилие в контакте
//


double napr_usil_kontakt2( double * DEF, int NOM, double * SHIRINA, double RAST0, double * NAPR, double Er_, double EPr_, double Ek_, double EPk_ )

{

int i,j,i1,j1,i2,j2,l;		// Счетчики 
int kol_nagr_uch;		// Количество равномерных нагруженных участков в зоне контакта ролика с кольцом.
int nom_ur;			// Счетчик уравнений и нагруженных участков (т.к. каждому нагруженному участку соответствует одно уравнение).
int nom_koeff;			// Счетчик коэффициентов линейного уравнения.
int k_umn;			// Счетчик количества умножений системы линейных уравнений на коэффициент.
double * b;			// Указатель на столбец свободных членов системы линейных уравнений.
double * a;			// Указатель на матрицу коэффициентов системы линейных уравнений.
double * x;			// Указатель на столбец решений системы линейных уравнений, являющейся напряжениями на неравномерных участках контакта
double rast;			// Расстояние между участками
double Km;			// Коэффициент на который умножается система линейных уравнений так чтобы определитель матрицы системы лин.уравнений не был равен 0.

/*
double sum_kv_otkl;	// Суммарное квадратичное отклонение.
double sr_kv_otkl;	// Среднеквадратичное отклонение

double s;		// Сумма произведений строки матрицы коэффициентов на столбец решений.
double abs_otkl;	// Абсалютное отклонение cуммы произведений строки матрицы системы лин.уравнений на столбец решений от свободного члена.
double otn_otkl;	// Относительное отклонение cуммы произведений строки матрицы системы лин.уравнений на столбец решений от свободного члена.
*/
	
double Q;			// Усилие в контакте ролика с кольцом.			
double opr;			// Определитель матрицы системы линейных уравнений
int priz_sosed;			// Признак соседства с нагруженным участком
int napr;			// Направление (Север, Юг, Запад, Восток, Сенверо-Запад, Северо-Восток, Юго-Восток, Юго-Запад)
int i0, j0;			// Координаты соседнего участка
int nom_okaim;			// Номер окаймления
int sled_nom_okaim;		// Следующий номер окаймления
int rezult;			// Код результата решения системы линейных уравнений.
double Max_def;			// Максимальная деформация по текущей полосе в контакте ролика с кольцом
double pred_def;		// Деформация на предыдущем участке при исходном равномерном разбиении.
double posled_def;		// Деформация на последующем участке при исходном равномерном разбиении.
double tek_def;			// Деформация на текущем участке при исходном равномерном разбиении.
double proc_izm_def_1;		// Процент изменения деформации при переходе от предыдущего участка к текущему.
double proc_izm_def_2;		// Процент изменения деформации при переходе от последующего участка к текущему.
double proc_izm_def;		// Наибольший процент изменения деформации при переходе от соседнего участка к текущему.
int koeff_sliyan;		// Коэффициент слияния участков для текущего равномерного участка
int koeff_sliyan_lev;		// Коэффициент слияния для участка расположенного левее  текущего.
int koeff_sliyan_prav;		// Коэффициент слияния для участка расположенного правее текущего.
int nom_uch_neravn;		// Счетчик участков на полосе при неравномерном разбиении.
int kol_neravn_uch;		// Количество участков на полосе при новом, неравномерном разбиении.
double sum_def;			// Вспомогательная переменная. Сумма деформаций нескольких участков.
double def_neravn_uch;		// Вспомогательная переменная. Деформация на неравномерном участке.
double pr_gr_1;			// Правая граница участка № 1
double lev_gr_1;		// Левая граница  участка № 1	
double centr_i1;		// Центр участка № 1 по оси x
double centr_j1;		// Центр участка № 1 по оси Y	
double pr_gr_2;			// Правая граница участка № 2
double lev_gr_2;		// Левая граница  участка № 2	
double centr_i2;		// Центр участка № 2 по оси x
double centr_j2;		// Центр участка № 2 по оси Y	
int prz;			// Признак использования текущего равномерного участка. Вспомогательная переменная.
int poz1;			// Указатель позиции в массиве "priz_uch_neravn" (признак использования неравномерных участков). Вспомогательная переменная.
int kol_nagr_uch_neravn;	// Количество неравномерных участков нагруженных и находящихся в окаймлении (используемых для построения системы линейных уравнений)


// Найти максимальную деформацию в зоне контакта.
Max_def=0;
for (j=0; j<kol_uch_shirina; j++) for (i=0; i<N; i++) if (*(DEF+N*kol_uch_shirina*NOM+kol_uch_shirina*i+j) > Max_def)  Max_def=*(DEF+N*kol_uch_shirina*NOM+kol_uch_shirina*i+j);

// Перебор в цикле всех полос области контакта
for (j=0; j<kol_uch_shirina; j++)
{
	// Определить коэффициенты слияния для каждого из участков полосы № j
	for (i=0; i<N; i++)
	{
		if (priz_sliyan_uch)
		{
			// Установлен признак слияния участков
		
			// Взять деформацию на предыдущем участке.
			if (i > 0) pred_def=*(DEF+N*kol_uch_shirina*NOM+kol_uch_shirina*(i-1)+j); else pred_def=0;

			// Взять деформацию на последующем участке.
			if (i < N) posled_def = *(DEF+N*kol_uch_shirina*NOM+kol_uch_shirina*(i+1)+j); else posled_def=0;

			// Взять деформацию на текущем участке.	
			tek_def = *(DEF+N*kol_uch_shirina*NOM+kol_uch_shirina*i+j);

			// Определить процент изменения деформации при переходе от предыдущего участка к текущему.	
			if (fabs(Max_def) > 0.0000001) 	proc_izm_def_1 = fabs(100*(tek_def-pred_def)/Max_def); else proc_izm_def_1 = 0.0;

			// Определить процент изменения деформации при переходе от последующего участка к текущему.	
			if (fabs(Max_def) > 0.0000001) 	proc_izm_def_2 = fabs(100*(posled_def-tek_def)/Max_def); else proc_izm_def_2 = 0.0;

			// Выбрать наибольтший из процентов изменения деформации.
			if (proc_izm_def_1 > proc_izm_def_2) proc_izm_def = proc_izm_def_1; else proc_izm_def = proc_izm_def_2;

			if (proc_izm_def >= 5)
			{
				// Для данного участка установить коэффициент слияния 1
				koeff_sliyan = 1; 
			}
			else	
			{
				if (proc_izm_def >= 1)  
				{
					// Для данного участка установить коэффициент слияния 2	
					koeff_sliyan = 1; 	
				}
				else	
				{
					if (proc_izm_def >= 0.5)  
					{
						// Для данного участка установить коэффициент слияния 5	
						koeff_sliyan = 2;
					}
					else
					{	
						// Для данного участка установить коэффициент слияния 20	
						koeff_sliyan = 3;	
					}	
				}
			}
		}
		else
		{
			// Сброшен признак слияния.
			koeff_sliyan = 1; 
		}

		// Записать в массив найденный коэффициент слияния.		
		*(k_sl+i) = koeff_sliyan;
	}

	// Сделать окаймление № 1. Участки с коэффициентом слияния 2 окаймить слева и справа участкаки имеющими коэффициент слияния 2 или менее
	for (i=0; i<N; i++)
	{
		// Взять коэффициент слияния на текущем участке.
		koeff_sliyan = *(k_sl+i);

		if (i > 0) 
		{
			// Левее текущего участка есть другой участок.
			
			// Считать коэффициент слияния на участке расположенном левее текущего.
			koeff_sliyan_lev = *(k_sl+i-1);

			// Если коэффициент слияния на участке расположенного левее текущего равен 2, а коэффициент слияния текущего участка более 2 
			// тогда установить частоту разбиения текущего участка равной 2.
			if ((koeff_sliyan_lev == 2) && (koeff_sliyan > 2)) koeff_sliyan = 2;
		}

		if (i < N-1)
		{
			// Правее текущего участка есть другой участок.

			// Считать коэффициент слияния на участке расположенном правее текущего.
			koeff_sliyan_prav = *(k_sl+i+1);

			// Если коэффициент слияния участка расположенного правее текущего равен 2, а коэффициент слияния текущего участка более 2
			// тогда установить частоту разбиения текущего участка равной 2.
			if ((koeff_sliyan_prav == 2) && (koeff_sliyan > 2)) koeff_sliyan = 2;
		}

		// Записать новый коэффициент слияния во вспомогательный массив.
		*(k_sl1+i) = koeff_sliyan;
	}

	// Записать обновленные коэффициенты слияния участков на текущей полосе в массив коэффициентов слияния участков.
	for (i=0; i<N; i++) *(k_sl+i) = *(k_sl1+i);

	// Сделать окаймление № 2. Участки с коэффициентом слияния 1 окаймить слева и справа участкаки имеющими коэффициент слияния 1
	for (i=0; i<N; i++)
	{
		// Взять коэффициент слияния на текущем участке.
		koeff_sliyan = *(k_sl+i);

		if (i > 0) 
		{
			// Левее текущего участка есть другой участок.
			
			// Считать коэффициент слияния на участке расположенном левее текущего.
			koeff_sliyan_lev = *(k_sl+i-1);

			// Если коэффициент слияния на участке расположенном левее текущего равен 1, а коэффициент слияния на текущем участке более 1 
			// тогда установить коэффициент слияния на текущем участке равный 1.
			if ((koeff_sliyan_lev == 1) && (koeff_sliyan > 1)) koeff_sliyan = 1;
		}

		if (i < N-1)
		{
			// Правее текущего участка есть другой участок.

			// Считать коэффициент слияния на участке расположенном правее текущего.
			koeff_sliyan_prav =  *(k_sl+i+1);

			// Если коэффициент слияния на участке расположенном правее текущего равен 1, а коэффициент слияния на текущем участке более 1
			// тогда установить коэффициент слияния на текущем участке равный 1.
			if ((koeff_sliyan_prav == 1) && (koeff_sliyan > 1)) koeff_sliyan = 1;
		}

		// Записать новый коэффициент слияния на текущем участке во вспомогательный массив.
		*(k_sl1+i) = koeff_sliyan;
	}

	// Записать обновленные коэффициенты слияния участков на текущей полосе в массив коэффициентов слияния участков.
	for (i=0; i<N; i++) *(k_sl+i) = *(k_sl1+i);

	// Построение неравномерного разбиения на участки по текущей полосе.
	i=0;
	nom_uch_neravn=0;

	while (i < N)		
	{
		// Считать коэффициент слияния на текущем участке.
		koeff_sliyan = *(k_sl+i); 

		// Установить связь между участками при равномерном и неравномерном разбиении,
		// определить деформацию на неравномерном участке.
		sum_def=0;
		l=0;

		while ((i < N) && (l < koeff_sliyan) && (*(k_sl+i) >= koeff_sliyan)) 
		{
			sum_def += *(DEF+N*kol_uch_shirina*NOM+kol_uch_shirina*i+j);	
			*(swaz_neravn_ravn + kol_uch_shirina*i+j) = nom_uch_neravn;
			i++;
			l++;
		}

		def_neravn_uch = sum_def/l;
		*(DEF_neravn + kol_uch_shirina*nom_uch_neravn+j) = def_neravn_uch;	

		// Определить правую границу неравномерного участка.
		*(prav_gr_neravn_uch + kol_uch_shirina*nom_uch_neravn+j) = i*OM;

		// Нарастить счетчик неравномерных участков
		nom_uch_neravn++;
	}

	// Запомнить количество участков на текущей полосе при неравномерном разбиении.
	kol_neravn_uch = nom_uch_neravn;
	*(kol_neravn_uch_polosa + j) = kol_neravn_uch;

/*
	fprintf(f2,"\n\n  Tablica swjazi ravnomernogo i neravnomernogo razbienija. Polosa № %d   \n ",j);
	for (i=0; i<N; i++)  fprintf(f2,"\n  N ravnomern razb = %3d   N neravnomernogo razb = %3d   ",i , *(swaz_neravn_ravn + kol_uch_shirina*i+j) );

	fprintf(f2,"\n\n  Tablica deformacii i pravih granic uchastkov pri neravnomernom razbienii. Polosa № %d   \n ",j);
	for (i=0; i<kol_neravn_uch; i++) fprintf(f2,"\n N neravnomern uch = %3d    Deform = %8.5f   Pravaja granica = %8.5f ",i, *(DEF_neravn + kol_uch_shirina*i+j), *(prav_gr_neravn_uch+kol_uch_shirina*i+j)     );

	fprintf(f2,"\n - - - - - - - - - - - - - - - - - - - - - ");
*/

}

/*
fprintf(f2,"\n \n ");
fprintf(f2,"\n\n  Kolich neravn uchastkov na polose \n ",j);

for (j=0; j<kol_uch_shirina; j++)
{
	fprintf(f2,"\n  Polosa %d    Kolich neravn uchastkov %d ",j ,*(kol_neravn_uch_polosa + j));
}

*/

// Обнулить количество нагруженных участков в зоне контакта ролика № NOM с кольцом.
kol_nagr_uch = 0;

// Заполнение массива признаков использования равномерных участков. 
for (i=0; i<N; i++) 
	for(j=0; j<kol_uch_shirina; j++)
		if (*(DEF+N*kol_uch_shirina*NOM+kol_uch_shirina*i+j) > 0)
		{
			// Установить признак нагружения на равномерном участке.
			*(priz_uch+kol_uch_shirina*i+j)=1;

			// Нарастить количество нагруженных равномерных участков.
			kol_nagr_uch++;
		}
		else
		{
			// Сброс признака нагружения участка
			*(priz_uch+kol_uch_shirina*i+j)=0;
		}

//printf("\n  %d deformirovannyh ravnomernyh uchastkov ",kol_nagr_uch);

// Окаймление (Включение в расчет участков соседних с нагруженными)
//
for (nom_okaim=1; nom_okaim <= max_nom_okaim; nom_okaim++)
{
	sled_nom_okaim = nom_okaim+1;

	for (i=0; i<N; i++) 
	{
		for (j=0; j<kol_uch_shirina; j++)
		{	
			// Сброс признака соседства с нагруженным участком.
			priz_sosed = 0;

			// Перебор в цикле всех направлений и проверка соседства с нагруженным участком.
			for (napr=0; napr<8; napr++)
			{
				switch (napr)
				{
					case 0:
						// Направление север
						i0 = i;
						j0 = j+1;
						break;

					case 1:
						// Направление северо-восток
						i0 = i + 1;
						j0 = j + 1;
						break;	

					case 2:
						// Направление восток
						i0 = i + 1;
						j0 = j;
						break;

					case 3:
						// Направлениен юго-восток
						i0 = i + 1;
						j0 = j - 1;
						break;

					case 4:
						// Направление юг
						i0 = i;
						j0 = j - 1;
						break;

					case 5:
						// Направление юго-запад
						i0 = i - 1;
						j0 = j - 1;
						break;

					case 6:
						// Направление запад
						i0 = i - 1;
						j0 = j;
						break;

					case 7:
						// Направление северо-запад
						i0 = i - 1;
						j0 = j + 1;
						break;
				}

				if ((i0 >=0) && (i0 < N) && (j0 >=0) && (j0 < kol_uch_shirina))
				{
					// Если установлено соседство с нагруженным или ранее окаймленным участком, 
					// тогда установить признак соседства с нагруженным участком.
					if (*(priz_uch+kol_uch_shirina*i0+j0) == nom_okaim )	priz_sosed = 1;
				}
			}

			if ((priz_sosed) && (*(priz_uch+kol_uch_shirina*i+j) == 0))
			{
				// Пометить текущий участок как входящий в окаймление
				*(priz_uch+kol_uch_shirina*i+j)= sled_nom_okaim ;

				// Нарастить количество нагруженных участков.
				kol_nagr_uch++;
			}
		}
	}


}

// Выдать количество деформированных и окаймленных равномерных участков
//fprintf(f2,"\n  %d deformirov+okaimlennyh ravnomernyh uchastkov ",kol_nagr_uch);

/*
// Выдать двухмерный массив деформаций в контакте ролика № NOM с кольцом при равномерном разбиении на участки 
fprintf(f2,"\n\n Deform v kontakte rolika № %d  ravn uchastok \n\n",NOM);
for (i=0; i<N; i++)
{
	for (j=0; j<kol_uch_shirina; j++)  
	{
		fprintf(f2," %7.5f \t",*(DEF+N*kol_uch_shirina*NOM+kol_uch_shirina*i+j)  );
	}
	fprintf(f2,"\n");
}
*/

/*
// Выдать массив признаков использования раномерных участков.
fprintf(f2,"\n\n Priznak ispolsov ravn uchastok  rolika № %d   \n\n",NOM);

for (i=0; i<N; i++) 
{
	for(j=0; j<kol_uch_shirina; j++) 
	{
		fprintf(f2," %d \t", *(priz_uch+kol_uch_shirina*i+j)  );
	}
	fprintf(f2,"\n");
}
*/

// Очистка массива признаков использования не равномерных участков.
for (i=0; i<N; i++) for (j=0; j<kol_uch_shirina; j++) *(priz_uch_neravn+kol_uch_shirina*i+j) = 0;

// Обнулить количество неравномерных участков нагруженных и входящих в окаймление.
kol_nagr_uch_neravn = 0;

// Заполнение массива признаков использования неравномерных участков на основе массива признаков использования равномерных участков.
for (i=0; i<N; i++) 
	for (j=0; j<kol_uch_shirina; j++)	
	{
		// Считать признак использования текущего равномерного участка
		prz = *(priz_uch+kol_uch_shirina*i+j);

		if (prz > 0)
		{
			// Определить указатель на элемент массива признаков использования неравномерных участков соответствующий текущему равномерному.
			poz1 = kol_uch_shirina * *(swaz_neravn_ravn + kol_uch_shirina*i+j) + j;

			if (*(priz_uch_neravn+poz1) == 0) 
			{
				// Соответствующий неравномерный участок еще не был использован, установить ему 
				// признак использования такой же как у соответствующего ему равномерного участка.
				*(priz_uch_neravn + poz1) = prz;

				// Нарастить счетчик нагруженных и входящих в окаймление неравномерных участков.
				kol_nagr_uch_neravn++;					
			}
			else
			{
				// Соответствующий неравномерный участок уже был использован, установить ему 
				// минимальный признак использования.
				//
				if (*(priz_uch_neravn + poz1) > prz) *(priz_uch_neravn + poz1) = prz;
			}	

		}
	}



// Выдать количество деформированных и окаймленных неравномерных участков
//fprintf(f2,"\n  %d deformirov+okaimlennyh neravnomernyh uchastkov ", kol_nagr_uch_neravn);

/*
// Выдать двухмерный массив деформаций в контакте ролика № NOM с кольцом при неравномерном разбиении на участки 
fprintf(f2,"\n\n Deform v kontakte rolika № %d  neravn uchastok \n\n",NOM);

for (j=0; j<kol_uch_shirina; j++)	
{
	for (i=0; i<*(kol_neravn_uch_polosa+j); i++)
	{
		fprintf(f2," %7.5f \t",*(DEF_neravn+kol_uch_shirina*i+j) );
	}
	fprintf(f2,"\n");
}
*/
/*
// Выдать массив признаков использования нераномерных участков.
fprintf(f2,"\n\n Priznak ispolsov neravn uchastokov rolika № %d   \n\n",NOM);

for (j=0; j<kol_uch_shirina; j++)	
{
	for (i=0; i<*(kol_neravn_uch_polosa+j); i++)
	{
		fprintf(f2," %3d \t",*(priz_uch_neravn+kol_uch_shirina*i+j));
	}
	fprintf(f2,"\n");
}
*/


// Выделить область памяти для хранения столбца свободных членов системы линейных уравнений.
b = (double *) malloc(kol_nagr_uch_neravn * sizeof(double));
if (b == NULL)
{
	// Ошибка при выделении блока памяти для столбца свободных членов системы линейных уравнений.
	// Выдать на экран сообщение об ошибке
	printf("\n  - Oshibka pri widelenii bloka pamyati dlya stolbca swobdnih chlenov pri reshenii systemi lin uravnenii");

	// Выход из процедуры с признаком ошибки.	
	return -1;
}

// Выделить область памяти для хранения матрицы коэффициентов системы линейных уравнений.
a = (double *) malloc(kol_nagr_uch_neravn * kol_nagr_uch_neravn * sizeof(double));
if (a == NULL)
{
	// Ошибка при выделении блока памяти для матрицы коэффициентов системы линейных уравнений.
	// Выдать на экран сообщение об ошибке
	printf("\n  - Oshibrka pri widelenii bloka pamyati dlya matricy koefficientov pri reshenii systemi lin uravnenii");

	// Освободить ранее выделенные блоки памяти.
	free(b);

	// Выход из процедуры с признаком ошибки.	
	return -1;
}


// Успешно выделены блоки памяти для размещения матрицы коэффициентов и столбца свободных членов.
// Обнулить счетчик уравнений (нагруженных участков).
nom_ur = 0;

// Перебор в цикле всех неравномерных нагруженных участков области контакта и создание для каждого нагруженного участка линейного уравнения.
for (j1=0; j1<kol_uch_shirina; j1++)
{
	// Определить координаты центра неравномерного участка № 1 по оси Y
	centr_j1 = j1*OM + OM/2;		

	for (i1=0; i1<*(kol_neravn_uch_polosa+j1); i1++)
	{
		if (*(priz_uch_neravn+kol_uch_shirina*i1+j1))
		{
			// Неравномерный участок № i1,j1 области контакта является нагруженным и деформированным. 
			// Создаем новое уравнение.

			// Деформацию на неравномерном участке №  i1,j1  записать в элемент № nom_ur столбца свободных членов
			// создаваемой системы линейных уравнений.
			*(b+nom_ur) = *(DEF_neravn+kol_uch_shirina*i1+j1);

			// Определить координаты центра неравномерного участка № 1 по оси X
			pr_gr_1 = *(prav_gr_neravn_uch+kol_uch_shirina*i1+j1);					// Взять правую границу участка № i1,j1
			if (i1>0) lev_gr_1= *(prav_gr_neravn_uch+kol_uch_shirina*(i1-1)+j1); else lev_gr_1=0; 	// Взять левую границу  участка № i1,j1
			centr_i1 = lev_gr_1 + (pr_gr_1-lev_gr_1)/2;

			// Обнулить счетчик коэффициентов текущего уравнения.
			nom_koeff=0;

			// Перебор в цикле всех неравномерных участков области контакта.
			for (j2=0; j2<kol_uch_shirina; j2++)
			{
				// Определить координаты центра неравномерного участка № 2 по оси Y
				centr_j2 = j2*OM + OM/2;							

				for (i2=0; i2<*(kol_neravn_uch_polosa+j2); i2++)
				{
					if (*(priz_uch_neravn+kol_uch_shirina*i2+j2))
					{
						// Определить правую и левую границы участка № i2,j2
						pr_gr_2 = *(prav_gr_neravn_uch+kol_uch_shirina*i2+j2);									
						if (i2>0) lev_gr_2= *(prav_gr_neravn_uch+kol_uch_shirina*(i2-1)+j2); else lev_gr_2= 0; 	
						
						// Неравномерный участок № i2,j2 области контакта является нагруженным и деформированным.
						if ((i1==i2) && (j1==j2))
						{
							// Задать расстояние участка самого от себя 
							// (должно быть очень малое число но не 0, т.к.на 0 делить нельзя).
							koeff_sliyan= (int) floor((pr_gr_2-lev_gr_2)/OM+0.01);
							//printf("\n koeff_sl = %3d ",koeff_sl);
							rast = RAST0 * k_rast0[koeff_sliyan-1];
						}
						else
						{
							// Определить координаты центра участка № 2 по оси X
							centr_i2 = lev_gr_2 + (pr_gr_2-lev_gr_2)/2;

							// Определить расcтояние от участка № i1,j1 до участка № i2,j2
							rast = sqrt(sqr(centr_i1-centr_i2) + sqr(centr_j1-centr_j2));
						}

						// Определить коэффициент влияния участка № i2,j2 на участок i1,j1 и
						// записать его в матрицу коэффициентов системы линейных уравнений.
						*(a+kol_nagr_uch_neravn*nom_ur+nom_koeff) = (((1-EPr_*EPr_)/(pi*Er_))+((1-EPk_*EPk_)/(pi*Ek_)))*OM*(pr_gr_2-lev_gr_2)/rast;

						// Нарастить счетчик коэффициентов линейного уравнения.
						nom_koeff++;
					}
				}
			}

			// Нарастить счетчик линейных уравнений
			nom_ur++;
		}
	}
}

//fprintf(f2,"\n Kol nagruz i okaimlen neravnomer uchastkov = %d \n",kol_nagr_uch_neravn);
//printf("\n Kol nagruz i okaimlen neravnomer uchastkov = %d \n",kol_nagr_uch_neravn);

// Задание коэффициента Km на который умножается матрица коэффициентов 
// и столбец свободных членов системы линейных уравнений.
// Этот коэффициент подбирается в зависимости от количества уравнений в системе.
// Чем больше уравнений, тем больше коэффициент.
//
// Это делается для того чтобы чтобы определитель матрицы коэффициентов 
// системы линейных уравнений не был равен нулю.
//
if (kol_nagr_uch_neravn <= 10) 
	Km = 10000;
else
	if (kol_nagr_uch_neravn <= 25) 
		Km= 100000;
	else
		if (kol_nagr_uch_neravn <= 75)
			Km= 1000000;
		else
			if (kol_nagr_uch_neravn <= 150)
				Km= 10000000;
			else
				if (kol_nagr_uch_neravn <= 300)
					Km= 100000000;
				else
					if (kol_nagr_uch_neravn <= 600)
						Km= 1000000000;
					else
						if (kol_nagr_uch_neravn <= 1200)
							Km= 10000000000;
						else
							if (kol_nagr_uch_neravn <= 2400)
								Km= 100000000000;
							else
								Km= 1000000000000;

// Умножение матрицы коэффициентов и столбца свободных членов на коэффициент Km
// так чтобы определитель матрицы коэффициентов не был равен 0.

// Обнулить счетчик умножений системы линейных уравнений на коэффициент.
k_umn = 0;

// Цикл умножения системы линейных уравнений до тех пор пока определитель матрицы коэффициенттов 
// не будет равен нулю, либо количество итераций не превысит определенного числа.

while (k_umn <= 7)
{
	// Перебор в цикле всех уравнений системы.
	for (nom_ur=0; nom_ur<kol_nagr_uch_neravn; nom_ur++)
	{
		// Перебор в цикле всех коэффициентов уравнения и умножение их на коэффициент Km.
		for (nom_koeff=0; nom_koeff<kol_nagr_uch_neravn; nom_koeff++) *(a+nom_ur*kol_nagr_uch_neravn+nom_koeff)*=Km; 

		// Умножение очередного элемента столбца свободных членов  на коэффициент Km.  	
		*(b+nom_ur)*= Km;
	}
	
	// Нарастить на 1 счетчик умножений системы линейных уравнений.
	k_umn++;

	// Для последующих итераций цикла установить коэффициент умножения равный 10.
	Km = 10;

	//
	//		Поиск корней системы линейных уравнений методом Гаусса. 
	//
	//	Входные параметры :	    a - Указатель на матрицу коэффициентов системы линейных уравнений
	//				            b - Указатель на столбец свободных членов системы линейных уравнений
	//
	//	      kol_nagr_uch_neravn - Количество неравномерных нагруженных участков = количество коэффициентов в уравнении = 
	//				                количество столбцов в матрице коэффициентов = количество уравнений в системе = 
	//				                количество строк в матрице коэффициентов 
	//
	//	Выходные параметры :  x	- Указатель на столбец решений системы линейных уравнений.
	//
	//	Возвращаемое значение : "0" - Решение не найдено, "1" - Решение найдено.
	//
	opr=gaus( a, b, &x, kol_nagr_uch_neravn );

	rezult = 1;
	if (opr == 0.000000) rezult = 0;

	// Если решение найдено, тогда выход из итерационного цикла умножения системы линейных уравнений на коэффициент.
	if (rezult) break;
}


if (rezult) 
{
	// Найдено решение системы линейных уравнений. 
	// Получено распределение напряжений по участкам полоски контакта ролика с кольцом с учетом краевых эффектов.

	// Выдать на экран сообщение.
	//printf("\n + ");

/*
	// Выдать для контроля столбец решений "x" 	
	fprintf(f2,"\n\n  Stolb x  \n\n");
	for (i=0; i<kol_nagr_uch_neravn; i++) fprintf(f2," %17.5f \n",*(x+i));


	// Определить среднеквадратичное отклонение A*x от B.

	// Обнулить суммарное квадратичное отклонение.
	sum_kv_otkl = 0;

	// Перебор в цикле всех уравнений
	for (nom_ur=0; nom_ur<kol_nagr_uch_neravn; nom_ur++)
	{
		// Определить отклонение для уравнения № nom_ur

		// Вычислить сумму произведений строки матрицы коэффициентов № nom_ur со столбцом решений "x" 
		// и вычесть ее из элемента столбца свободных членов № nom_ur.
		s = 0;
		for (nom_koeff=0; nom_koeff<kol_nagr_uch_neravn; nom_koeff++) s += *(a+nom_ur*kol_nagr_uch_neravn+nom_koeff) * *(x+nom_koeff);

		// Определить абсалютное отклонение cуммы произведений строки матрицы коэффициентов на столбец решений от свободного члена.
		abs_otkl = *(b+nom_ur) - s;

		// Определить относительное отклонение cуммы произведений строки матрицы коэффициентов на столбец решений от свободного члена.
		otn_otkl = abs_otkl / *(b+nom_ur) * 100;

		// Выдать на экран сообщение о найденном отклонении.
		fprintf(f2,"\n Uravnenie %d : abs_otkl = %15.10f     Otnos otkl =  %15.10f     ",nom_ur, abs_otkl, otn_otkl );

		// Нарастить суммарное квадратичное отклонение.
		sum_kv_otkl += abs_otkl*abs_otkl;
	}

	// Определить среднеквадратичное отклонение
	sr_kv_otkl = sqrt(sum_kv_otkl)/kol_nagr_uch_neravn;
*/

	// Обнулить матрицу напряжений на неравномерных участках.
	for (j1=0; j1<kol_uch_shirina; j1++) for (i1=0; i1<N; i1++)	*(NAPR_neravn+kol_uch_shirina*i1+j1) = 0;

	// Обнулить счетчик нагруженных участков.
	nom_ur = 0;

	// Из столбца решений системы линейных уравнений "х" построить матрицу распределения напряжений (давлений) на неравномерных участках области
	// контакта ролика с кольцом. 

	for (j1=0; j1<kol_uch_shirina; j1++)
	{
		for (i1=0; i1<*(kol_neravn_uch_polosa+j1); i1++)
		{
			if (*(priz_uch_neravn+kol_uch_shirina*i1+j1))
			{
				// Неравномерный участок № i1,j1 области контакта является нагруженным или вхолящим в окаймление. 

				if (*(x + nom_ur) > 0) 
				{
					// Текущий элемент столбца решений Х содержит положительное значение.
					// Взять для текущего неравномерного участка напряжение из текущего элемента столбца решений Х.
					*(NAPR_neravn+kol_uch_shirina*i1+j1) = *(x + nom_ur);
				}
				else
				{
					// Текущий элемент столбца решений Х содержит отрицательное значение.
					*(NAPR_neravn+kol_uch_shirina*i1+j1) = 0;
				}	

				// Нарастить счетчик нагруженных участков.
				nom_ur++;
			}
			else
			{
				// Неравномерный участок № i1,j1 области контакта не является нагруженным или вхолящим в окаймление.
				// Установить на нем нулевое напряжение.
				*(NAPR_neravn+kol_uch_shirina*i1+j1) =  0;
			}
		}
	}

/*
	// Выдать массив напряжекний на неравномерных участках.
	fprintf(f2,"\n\n Naprjag na neravnomernyh uchastkah  \n\n");

	for (i=0; i<N; i++) 
	{
		for(j=0; j<kol_uch_shirina; j++) 
		{
			fprintf(f2," %15.10f \t", *(NAPR_neravn+kol_uch_shirina*i+j)  );
		}
		fprintf(f2,"\n");
	}
*/

	// Из матрицы распределения напряжений (давлений) на неравномерных участках построгить матрицу распределения напряжений (давлений)
	// на равномерных участках области контакта ролика с кольцом.

	// Из матрицы растолбца решений системы линейных уравнений "х" построить матрицу напряжений (давлений) на участках области
	// контакта ролика с кольцом. 

	// Перебор в цикле всех равномерных участков сетки И заполнение их найденными для неравномерных участков значениями напряжений.	
	for (i=0; i<N; i++)
		for (j=0; j<kol_uch_shirina; j++)
		{
			// Определить позицию в найденном массиве напряжений на неравномерных участках соответствующую текущему равномерному участку.
			i1 = *(swaz_neravn_ravn + kol_uch_shirina*i+j);

			// Взять для текущего равномерного участка напряжение из соответствующего ему неравномерного участка.
			*(NAPR+N*kol_uch_shirina*NOM+kol_uch_shirina*i+j) = *(NAPR_neravn+kol_uch_shirina*i1+j);
		}	

	// Освободить область памяти выделенную для хранения столбца результатов.
	free(x);

	// Определить суммарное усилие в контакте ролика с кольцом путем нахождения усилия на каждом участке 
	// (Усилие = Напряжение * Площадь) и суммирования по всем участкам области контакта.
	Q=0;
	for (i=0; i<N; i++) for (j=0; j<kol_uch_shirina; j++) Q += *(NAPR+N*kol_uch_shirina*NOM+kol_uch_shirina*i+j)*OM*OM;

	/*
	// Выдать двухмерный массив напряжений (давлений) в контакте ролика № NOM с кольцом 
	fprintf(f2,"\n\n Napryagenie v kontakte rolika № %d \n\n",NOM);
	for (i=0; i<N; i++)
	{
		for (j=0; j<kol_uch_shirina; j++)  fprintf(f2," %8.3f  \t ",*(NAPR+N*kol_uch_shirina*NOM+kol_uch_shirina*i+j));
		fprintf(f2,"\n");
	}
	*/
}


// Освободить область памяти выделенную для хранения матрицы коэффициентов системы линейных уравнений.
free(a);

// Освободить область памяти выделенную для хранения столбца свободных членов системы линейных уравнений.
free(b);

if (!rezult)
{
	// Не найдено решение системы линейных уравнений. 
	// Не найдено распределение напряжений по участкам полоски контакта ролика с кольцом с учетом краевых эффектов.

	// Выдать на экран сообщение.
	printf("\n - Ne naideno reshenie systemy lin. uravnenii ");

	// Выход из процедуры с признаком ошибки.	
	return -1;
}


// Выход из функции с возвратом суммарного усилия в контакте ролика с кольцом.
return Q;

}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
///												
/// ОПРЕДЕЛЕНИЕ ДЕФОРМАЦИЙ И НАГРУЗОК ДЕЙСТВУЮЩИХ ПО ДЛИНЕ ПОЛОСКИ КОНТАКТА РОЛИКА И 		
/// ДОРОЖЕК КАЧЕНИЯ НАРУЖНОГО И ВНУТРЕННЕГО КОЛЕЦ. ОПРЕДЕЛЕНИЕ НЕВЯЗОК УРАВНЕНИЙ			
/// РАВНОВЕСИЯ СИЛ И МОМЕНТОВ ДЕЙСТВУЮЩИХ НА РОЛИК						
///
/// Входные параметры :	
///		x1 - Сближение ролика с наружным кольцом	
///		x2 - Угол перекоса ролика		
///		DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
///		 j - Номер ролика		
///	 W_sep - Угловая скорость сепаратора в радианах/секунда
///
/// Выходные параметры :
///	 * uk_Qnev - Указатель на переменную в которой записана невязка уравнения сил действующих на ролик
///	 * uk_Mnev - Указатель на переменную в которой записана невязка уравнения моментов действующих на ролик		
///	 * uk_Qv   - Указатель на переменную в которой записано усилие в контакте ролика с внутренним кольцом
///	 * uk_Qn   - Указатель на переменную в которой записано усилие в контакте ролика с наружным кольцом	
///	 * uk_QBL  - Указатель на переменную в которой записан момент действующий на ролик со стороны внутреннего кольца
///	 * uk_QHL  - Указатель на переменную в которой записан момент действующий на ролик со стороны наружного кольца
///	
/// Возвращаемое значение :	
/// 	 Cоставная невязка уравнений равновесия сил и моментов действующих на ролик.
///
///

double roz( double x1, double x2, double DR, int j, double W_sep, double * uk_Qnev, double * uk_Mnev, double * uk_Qv, double * uk_Qn, double * uk_QBL, double * uk_QHL)
{

double a;		/// Косинус угловой координаты ролика
double Fc;		/// Суммарная центробежная сила действующая на ролик при его движении по круговой орбите.
int i;			/// Счетчик участков ролика
double xi;		/// Плечо участка ролика (растояние от участка до середины ролика). 
double ci;		/// Уменьшение диаметра ролика на участке.
double sk;		/// Растояние от текущего участка до точки с нулевой деформацией в контакте ролика с внутренним кольцом.

double DEFv;		/// Деформация на участке контакта ролика с внутренним кольцом.
double DEFn;		/// Деформация на участке контакта ролика с наружным кольцом.
double sostav_newjaz;	/// Составная невязка уравнений равновесия сил и моментов действующих на ролик

double Qpog;		/// Погонная нагрузка на участке контакта ролика с кольцом.
double R1;		/// Радиус кривизны 1 го тела.	
double R2;		/// Радиус кривизны 2 го тела.	

double Qpog_1;		/// Погонная нагрузка на предыдущей итерации цикла уточнения погонной нагрузки на участке контакта ролика с кольцом.
double Qpog_2;		/// Погонная нагрузка на текущей итерации цикла уточнения погонной нагрузки на участке контакта ролика с кольцом.
double Bp;		/// Полуширина полосы контакта на текущей итерации цикла уточнения погонной нагрузки на участке контакта ролика с кольцом.
double TN;		/// Угловая скорость сепаратора в оборатах/минуту

double dP1;		/// Уменьшение радиального зазора в угловой позиции текущего ролика из за сложного профиля дорожки качения наружного кольца



/// Определить косинус угловой координаты ролика, он является коэффициентом при нахожденеии 
/// проекции усилия в контакте ролика с внутренним кольцом на ось OY.
a = cos(2*pi*j/Z);


/// Обнулить суммарную центробежную силу действующую на ролик при его движении по круговой орбите.
Fc = 0;

/// Обнулить суммарное усилие в контакте ролика с внутренним кольцом.
* uk_Qv = 0;

/// Обнулить суммарное усилие в контакте ролика с наружным кольцом.
* uk_Qn = 0;


if (Priz_profil_nk == 1)
{
	/// Профиль дорожки качения наружного кольца считан из файла PROF_NK.DAT и аппроксимирован рядом Фурье
	/// Определить уменьшение радиального зазора в угловой позиции текущего ролика из за сложного профиля дорожки качения наружного кольца
	dP1 = Rnk-fure(aa, kol_toch_profil_nk, (double) j/(double) Z * (double) kol_toch_profil_nk);
}
else
{
	/// Профиль дорожки качения наружного кольца круглый
        dP1 = 0.0;
}

///fprintf(f2, "\n Ролик № %3d   dP1 = %12.9f    Rnk = %12.9f     fure = %12.9f   (double) j/(double) Z) = %12.9f  ",j ,dP1, Rnk,   fure(aa, kol_toch_profil_nk, (double) j/(double) Z * (double) kol_toch_profil_nk),  (double) j/(double) Z );		



/// Перебор в цикле всех участков по длине ролика и определение 
/// деформации в контакте ролика с дорожкой качения наружного и 
/// внутреннего кольца.
///
for (i=0; i<N; i++)
{
	// Определить плечо текущего участка ролика (расcтояние от текущего участка до середины ролика).
	xi = i*OM+OM/2-Lw/2;

	// Определить съем на текущем участке
	ci = Rw - *(profil+i);
	
	// Определить растояние от текущего участка до точки с нулевой деформацией в контакте ролика с внутренним кольцом.
	sk = xi + Rvk * tan(0.5*TT*a);

	/// Определить деформацию на текущем участке контакта ролика с внутренним кольцом.
	DEFv = DR*a - (P/2-(Rvk-RZM)-dP1)-x1 + sk*tan(TT*a-x2)-ci;

	// Деформация не может быть отрицательной величиной, в крайнем случае она равна 0.
	if (DEFv < 0) DEFv = 0;


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///
/*		
	fprintf(f2, "\n   			Сообщение из ROZ                       ");
	fprintf(f2, "\n   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  ");
	fprintf(f2, "\n       Ролик № %3d      Угловая координата %8.5f  ",j ,2*pi*j/Z);
	fprintf(f2, "\n DEFv = %8.5f       DR = %8.5f     cos(fi) = %8.5f      P = %8.5f       Rvk = %8.5f    RZM = %8.5f   x1 = %8.5f   ci = %8.5f  xi = %8.5f", DEFv ,DR ,a ,P ,Rvk ,RZM ,x1 ,ci, xi);
*/
	///
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	// Записать найденную на участке № i деформацию в массив деформаций в контакте j тного ролика с внутренним кольцом.
	*(DB + j*N + i) = DEFv;

	// Задать радиус кривизны ролика на текущем участке.
	R1 = Dw/2-ci;	 

	// Задать радиус кривизны дорожки качения внутреннего кольца.
	R2 = Rvk;

	// Определить начальное приближение усилия на текущем участке контакта 
	// ролика с внутренним кольцом (начальное приближение погонной нагрузки на участке)
	Qpog = step(DEFv,1.11) / (step(ak,1.11)*step(RL,0.11));

	// Уточнение усилия на текущем участке контакта ролика с внутренним кольцом (погонной нагрузки на участке) и
	// полуширины полосы контакта (Контакт выпуклый).
	Qpog_1 = Qpog;

	while (1)
	{
		Bp = 1.12837 * sqrt( ((1-EP_vk*EP_vk)/E_vk + (1-EP_w*EP_w)/E_w) * Qpog_1 * R1*R2/(R1+R2) );
		Qpog_2 = (DEFv * pi)/( 2*(  ((1-EP_w*EP_w)/E_w)*(log(2*R1/Bp)+0.407) + ((1-EP_vk*EP_vk)/E_vk)*(log(2*R2/Bp)+0.407)  )); 	
		if ((Qpog_1 == 0.0) || (fabs((Qpog_2-Qpog_1)/Qpog_1)*100 < 1.0)) break;
		Qpog_1 = Qpog_2;					
	}		

	// Запомнить усилие на текущем участке контакта ролика с внутренним кольцом (погонную нагрузку).
	Qpog = Qpog_2;

	// Определить ширину полосы контакта ролика с внутренним кольцом на данном участке и записать его в массив. (Контакт выпуклый).
	*(Bv+j*N+i) = 2 * 1.12837 * sqrt( ((1-EP_vk*EP_vk)/E_vk + (1-EP_w*EP_w)/E_w) * Qpog * R1*R2/(R1+R2) );	

	// Опредилить напряжение на участке контакта ролика с внутренним кольцом.
	if ((*(Bv+j*N+i)>0) && (RL>0))
	{
		*(SIGI+j*N+i) = Qpog/(*(Bv+j*N+i));
	}
	else
	{
		*(SIGI+j*N+i) = 0;
	}

	// Нарастить усилие в контакте ролика с внутренним кольцом, на величину усилия на данном участке.
	*uk_Qv += OM * Qpog;

	// Определить деформацию на текущем участке контакта ролика с наружным кольцом.
	DEFn = x1 + sk*tan(x2)-ci;

	// Деформация не может быть отрицательной величиной, в крайнем случае она равна 0.
	if (DEFn < 0) DEFn = 0;

	// Записать найденную на участке № i деформацию в массив деформаций в контакте j тного ролика с наружным кольцом.
	*(DH + j*N + i) = DEFn;



	// Задать радиус кривизны ролика на текущем участке.
	R1 = Dw/2-ci;	 

	// Задать радиус кривизны дорожки качения наружного кольца.
	R2 = Rvk+Dw;

	// Определить начальное приближение усилия на текущем участке контакта 
	// ролика с наружным кольцом (начальное приближение погонной нагрузки на участке)
	Qpog = step(DEFn,1.11) / (step(ak,1.11)*step(RL,0.11));


	// Уточнение усилия на текущем участке контакта ролика с наружным кольцом (погонной нагрузки на участке) и
	// полуширины полосы контакта (Контакт вогнутый).
	Qpog_1 = Qpog;

	while (1)
	{
		Bp = 1.12837 * sqrt( ((1-EP_nk*EP_nk)/E_nk + (1-EP_w*EP_w)/E_w)* Qpog_1 * R1*R2/( fabs(R2-R1)) );
		Qpog_2 = (DEFn * pi)/( 2*(  ((1-EP_w*EP_w)/E_w)*(log(2*R1/Bp)+0.407) + ((1-EP_nk*EP_nk)/E_nk)*(log(2*R2/Bp)+0.407)  )); 	
		if ((Qpog_1 == 0.0) || (fabs((Qpog_2-Qpog_1)/Qpog_1)*100 < 1.0)) break;
		Qpog_1 = Qpog_2;					
	}		

	// Запомнить усилие на текущем участке контакта ролика с внутренним кольцом (погонную нагрузку).
	Qpog = Qpog_2;

	// Определить ширину полосы контакта ролика с наружным кольцом на данном участке и записать его в массив. (Контакт вогнутый).
	*(Bn+j*N+i) =  2 * 1.12837 * sqrt( ((1-EP_nk*EP_nk)/E_nk + (1-EP_w*EP_w)/E_w)* Qpog * R1*R2/( fabs(R2-R1)) );	

	// Опредилить напряжение на участке контакта ролика с наружным кольцом.
	if ((*(Bn+j*N+i)>0) && (RL>0))
	{
		*(SIGO+j*N+i) = Qpog/(*(Bn+j*N+i));
	}
	else
	{
		*(SIGO+j*N+i) = 0;
	}

	// Нарастить усилие в контакте ролика с наружным кольцом.
	*uk_Qn += OM * Qpog;

	// Получить угловую скорость сепаратора в оборотах/минута
	TN = (W_sep*30)/pi;

	// Нарастить центробежную силу действующую на ролик, на величину центробежной силы действующей на данном участке.
	Fc += 0.00000000000043064266*RO_w*DM*TN*TN*(Dw-2*ci)*(Dw-2*ci)*OM;
}

// Запомнить центробежную силу действующую на ролик в массиве значений центробежных сил.
*(FCOP+j) = Fc;



// Определить суммарный момент действующий на ролик со стороны наружного и внутреннего кольца.

// Обнулить суммарный момент действующий на ролик со стороны наружного и внутреннего кольца.
*uk_QBL = 0.0;
*uk_QHL = 0.0;

// Перебор в цикле всех участков рабочей зоны ролика.
for (i=0; i<N; i++)
{
	// Определить плечо текущего участка ролика (растояние от текущего участка до середины ролика).
	xi = i*OM + OM/2 - Lw/2;

	// Нарастить суммарный момент действующий на ролик со стороны внутреннего кольца на момент действующий на данном участке.
	*uk_QBL += *(SIGI+j*N+i)*OM * *(Bv+j*N+i)*xi;

	// Нарастить суммарный момент действующий на ролик со стороны наружного кольца на момент действующий на данном участке.
	*uk_QHL += *(SIGO+j*N+i)*OM * *(Bn+j*N+i)*xi;
}

// Определить невязку уравнения равновесия сил действующих на ролик.
*uk_Qnev = *uk_Qv - *uk_Qn+Fc;

// Определить невязку уравнения моментов действующих на ролик.
*uk_Mnev = *uk_QBL - *uk_QHL;

// Определить составную невязку уравнений равновесия сил и моментов действующих на ролик.
sostav_newjaz = sqrt(*uk_Qnev * *uk_Qnev + *uk_Mnev * *uk_Mnev);



// Выход из функции с возвратом составной невязки уравнения равновесия сил и моментов действующих на ролик
return sostav_newjaz;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
///	РЕШЕНИЕ СИСТЕМ УРАВНЕНИЙ РАВНОВЕСИЯ СИЛ И МОМЕНТОВ ДЕЙСТВУЮЩИХ НА ВСЕ РОЛИКИ.	
///	ПОЛУЧЕНИЕ НЕВЯЗКИ УРАВНЕНИЯ РАВНОВЕСИЯ СИЛ ДЕЙСТВУЮЩИХ НА ВНУТРЕННЕЕ КОЛЬЦО	
///
///
/// Входные параметры :	
///	   DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
///	W_sep - Угловая скорость вращения сепаратора в радианах/секунда
///
/// Выходные параметры :	
///	* bmo - Суммарный момент действующий со стороны роликов на внутреннее кольцо.
///
///


double pprz( double DR , double * bmo, double W_sep )
{

double eps;	// Допустимая погрешность составной невязки уравнений равновесия сил и моментов действующих на ролик
double k1;	// Коэффициент приращения по x1	
double k2;	// Коэффициент приращения по x2	
double fro;	// Сумма проекций на ось OY усилий в контакте роликов с внутренним кольтцом.
int j;		// Счетчик роликов.	
double fi;	// Угловая координата ролика в радианах.	
double fti;	// Угловая координата ролика в градусах
double a;	// Косинус угловой координаты ролика.
double x1;	// Сближение ролика с наружным кольцом
double x2;	// Угол перекоса ролика.
double Qnev;  	// Невязка уравнений сил действующих на ролик
double Mnev;  	// Невязка уравнений моментов действующих на ролик		
double Qv;  	// Усилие в контакте ролика с внутренним кольцом
double Qn;  	// Усилие в контакте ролика с наружным кольцом	
double QBL;  	// Момент действующий на ролик со стороны внутреннего кольца
double QHL;  	// Момент действующий на ролик со стороны наружного кольца
double pr;  	// Cоставная невязка уравнений равновесия сил и моментов действующих на ролик.
double h1, h2;	// Шаг приращения по переменной x1 и x2.
double tr;	// Определитель матрицы частных производных функций невязок уравнений равновесия сил и моментов действующих на ролик и используемой при шагании по методу Ньютона. 
double pir;	// Определитель матрицы частных производных функций невязок уравнений равновесия сил и моментов действующих на ролик первый столбец которой заменен на взятые с обратным знаком функции невязки уравнений равновесия сил и моментов действующих на ролик.
double por;	// Определитель матрицы частных производных функций невязок уравнений равновесия сил и моментов действующих на ролик второй столбец которой заменен на взятые с обратным знаком функции невязки уравнений равновесия сил и моментов действующих на ролик.
double frr;	// Проекция на ось OY усилия в контакте ролика с внутренним кольцом.
double bm;	// Момент действующий со стороны ролика на внутренее кольцо.	
double fraz;	// Невязкой кравнения равновесия внутреннего кольца

double dQnev_dx1;	// Частная производная функции невязки уравнения равновесия по переменной X1.
double dQnev_dx2;	// Частная производная функции невязки уравнения равновесия по переменной X2.
double dMnev_dx1;	// Частная производная функции невязки уравнения равновесия моментов по переменной X1.
double dMnev_dx2;	// Частная производная функции невязки уравнения равновесия моментов по переменной X2.

double pr_0_0, pr_1_0, pr_2_0, pr_m1_0, pr_m2_0, pr_0_1, pr_0_2, pr_0_m1, pr_0_m2;			// Вспомогательная переменная для хранения составной невязки уравнений сил и моментов действующих на ролик. 
double Qnev_0_0, Qnev_1_0, Qnev_2_0, Qnev_m1_0, Qnev_m2_0, Qnev_0_1, Qnev_0_2, Qnev_0_m1, Qnev_0_m2;	// Вспомогательная переменная для хранения невязки уравнения сил действующих на ролик.
double Mnev_0_0, Mnev_1_0, Mnev_2_0, Mnev_m1_0, Mnev_m2_0, Mnev_0_1, Mnev_0_2, Mnev_0_m1, Mnev_0_m2;	// Вспомогательная переменная для хранения невязки уравнений моментов действующих на ролик.
double x1_0_0, x1_1_0, x1_2_0, x1_m1_0, x1_m2_0, x1_0_1, x1_0_2, x1_0_m1, x1_0_m2;			// Вспомогательная переменная для хранения x1.
double x2_0_0, x2_1_0, x2_2_0, x2_m1_0, x2_m2_0, x2_0_1, x2_0_2, x2_0_m1, x2_0_m2;			// Вспомогательная переменная для хранения x2.


// Задание допустимой погрешности составной невязки уравнения сил и моментов действующих на ролик
//eps = 0.005;
//eps = 0.00005;
//eps = 0.00001;
//eps = 0.000005;
//eps = 0.000002;
//eps = 0.0000005;
//eps = 0.0000003;
//eps = 0.0000002;
//eps = 0.0000001;
  eps = 0.00000005;


// Задание коэффициента приращения по переменной x1
k1 = 0.001;

// Задание коэффициента приращения по переменной x2
k2 = 0.001;

// Обнулить суммарный момент действующий со стороны роликов на внутреннее кольцо
*bmo = 0.0;

// Обнулить сумму проекций на ось OY усилий в контакте роликов с внутренним кольтцом.
fro = 0.0;


// Перебор в цикле всех роликов подшипника.
for(j=0; j<Z; j++)
{
	// Определить угловую координату в радианах очередного ролика.
	fi = 2*pi* (double) j / ((double) Z);

	// Определить угловую координату в градусах очередного ролика.
	fti = fi*180/pi;

	// Определение  растояние от оси ролика до дорожки качения внутреннего кольца 
	// Rvk ..................................................
	// ..................................................

	// Определить косинус угловой координаты ролика, он является коэффициентом при нахожденеии 
	// проекции усилия в контакте ролика с внутренним кольцом на ось OY.
	a = cos(fi);

	// Взять начальное приближение сближения ролика с наружным кольцом.
	x1 = DF;

	// Взять начальное приближение угла перекоса ролика
	x2 = B;

	// Цикл поиска x1, x2 так чтобы pr - составная невязка уравнений сил и моментов действующих на ролик была меньше eps.

	while (1)	
	{
		// Вызов функции определения деформаций и нагрузок действубщих по длине полоски контакта ролика
		// и дорожек качения наружного и внутреннего колец. Определение невязок уравнений сил и моментов 
		// действующих на ролик.
		//
		// Входные параметры :
		//		x1 - Сближение ролика с наружным кольцом	
		//		x2 - Угол перекоса ролика		
		//		DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		//		 j - Номер ролика		
		//	 W_sep - Угловая скорость сепаратора в радианах/секунда
		//
		// Выходные параметры :
		//		Qnev - Невязка уравнений сил действующих на ролик
		//		Mnev - Невязка уравнений моментов действующих на ролик		
		//		  Qv - Усилие в контакте ролика с внутренним кольцом
		//		  Qn - Усилие в контакте ролика с наружным кольцом	
		//		 QBL - Момент действующий на ролик со стороны внутреннего кольца
		//		 QHL - Момент действующий на ролик со стороны наружного кольца
		//	
		// Возвращаемое значение :	
		// 		 pr - составная невязка уравнений равновесия сил и моментов действующих на ролик.
		//
		pr = roz( x1, x2, DR, j, W_sep, &Qnev, &Mnev, &Qv, &Qn, &QBL, &QHL); 
		
		// Если составная невязка меньше eps тогда выход из цикла поиска x1, x2.
		if (pr < eps) break;
			 
		// Запомнить составную невязку, невязки уравнений сил и моментов для текущего x1, x2.
		pr_0_0 	 = pr;
		Qnev_0_0 = Qnev;
		Mnev_0_0 = Mnev;
		x1_0_0	 = x1;
		x2_0_0	 = x2;

		// Получение данных для численного нахождения частных производных функций невязки уравнениия сил и 
		// невязки уравнений моментов по переменной X1.

		// Задать шаг приращения по переменной X1.
		h1 = x1_0_0*k1;
		if (h1==0) h1=0.000001;

		// Сделать малое приращение переменной X1.
		x1 = x1_0_0 + h1;
	
		// Вызов функции определения деформаций и нагрузок действубщих по длине полоски контакта ролика
		// и дорожек качения наружного и внутреннего колец. Определение невязок уравнений сил и моментов 
		// действующих на ролик.
		//
		// Входные параметры :
		//		x1 - Сближение ролика с наружным кольцом	
		//		x2 - Угол перекоса ролика		
		//		DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		//		 j - Номер ролика		
		//	 W_sep - Угловая скорость сепаратора в радианах/секунда
		//
		// Выходные параметры :
		//		Qnev - Невязка уравнений сил действующих на ролик
		//		Mnev - Невязка уравнений моментов действующих на ролик		
		//		  Qv - Усилие в контакте ролика с внутренним кольцом
		//		  Qn - Усилие в контакте ролика с наружным кольцом	
		//		 QBL - Момент действующий на ролик со стороны внутреннего кольца
		//		 QHL - Момент действующий на ролик со стороны наружного кольца
		//	
		// Возвращаемое значение :	
		// 		 pr - составная невязка уравнений равновесия сил и моментов действующих на ролик.
		//
		pr = roz( x1, x2, DR, j, W_sep, &Qnev, &Mnev, &Qv, &Qn, &QBL, &QHL); 

		// Если составная невязка меньше eps тогда выход из цикла поиска x1, x2.
		if (pr < eps) break;

		// Запомнить составную невязку, невязки уравнений сил и моментов для текущего x1, x2.
		pr_1_0 	 = pr;
		Qnev_1_0 = Qnev;
		Mnev_1_0 = Mnev;
		x1_1_0	 = x1;
		x2_1_0	 = x2;

		// Сделать двойное малое приращение переменной X1.
		x1 = x1_0_0 + 2*h1;

		// Вызов функции определения деформаций и нагрузок действубщих по длине полоски контакта ролика
		// и дорожек качения наружного и внутреннего колец. Определение невязок уравнений сил и моментов 
		// действующих на ролик.
		//
		// Входные параметры :
		//		x1 - Сближение ролика с наружным кольцом	
		//		x2 - Угол перекоса ролика		
		//		DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		//		 j - Номер ролика		
		//	 W_sep - Угловая скорость сепаратора в радианах/секунда
		//
		// Выходные параметры :
		//		Qnev - Невязка уравнений сил действующих на ролик
		//		Mnev - Невязка уравнений моментов действующих на ролик		
		//		  Qv - Усилие в контакте ролика с внутренним кольцом
		//		  Qn - Усилие в контакте ролика с наружным кольцом	
		//		 QBL - Момент действующий на ролик со стороны внутреннего кольца
		//		 QHL - Момент действующий на ролик со стороны наружного кольца
		//	
		// Возвращаемое значение :	
		// 		 pr - составная невязка уравнений равновесия сил и моментов действующих на ролик.
		//
		pr = roz( x1, x2, DR, j, W_sep, &Qnev, &Mnev, &Qv, &Qn, &QBL, &QHL); 

		// Если составная невязка меньше eps тогда выход из цикла поиска x1, x2.
		if (pr < eps) break;

		// Запомнить составную невязку, невязки уравнений сил и моментов для текущего x1, x2.
		pr_2_0 	 = pr;
		Qnev_2_0 = Qnev;
		Mnev_2_0 = Mnev;
		x1_2_0	 = x1;
		x2_2_0	 = x2;

		// Сделать обратное малое приращение переменной X1.
		x1 = x1_0_0 - h1;

		// Вызов функции определения деформаций и нагрузок действубщих по длине полоски контакта ролика
		// и дорожек качения наружного и внутреннего колец. Определение невязок уравнений сил и моментов 
		// действующих на ролик.
		//
		// Входные параметры :
		//		x1 - Сближение ролика с наружным кольцом	
		//		x2 - Угол перекоса ролика		
		//		DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		//		 j - Номер ролика		
		//	 W_sep - Угловая скорость сепаратора в радианах/секунда
		//
		// Выходные параметры :
		//		Qnev - Невязка уравнений сил действующих на ролик
		//		Mnev - Невязка уравнений моментов действующих на ролик		
		//		  Qv - Усилие в контакте ролика с внутренним кольцом
		//		  Qn - Усилие в контакте ролика с наружным кольцом	
		//		 QBL - Момент действующий на ролик со стороны внутреннего кольца
		//		 QHL - Момент действующий на ролик со стороны наружного кольца
		//	
		// Возвращаемое значение :	
		// 		 pr - составная невязка уравнений равновесия сил и моментов действующих на ролик.
		//
		pr = roz( x1, x2, DR, j, W_sep, &Qnev, &Mnev, &Qv, &Qn, &QBL, &QHL); 

		// Если составная невязка меньше eps тогда выход из цикла поиска x1, x2.
		if (pr < eps) break;

		// Запомнить составную невязку, невязки уравнений сил и моментов для текущего x1, x2.
		pr_m1_0   = pr;
		Qnev_m1_0 = Qnev;
		Mnev_m1_0 = Mnev;
		x1_m1_0	  = x1;
		x2_m1_0	  = x2;

		// Сделать двойное обратное малое приращение переменной X1.
		x1 = x1_0_0 - 2*h1;

		// Вызов функции определения деформаций и нагрузок действубщих по длине полоски контакта ролика
		// и дорожек качения наружного и внутреннего колец. Определение невязок уравнений сил и моментов 
		// действующих на ролик.
		//
		// Входные параметры :
		//		x1 - Сближение ролика с наружным кольцом	
		//		x2 - Угол перекоса ролика		
		//		DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		//		 j - Номер ролика		
		//	 W_sep - Угловая скорость сепаратора в радианах/секунда
		//
		// Выходные параметры :
		//		Qnev - Невязка уравнений сил действующих на ролик
		//		Mnev - Невязка уравнений моментов действующих на ролик		
		//		  Qv - Усилие в контакте ролика с внутренним кольцом
		//		  Qn - Усилие в контакте ролика с наружным кольцом	
		//		 QBL - Момент действующий на ролик со стороны внутреннего кольца
		//		 QHL - Момент действующий на ролик со стороны наружного кольца
		//	
		// Возвращаемое значение :	
		// 		 pr - составная невязка уравнений равновесия сил и моментов действующих на ролик.
		//
		pr = roz( x1, x2, DR, j, W_sep, &Qnev, &Mnev, &Qv, &Qn, &QBL, &QHL); 

		// Если составная невязка меньше eps тогда выход из цикла поиска x1, x2.
		if (pr < eps) break;

		// Запомнить составную невязку, невязки уравнений сил и моментов для текущего x1, x2.
		pr_m2_0   = pr;
		Qnev_m2_0 = Qnev;
		Mnev_m2_0 = Mnev;
		x1_m2_0	  = x1;
		x2_m2_0	  = x2;

		// Получение данных для численного нахождения частных производных функций невязки уравнениия сил и 
		// невязки уравнений моментов по переменной X2.

		// Вернуться в исходную точку по X1.
		x1 = x1_0_0;

		// Получение данных для численного нахождения частных производных функций невязки уравнениия сил и 
		// невязки уравнений моментов по переменной X2.

		// Задать шаг приращения по переменной X2.
		h2 = x2_0_0*k2;
		if (h2 == 0) h2 = 0.000001;

		// Сделать малое преращение по переменной X2.
		x2 = x2_0_0 + h2;

		// Вызов функции определения деформаций и нагрузок действубщих по длине полоски контакта ролика
		// и дорожек качения наружного и внутреннего колец. Определение невязок уравнений сил и моментов 
		// действующих на ролик.
		//
		// Входные параметры :
		//		x1 - Сближение ролика с наружным кольцом	
		//		x2 - Угол перекоса ролика		
		//		DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		//		 j - Номер ролика		
		//	 W_sep - Угловая скорость сепаратора в радианах/секунда
		//
		// Выходные параметры :
		//		Qnev - Невязка уравнений сил действующих на ролик
		//		Mnev - Невязка уравнений моментов действующих на ролик		
		//		  Qv - Усилие в контакте ролика с внутренним кольцом
		//		  Qn - Усилие в контакте ролика с наружным кольцом	
		//		 QBL - Момент действующий на ролик со стороны внутреннего кольца
		//		 QHL - Момент действующий на ролик со стороны наружного кольца
		//	
		// Возвращаемое значение :	
		// 		 pr - составная невязка уравнений равновесия сил и моментов действующих на ролик.
		//
		pr = roz( x1, x2, DR, j, W_sep, &Qnev, &Mnev, &Qv, &Qn, &QBL, &QHL); 

		// Если составная невязка меньше eps тогда выход из цикла поиска x1, x2.
		if (pr < eps) break;

		// Запомнить составную невязку, невязки уравнений сил и моментов для текущего x1, x2.
		pr_0_1 	 = pr;
		Qnev_0_1 = Qnev;
		Mnev_0_1 = Mnev;
		x1_0_1	 = x1;
		x2_0_1	 = x2;

		// Сделать второе малое преращение по переменной X2.
		x2 = x2_0_0 + 2*h2;

		// Вызов функции определения деформаций и нагрузок действубщих по длине полоски контакта ролика
		// и дорожек качения наружного и внутреннего колец. Определение невязок уравнений сил и моментов 
		// действующих на ролик.
		//
		// Входные параметры :
		//		x1 - Сближение ролика с наружным кольцом	
		//		x2 - Угол перекоса ролика		
		//		DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		//		 j - Номер ролика		
		//	 W_sep - Угловая скорость сепаратора в радианах/секунда
		//
		// Выходные параметры :
		//		Qnev - Невязка уравнений сил действующих на ролик
		//		Mnev - Невязка уравнений моментов действующих на ролик		
		//		  Qv - Усилие в контакте ролика с внутренним кольцом
		//		  Qn - Усилие в контакте ролика с наружным кольцом	
		//		 QBL - Момент действующий на ролик со стороны внутреннего кольца
		//		 QHL - Момент действующий на ролик со стороны наружного кольца
		//	
		// Возвращаемое значение :	
		// 		 pr - составная невязка уравнений равновесия сил и моментов действующих на ролик.
		//
		pr = roz( x1, x2, DR, j, W_sep, &Qnev, &Mnev, &Qv, &Qn, &QBL, &QHL); 

		// Если составная невязка меньше eps тогда выход из цикла поиска x1, x2.
		if (pr < eps) break;

		// Запомнить составную невязку, невязки уравнений сил и моментов для текущего x1, x2.
		pr_0_2 	 = pr;
		Qnev_0_2 = Qnev;
		Mnev_0_2 = Mnev;
		x1_0_2	 = x1;
		x2_0_2	 = x2;

		// Сделать обратное малое преращение по переменной X2.
		x2 = x2_0_0 - h2;

		// Вызов функции определения деформаций и нагрузок действубщих по длине полоски контакта ролика
		// и дорожек качения наружного и внутреннего колец. Определение невязок уравнений сил и моментов 
		// действующих на ролик.
		//
		// Входные параметры :
		//		x1 - Сближение ролика с наружным кольцом	
		//		x2 - Угол перекоса ролика		
		//		DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		//		 j - Номер ролика		
		//	 W_sep - Угловая скорость сепаратора в радианах/секунда
		//
		// Выходные параметры :
		//		Qnev - Невязка уравнений сил действующих на ролик
		//		Mnev - Невязка уравнений моментов действующих на ролик		
		//		  Qv - Усилие в контакте ролика с внутренним кольцом
		//		  Qn - Усилие в контакте ролика с наружным кольцом	
		//		 QBL - Момент действующий на ролик со стороны внутреннего кольца
		//		 QHL - Момент действующий на ролик со стороны наружного кольца
		//	
		// Возвращаемое значение :	
		// 		 pr - составная невязка уравнений равновесия сил и моментов действующих на ролик.
		//
		pr = roz( x1, x2, DR, j, W_sep, &Qnev, &Mnev, &Qv, &Qn, &QBL, &QHL); 

		// Если составная невязка меньше eps тогда выход из цикла поиска x1, x2.
		if (pr < eps) break;

		// Запомнить составную невязку, невязки уравнений сил и моментов для текущего x1, x2.
		pr_0_m1   = pr;
		Qnev_0_m1 = Qnev;
		Mnev_0_m1 = Mnev;
		x1_0_m1	  = x1;
		x2_0_m1	  = x2;

		// Сделать второе обратное малое преращение по переменной X2.
		x2 = x2_0_0 - 2*h2;

		// Вызов функции определения деформаций и нагрузок действубщих по длине полоски контакта ролика
		// и дорожек качения наружного и внутреннего колец. Определение невязок уравнений сил и моментов 
		// действующих на ролик.
		//
		// Входные параметры :
		//		x1 - Сближение ролика с наружным кольцом	
		//		x2 - Угол перекоса ролика		
		//		DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		//		 j - Номер ролика		
		//	 W_sep - Угловая скорость сепаратора в радианах/секунда
		//
		// Выходные параметры :
		//		Qnev - Невязка уравнений сил действующих на ролик
		//		Mnev - Невязка уравнений моментов действующих на ролик		
		//		  Qv - Усилие в контакте ролика с внутренним кольцом
		//		  Qn - Усилие в контакте ролика с наружным кольцом	
		//		 QBL - Момент действующий на ролик со стороны внутреннего кольца
		//		 QHL - Момент действующий на ролик со стороны наружного кольца
		//	
		// Возвращаемое значение :	
		// 		 pr - составная невязка уравнений равновесия сил и моментов действующих на ролик.
		//
		pr = roz( x1, x2, DR, j, W_sep, &Qnev, &Mnev, &Qv, &Qn, &QBL, &QHL); 

		// Если составная невязка меньше eps тогда выход из цикла поиска x1, x2.
		if (pr < eps) break;

		// Запомнить составную невязку, невязки уравнений сил и моментов для текущего x1, x2.
		pr_0_m2   = pr;
		Qnev_0_m2 = Qnev;
		Mnev_0_m2 = Mnev;
		x1_0_m2	  = x1;
		x2_0_m2	  = x2;

		// Вернуться в исходную точку по X2.
		x2 = x2_0_0;

		//				d q(x1 x2)
		//	Получить	----------- - частную производную функции невязки уравнения равновесия ролика по X1
		//				d x1
		//
		dQnev_dx1 = (-Qnev_2_0 + 8*Qnev_1_0 - 8*Qnev_m1_0 + Qnev_m2_0) / (12*h1);

		//				d q(x1 x2)
		//	Получить	----------- - частную производную функции невязки уравнения равновесия ролика по X2
		//				d x2
		//
		dQnev_dx2 = (-Qnev_0_2 + 8*Qnev_0_1 - 8*Qnev_0_m1 + Qnev_0_m2) / (12*h2);

		//				d M(x1 x2)
		//	Получить	----------- - частную производную функции невязки уравнения моментов действующих на ролик по X1
		//				d x1
		//
		dMnev_dx1 = (-Mnev_2_0 + 8*Mnev_1_0 - 8*Mnev_m1_0 + Mnev_m2_0) / (12*h1);

		//				d M(x1 x2)
		//	Получить	----------- - частную производную функции невязки уравнения моментов действующих на ролик по X2
		//				d x2
		//
		dMnev_dx2 = (-Mnev_0_2 + 8*Mnev_0_1 - 8*Mnev_0_m1 + Mnev_0_m2) / (12*h2);

		// Получить определитель матрицы частных производных функций невязок уравнений равновесия сил и моментов 
		// действующих на ролик и используемой при шагании по методу Ньютона. 		
		// 		
		tr = dQnev_dx1 * dMnev_dx2 - dMnev_dx1 * dQnev_dx2;

		// Получить определитель матрицы частных производных функций невязок уравнений равновесия сил и моментов 
		// действующих на ролик первый столбец которой заменен на взятые с обратным знаком функции невязки уравнений 
		// равновесия сил и моментов действующих на ролик.
		pir = -Qnev_0_0 * dMnev_dx2 + Mnev_0_0 * dQnev_dx2;	

		// Получить определитель матрицы частных производных функций невязок уравнений равновесия сил и моментов 
		// действующих на ролик второй столбец которой заменен на взятые с обратным знаком функции невязки уравнений 
		// равновесия сил и моментов действующих на ролик.
		por	= -dQnev_dx1 * Mnev_0_0 + dMnev_dx1 * Qnev_0_0;


		//////////////////////////
		///
		if (tr==0) break;
		///	
		/////////////////////////

		// Шагание по методу Ньютона. Нахождения следующего приближения по X1 и X2.
		x1 = x1 + koeff_shag_1 * pir/tr;
		x2 = x2 + koeff_shag_1 * por/tr;
	}

	// Выполняются уравнения равновесия сил и моментов действующих на ролик.
	// Составная невязка меньше pr.

	// Записать в массив найденное усилие в контакте текущего ролика с внутренним кольцом.
	*(QJ+j)= Qv;

	// Записать в массив найденное усилие в контакте текущего ролика с наружным кольцом.
	*(QHU+j)= Qn;

	// Определить проекцию на ось OY усилия в контакте ролика с внутренним кольцом.
	frr = Qv * a;

	// Нарастить сумму проекций на ось OY усилий в контакте роликов с внутренним кольцом.
	fro += frr;
	
	// Опредилить эксцентриситет нагрузки приложенной к текущему ролику (растояние от центра ролика до точки приложения нагрузки).
	*(DEC+j)= 0;	
	if (Qv > 0) *(DEC+j)= QBL/Qv;

	// Определить момент действующий со стороны текущего ролика на внутреннее кольцо.
	bm = frr * *(DEC+j);

	// Нарастить суммарный момент действующий со стороны ролика на внутреннее кольцо. 
	*bmo += bm;	

	// Запомнить найденное сближение ролика с наружным кольцом.
	// Оно будет являться начальным приближением при поиске сближения для следующего ролика.
	DF = x1;

	// Запомнить найденный угол перекоса ролика. 
	// Он будет являться начальным приближением при поиске угла перекоса следующего ролика.
	B = x2;

	// Записать в массив сближение ролика с наружным кольцом и угол перекоса ролика переведенный в минуты.
	*(F1X+j) = x1;
	*(F2X+j) = x2*180*60/pi;	

	// Записать найденные невязки уравнений равновесия сил и моментов действующих на ролик в массивы.
	*(F1V+j) = Qnev;
	*(F2V+j) = Mnev;
}

// Определить отклонение суммы проекций на ось OY усилий в контакте роликов 
// с внутренним кольцом от радиальной нагрузки действующей на подшипник. 
// Это является невязкой кравнения равновесия внутреннего кольца (на внутреннее кольцо давит нагрузка и ролики).
//
fraz = fro - FR;


// Выход из функции с возвратом невязки уравнения равновесия внутреннего кольца
return fraz; 

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////			ПОДПРОГРАММА ОПРЕДЕЛЕНИЯ ВЯЗКОСТИ ПО ФОРМУЛЕ РОЛАНДСА		/////////////////////////
///
///	Входные параметры :	            P  - Давление в кг/мм2
///				            T  - Темпмература в градусах Кельвина				
///
///	Выходные параметры :	* Pezo_koeff_1 - Указатель на переменную хранящую пъезокоэффициент для расчёта толщины плёнки
///
///	Возвращаемое значение :	     Vyazkost  - Динамическая вязкость смазки с учётом давления в кг*с/мм2


double Vyaz_Rolands( double P,  double T,  double * Pezo_koeff_1)
{

int 	k, j;			// Счётчики цикла	
double	proizved1;		// Вспомогательная переменная служащая для накапливания произведения

double 	Vyazkost;		// Динамическая вязкость в кг*с/мм2
double 	Vyazkost_100_pa_s;	// Динамическая вязкость в 100*Па*с
double 	Vyazkost_pa;		// Динамическая вязкость в Па*с	

double	N0_pa_s;		// Динамическая вязкость при нулевом давлении и температуре в Па*с  (то же что и N0 но в Па*с)  (сделать глобальной)
double	P_pa;			// Давление в Па

double 	Pezo_koeff__10_9_Pa_1;	// Пъезокоэффициент вязкости смазки в  10^9*Па^(-1)
double 	Pezo_koeff_Pa_1;	// Пъезокоэффициент вязкости смазки в Па^(-1)	


// Перевести давление   P   из  кг/мм2    в Па
P_pa = P*10000000;


if ((Maslo >= 1) && (Maslo <= 12))
{
	/// Для масел с номерами от 1 до 12.

	/// Перевести температуру из градусов Кельвина в градусы Цельсия.
	T -= 273;

	switch (vid_aprox)
	{
		case 1:
		{   	
			/// Апроксимация вязкости и пъезокоэффициента с помощью полиномов Лагранжа

			/// Определить динамическую вязкость  в 100*Па*с   и пъезокоэффициент  вязкости смазки в 10^9*Па^(-1)  с помощью полиномов Лагранжа используя ранее вычисленные коэффициенты.
			Vyazkost_100_pa_s 	= 0.0;
			Pezo_koeff__10_9_Pa_1 	= 0.0;

			for (k=0; k < kol_toch_temp; k++)
			{
				///                           kol_toch_smazka-1
				/// Найти произведение 	    	-------               
				///				|     |								
				///				|     |	 (T - Tj)							
				///				|     |								
				///			       j=0  j<>k
				///
				proizved1 = 1.0;
				for (j=0; j < kol_toch_temp; j++)
				{
					if (k != j) proizved1 *= ( T - *(Temp_smazka+j) );
				}
			
				Vyazkost_100_pa_s += *(k_lagr_vyaz+k) * proizved1;              /// Нарастить сумму полинома Лагранжа выдающего вязкость в 100*Па*с 
				Pezo_koeff__10_9_Pa_1 += *(k_lagr_pezo+k) * proizved1;		/// Нарастить сумму полинома Лагранжа выдающего пъезокоэффициент вязкости в 10^9*Па^(-1)
			}

			break;
		}
		
		default :
		{
			/// Апроксимация вязкости и пъезокоэффициента с помощью формулы Баруса

			/// Определить динамическую вязкость в 100*Па*с  по формуле Баруса для текущей температуры	
			Vyazkost_100_pa_s= Vyaz_smazka[0] * exp(-Termo_koeff_Barus*(T-Temp_smazka[0]));	

			/// Определить пъезокоэффициент вязкости смазки в 10^9*Па^(-1)  с помощью апроксимацией экспонентой для текущей температуры
			Pezo_koeff__10_9_Pa_1 = Pezo_smazka[0] * exp(-Koeff_exp_pezo*(T-Temp_smazka[0]));	
		}
	}

	Vyazkost_pa 	= Vyazkost_100_pa_s/ 100;                  	/// Перевод динамической вязкости из 100*Па*с   в  Па*с
	Pezo_koeff_Pa_1 = Pezo_koeff__10_9_Pa_1 / 1000000000;           /// Перевод пъезокоэффициента вязкости из 10^9*Па^(-1)   в  Па^(-1)
	Vyazkost_pa 	=  Vyazkost_pa * exp( Pezo_koeff_Pa_1 * P_pa);	/// Определить динамическую вязкость смазки в Па*с с учётом давления в контакте по формуле Баруса
	Vyazkost_100_pa_s = Vyazkost_pa * 100;				/// Перевод динамической вязкости смазки с учётом давления из Па*с    в   100*Па*с
	Vyazkost 	= Vyazkost_100_pa_s / 1000000000;               /// Перевод динамической вязкости из  100*Па*с    в    кг*с/мм2
	* Pezo_koeff_1 	= Pezo_koeff__10_9_Pa_1 / 100;			/// Получить пъезокоэффициент для расчёта толщины плёнки, деление пъезокоэффициента в 10^9*Па^(-1)   на 100
}
else
{
	/// Для масел с другими номерами 
	N0_pa_s 	= N0*10000000;                  /// Перевести вязкость   N0  из  кг*с/мм2  в Па*с
        Vyazkost_pa 	= N0_pa_s * exp ((log(N0_pa_s)+9.67) * (step(1+5.1*step(10,-9)*P_pa,Z1) * step((T-138)/(T0-138),-SS0)-1));	/// Определить динамическую вязкость смазки при заданном давлении и температуре в Па*с по формуле Роландса.
        Vyazkost 	=  Vyazkost_pa / 10000000;      /// Перевести динамическую вязкость смазки из Па*с  в  кг*с/мм2
	* Pezo_koeff_1 	= Pezo_koeff;			/// Взять пъезокоэффициент вязкости смазки из файла исходных данных и считать его пъезокоэффициентом для расчёта толщины плёнки	
}


// Выход из подпрограммы с возвратом динамической вязкости в кг*с/мм2
return Vyazkost;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////	ПОДПРОГРАММА ВЫЧИСЛЕНИЯ СРЕДНЕГО ЗАЗОРА РОЛИКА В МЕЖКОЛЕЧНОМ ПРОСТРАНСТВЕ ПО МЕТОДУ АКИФЬЕВА	/////
//
// Используемые глобальные переменные :			pi  = 3.1416
//							Dnk - Диаметр дорожки качения наружного кольца   в мм
//							Dvk - Диаметр дорожки качения внутреннего кольца в мм
//							Dw  - Диаметр ролика в мм
//							Bcs - Длина перемычки сепаратора  в мм
//							Rco - Радиус наружной цилиндрической поверхности сепаратора  в мм
//							Rci - Радиус внутренней цилиндрической поверхности сепаратора  в мм
//
//		Возвращаемое значение :			 Cw - Средний зазор ролика в межколечном пространстве м вв
//	

double Zazor_rol()
{

double S_megkol;		// Площадь межколечного пространства в подшипнике в мм2
double S_megkol_rol;		// Площадь межколечного пространства приходящаяся на один ролик в мм2
double S_torec_rol;		// Площадь закрываемая торцом одного ролика в мм2
double S_peremych_sep;		// Площадь закрываемая одной перемычкой сепаратора в мм2
double S_ne_zakryt_rol;		// Не закрытая площадь в межколечном пространстве приходящаяся на один ролик в мм2
double L_torec_rol;		// Длина обода окружности торца ролика в мм.
double Cw;			// Средний зазор ролика в межколечном пространстве в мм


// Определить площадь межколечного пространства в подшипнике в мм2
S_megkol = pi*Dnk*Dnk/4 - pi*Dvk*Dvk/4;

// Определить площадь межколечного пространства приходящаяся на один ролик в мм2
S_megkol_rol = S_megkol/Z;

// Определить площадь закрываемую торцом одного ролика в мм2
S_torec_rol  = pi*Dw*Dw/4;

// Определить площадь закрываемую одной перемычкой сепаратора в мм2
S_peremych_sep = Bcs * (Rco - Rci);

// Определить не закрытую площадь в межколечном пространстве приходящуюся на один ролик в мм2
S_ne_zakryt_rol = S_megkol_rol - S_torec_rol - S_peremych_sep;

// Определить длину обода окружности торца ролика в мм
L_torec_rol = pi * Dw;
		
// Определить средний зазор ролика в межколечном пространстве в мм
Cw = S_ne_zakryt_rol/L_torec_rol;

	
// Возврат найденного среднего зазора ролика в межколечном пространстве в мм.
return Cw;


}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////   ПОДПРОГРАММА ВЫЧИСЛЕНИЯ ТОРМОЗЯЩЕГО МОМЕНТА ОТ СИЛ ЖИДКОСТНОГО ТРЕНИЯ ДЕЙСТВУЮЩИХ НА РОЛИК	/////
///////	  И ПОТЕРЮ МОЩНОСТИ НА ПЕРЕМЕШИВАНИЕ СМАЗКИ							/////
///
///
///	    Входные параметры : 	  W_rol - Угловая скорость ролика в радиан/секунду
///
///	   Выходные параметры :		N_hdr_w1 - Потеря мощности на преодоление гидромеханического сопротивления ролика
///
///
///	Возвращаемое значение :		  TM_rol - Тормозящий момент действующий на ролик в кг * мм
///		


double Trmz_mom_rol( double W_rol, double * N_hdr_w1  )
{


double RO_smes_rol_kg_m3;		// Плотность масловоздушной смеси для роликов в кг/м3

double Vyaz_din_kg_s_mm2;		// Динамическая вязкость смазки в кг*с/мм2
double Vyaz_din_pa_s;			// Динамическая вязкость смазки в Па*с
double Vyaz_kin_m2_s;			// Кинематическая вязкость масловоздушной смеси для ролика в м2/с

double Rw_m;				// Радиус ролика в м.
double Cw_m;				// Средний зазор ролика в межколечном пространстве в м. 
double Lw_m;				// Полная длина ролика в м.

double Re;				// Число Рейнольдса.  
double Ta;				// Число Тейлора.  

double FL;				// Коэффициент трения для ламинарного режима, для цилиндрической поверхности ролика вращающегося в масловоздушной смеси.  
double F;				// Коэффициент трения для цилиндрической поверхности ролика вращающегося в масловоздушной смеси.  
double Cn;				// Коэффициент трения для торцевых поверхностей ролика.
                                        
int znak;				// Знак тормозящего момента

double TM_cyl;				// Тормозящий момент в Н*м действующий на цилиндрическую поверхность ролика
double TM_torc;				// Тормозящий момент в Н*м действующий на торцевые поверхности ролика
double TM_rol;				// Тормозящий момент действующий на ролик в кг * мм

double N_hdr_torc;			// Потеря мощности на торцевой поверхности ролика из за трения о масловоздушную смесь в ВТ.
double N_hdr_cyl;			// Потеря мощности на цилиндрической поверхности ролика из за трения о масловоздушную смесь в ВТ. 

double Pezo_koeff_1;			// Пъезокоэффициент вязкости смазки 


// Определить знак на который будет умножаться найденный тормозящий момент
if (W_rol > 0) znak=-1;  else znak=1;

// Взять угловую скорость ролика по абсолютной величине
W_rol = fabs(W_rol);	

RO_smes_rol_kg_m3	= RO1_smes_rol * 1000000000;			// Получить плотность масловоздушной смеси для ролика в кг/м3
Vyaz_din_kg_s_mm2	= Vyaz_Rolands(Patm,T_w+273, &Pezo_koeff_1);	// Получить динамическую вязкость смазки в кг*с/мм2  по формуле Роландса
Vyaz_din_pa_s		= Vyaz_din_kg_s_mm2 * 1000000 * 9.8;		// Получить динамическую вязкость смазки в Па*с
Vyaz_kin_m2_s		= Vyaz_din_pa_s/RO_smes_rol_kg_m3;		// Получить кинематическую вязкость масловоздушной смеси для ролика в м2/с

Rw_m = Dw/2/1000;	// Получить радиус ролика в м.
Cw_m = Cw/1000;		// Получить средний зазор ролика в межколечном пространстве в м.
Lw_m = Lw/1000;		// Получить полную длину ролика в м. 


 // Получить число Рейнольдса для цилиндрической поверхности ролика вращающегося в масловоздушной смеси.   
Re = Rw_m * W_rol * Cw_m / Vyaz_kin_m2_s;

 // Получить число Тейлора для цилиндрической поверхности ролика вращающегося в масловоздушной смеси.   
Ta = Re * sqrt(Cw_m/Rw_m);

 // Получить коэффициент трения для ламинарного режима, для цилиндрической поверхности ролика вращающегося в масловоздушной смеси.  
FL = 16.0/Re;


if ( Ta >= 41 )
{
	 // Получить коэффициент трения для турбулентно-вихревого режима, для цилиндрнической поверхности ролика 
	 // вращающегося в масловоздушной смеси.
	F = 1.3 * FL * step( Ta/41 , 0.539474 );
}
else
{
	 // Получить коэффициент трения для ламинарного режима, для цилиндрнической поверхности ролика 
	 // вращающегося в масловоздушной смеси.
	F = FL;
}

 // Получить тормозящий момент в Н * м действующий на цилиндрическую поверхность ролика (дисс.Акифьева стр.61 ф-лы 44, 45)
TM_cyl = F * RO_smes_rol_kg_m3 * sqr(Rw_m*W_rol/2) * pi * Rw_m * Lw_m * Rw_m ;

// Потеря мощности в ВТ на цилиндрической поверхности из за трения о масловоздушную смесь
N_hdr_cyl = fabs(TM_cyl*W_rol);		 


 // Получить число Рейнольдса для торцевых поверхностей ролика вращающегося в масловоздушной смеси (дисс.Акифьева стр.62 ф-ла 54)
Re = Rw_m*Rw_m*W_rol/Vyaz_kin_m2_s;

if (Re >= 300000)
{
	// Получить коэффициент для турбулентного режима обтекания торцевых поверхностей. (дисс.Акифьева стр.62 ф-ла 53)
	Cn = 0.146 * step(Re,-0.2);
}
else
{
	// Получить коэффициент для ламинарного режима обтекания торцевых поверхностей. (дисс.Акифьева стр.62 ф-ла 52)
	Cn = 3.87 * step(Re,-0.5);
}

 // Определить тормозящий момент в Н * м действующий на торцевые поверхности ролика (дисс.Акифьева стр.62 ф-ла 52)
TM_torc = 0.5 * RO_smes_rol_kg_m3 * W_rol*W_rol * step(Rw_m,5) * Cn;

// Потеря мощности в ВТ на торцевых поверхнотях ролика из за трения о масловоздушную смесь
N_hdr_torc = fabs(TM_torc*W_rol);

 // Получить суммарный тормозящий момент действующий на ролик в Н * м
TM_rol = TM_cyl	+ TM_torc;

// Получить суммарные затраты мощности на преодоление гидродинамического сопротивления ролика в ваттах.
* N_hdr_w1 = N_hdr_cyl + N_hdr_torc;

 // Перевод тормозящего момента действующего на ролик в кг * мм
TM_rol = TM_rol*1000/9.8;

 // Установить знак тормозящего момента
TM_rol = TM_rol * znak;



 // Выход из подпрограммы с возвратом тормозящего момента действующего на ролик в кг * мм
return TM_rol;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////	ПОДПРОГРАММА ОПРЕДЕЛЕНИЯ СИЛЫ ТРЕНИЯ В КОНТАКТЕ РОЛИКА		/////////////////////
////////////////	С ДОРОЖКОЙ КАЧЕНИЯ КОЛЬЦА					/////////////////////
///
///
///	    Входные параметры :	     nom_rolik - Номер ролика для которого выполняется расчет.
///					 W_sep - Угловая скорость сепаратора.
///					 W_rol - Угловая скорость ролика	
///				     T_rab_cel - Рабочая температура конитакта в градусах Цельсия
///				   priz_pechat - Признак печати распределения касательных напряжений в контакте ролика с дорожкой качения кольца
///			 	     vid_kolca - Вид кольца 'i'- внутреннее,  'o'- наружное.
///
///     Выходные параметры :   	      * N_sum1 - Потеря мощности в контакте в ВТ.
///				
///	Возвращаемое значение :     	F_tren - Сила трения в контакте ролика с дорожкой качения указанного кольца в кг
///
///

double	F_tren_kontakt_rolik_dorogka( int nom_rolik, double W_sep, double W_rol, double T_rab_cel, char vid_kolca, int priz_pechat, double * N_sum1 )
{

double dF_tr;			// Сила трения на участке контакта ролика с дорожкой качения кольца
double F_tren;			// Сила трения в контакте ролика с дорожкой качения указанного кольца

double F_tren_polosa_i;		// Сила трения на полосе № i в контакте ролика с дорожкой качения кольца

double Q_uch;			// Нормальное усилие на участке контакта ролика с дорожкой качения кольца
double Q_i;			// Нормальная нагрузка в центре полосы № i в контакте ролика с дорожкой качения кольца
double R_rol_tek_uch;		// Радиус ролика на текущем участке участке
double Rxk;			// Радиус совместной кривизны ролика и дорожки качения кольца
double V_skol_poverh;		// Скорость скольжения поверхностей в контакте ролика с дорожкой качения кольца	
double V_skol_poverh_i;		// Скорость скольжения поверхностей в контакте ролика с дорожкой качения кольца в центре полосы № i.
double U_kach;			// Скорость качения ролика по дорожке качения кольца
double U_kach_i;		// Скорость качения ролика по дорожке качения кольца в центре полосы № i.
double t_relax;			// Время релаксации смазки = времени прохождения контакта = Макс.ширина полосы контакта / Скорость качения ролика по дорожке	 
double P_uch;			// Давление на текущем участке контакта ролика с дорожкой качения кольца
double Q_pog_uch;		// Погонная нагрузка на текущем участке контакта ролика с дорожкой качения кольца.	
double P_i;			// Напряжение в центре полосы № i контакта ролика с дорожкой качения кольца		

double Nr;			// Вязкость смазки при рабочем давлении и рабочей температуре вычисленная по формуле Роландса
double N0t;			// Вязкость смазки при атмосферном давлении и рабочей температуре вычисленная по формуле Роландса
double Nr_i;			// Динамическая вязкость смазки в центре полосы № i

double Pezo_koeff_1;		// Пъзокоэффициент ( коэффициент зависимости вязкости от давления при рабочей температуре и давлении ).
double V_vtek_smaz;		// Скорость втекания смазки в контакт
double Uk;			// Безразмерный параметр скорости в контакте ролика с дорожкой качения кольца
double Gk;			// Безразмерный параметр материала в контакте ролика с дорожкой качения кольца	
double Wk;			// Безразмерный параметр нагрузки в контакте ролика с дорожкой качения кольца
double h_centr;			// Определить толщину маслянной пленки в центре контакта
double h_centr_i;		// Толщина маслянной плёнки в центре полосы № i	

double t_;			// Касательное напряжение на текущем участке
double t_i;			// Касательное напряжение в центре полосы № i в контакте ролика с дорожкой качения кольца 
double T_rab_kelvin;		// Рабочая температура контакта в градусах Кельвина	
int i, j;			// Счетчики циклов
double N_sum;			// Суммарная потеря мощности в контакте в ВТ
double dN;			// Потеря мощности в ВТ на участке контакта
//double dP;			// Шаг по давлению ( используется для определения пъезокоэффициента вязкости смазки)

double lambda1;			// Коэффициент лямбда1 характеризует степень сухости трения, равен отношению толщины маслянной плёнки к суммарной среднеквадратической шероховатости поверхностей ролика и дорожки качения на участке контакта
double exp_lambda;		// Вспомогательная переменная exp(-1.8*lambda^1.2) используемая для определения добавки на сухое трение на участке контакта.
double	dF_tr_suh; 		// Добавка из за сухого трения


// Получить рабочую температуру в контакте в градусах Кельвина
T_rab_kelvin = T_rab_cel+273;


// Обнулить суммарную потерю мощности в ВТ в контакте ролика с дорожкой качения указанного кольца
N_sum = 0;

// Обнулить силу трения в кг в контакте ролика с дорожкой качения указанного кольца
F_tren = 0.0;

// Перебор в цикле всех участков в зоне контакта ролика с дорожкой качения кольца
for (i=0; i<N; i++)
{
	// Обнулить силу трения по полосе № i
	F_tren_polosa_i = 0.0;
	Q_i 		= 0.0;                        // Сброс признака нахождения нормальной нагрузки в центре полосы № i
	P_i 		= 0.0;                        // Сброс признака нахождения напряжения в центре полосы  № i
	V_skol_poverh_i = 0.0;                        // Сброс признака нахождения скорости скольжения поверхностей в центре полосы № i
        t_i  		= 0.0;                        // Сброс признака нахождения касательного напряжения в центре полосы № i
	U_kach_i 	= 0.0;                        // Сброс признака нахождения скорости качения поверхностей в центре полосы № i
	h_centr_i 	= 0.0;                        // Сброс признака нахождения толщины маслянной плёнки в центре полосы № i
	Nr_i	 	= 0.0;                        // Сброс признака нахождения динамической вязкости в центре полосы № i

	for (j=0; j<kol_uch_shirina; j++)
	{
		if (vid_kolca == 'i') 
		{
			// Для внутреннего кольца 
			// Взять давление в кг/мм2 на текущем участке контакта ролика с дорожкой качения внутреннего кольца
			P_uch = *(SIGI2+N*kol_uch_shirina*nom_rolik + kol_uch_shirina*i+j);
		}
		else
		{
			// Для наружного кольца 
			// Взять давление в кг/мм2 на текущем участке контакта ролика с дорожкой качения наружного кольца
			P_uch = *(SIGO2+N*kol_uch_shirina*nom_rolik + kol_uch_shirina*i+j);
		}

		if ( P_uch > 0 )
		{
			// Есть давление на текущем участке области контакта ролика с дорожкой качения

			// Определить нормальное усилие в кг на текущем участке контакта ролика с дорожкой качения кольца
			Q_uch = P_uch * OM * OM;	

			// Определить погонную нагрузку в кг/мм на текущем участке контакта ролика с дорожкой качения кольца
			Q_pog_uch = P_uch * OM;

			// Взять радиус ролика в мм на текущем участке
			R_rol_tek_uch = *(profil+i);

			if (vid_kolca == 'i')
			{
				// Для внутреннего кольца.

				// Определить радиус в мм совместной кривизны ролика и дорожки качения внутреннего кольца (контакт выпуклый).
				Rxk = 1/(1/R_rol_tek_uch + 1/Rvk);

				// Определить скорость скольжения поверхностей в мм/сек в контакте ролика с дорожкой качения внутреннего кольца	
				//V_skol_poverh = Rvk*(W_vk-W_sep) - R_rol_tek_uch*W_rol;
				V_skol_poverh = Rvk*(W_vk-W_sep) - R_rol_tek_uch*(W_rol+W_sep);		// По замечанию Клебанова

				// Определить скорость качения в мм/сек ролика по дорожке внутреннего кольца
				U_kach = Rvk * fabs(W_vk-W_sep);
			}
			else
			{
				// Для наружного кольца.

				// Определить радиус в мм совместной кривизны ролика и дорожки качения наружного кольца (контакт вогнутый).
				Rxk = 1/fabs(1/R_rol_tek_uch - 1/Rnk);

				// Определить скорость скольжения в мм/сек поверхностей в контакте ролика с дорожкой качения наружного кольца	
				//V_skol_poverh = Rnk*(W_sep-W_nk)-R_rol_tek_uch*W_rol;
				//V_skol_poverh = Rnk*(W_sep-W_nk)-R_rol_tek_uch*(W_rol+W_sep);		// По замечанию Клебанова
				V_skol_poverh  = (-1)*(Rnk*(W_sep-W_nk)-R_rol_tek_uch*(W_rol+W_sep));	// По замечанию Клебанова + поменял знак силы трения в контакте с наружным кольцом


				//////////////////////////////////////////////////////////////////////////////////////////////
				//
/*
				if ((nom_rolik == 0) && (i == N/2) && (j == kol_uch_shirina/2))
				{
					fprintf(f2,"\n Сообщение из F_TREN :  для ролика № 0 в точке (%3d ; %3d) V_skol_poverh = %19.12f ", i, j, V_skol_poverh);						

				}
*/
				//			
				//////////////////////////////////////////////////////////////////////////////////////////////


				// Определить скорость качения в мм/сек ролика по дорожке наружного кольца
				U_kach = Rnk * fabs(W_nk-W_sep);
			}

			// Определить скорость в мм/сек втекания смазки в контакт  V = (V1 + V2)/2  (по Хуперту).
			//
			//  где  V1 = Rкольца * (Wкольца-Wсеп) - линейная скорость качения ролика по дорожке качения кольца   
			//       V2 = Rролика * Wролика        - линейная скорость на поверхности ролика
			//
			// Считаем что половина смазки расположена на дорожке качения кольца и входит в контакт со скоростью V1,
			// а вторая половина смазки расположена на поверхности ролика и входит в контакт со скоростью V2.
			// Таким образом скорость вхождения в контакт всей смазки есть средее арифмитическое  V1 и V2. 
			V_vtek_smaz = (U_kach + R_rol_tek_uch*W_rol)/2;

			// Определить динамическую вязкость смазки на участке контакта в кг*с/мм2 по формуле Роландса при рабочем давлении и рабочей температуре
			Nr = Vyaz_Rolands( P_uch+Patm, T_rab_kelvin, &Pezo_koeff_1 );			

			// Определить динамическую вязкость смазки в кг*с/мм2 по формуле Роландса при атмосферном давлении и рабочей температуре
			N0t = Vyaz_Rolands( Patm, T_rab_kelvin, &Pezo_koeff_1 );

			if (vid_kolca == 'i')
			{
				// Для внутреннего кольца.

				// Определить безразмерный параметр скорости в контакте ролика с дорожкой качения внутреннего кольца.
				Uk = fabs( N0t*V_vtek_smaz / (E1_rol_vk*Rxk) );

				// Определить безразмерный параметр материала в контакте ролика с дорожкой качения кольца внутреннего кольца.	
				Gk = Pezo_koeff_1 * E1_rol_vk;

				// Определить безразмерный параметр нагрузки в контакте ролика с дорожкой качения кольца внутреннего кольца
				//Wk = *(QJ + nom_rolik)/(E1_rol_vk*Rxk*Rxk);
				Wk = Q_pog_uch/(E1_rol_vk*Rxk);
			}
			else
			{
				// Для наружного кольца.

				// Определить безразмерный параметр скорости в контакте ролика с дорожкой качения наружного кольца.
				Uk = fabs( N0t*V_vtek_smaz / (E1_rol_nk*Rxk));

				// Определить безразмерный параметр материала в контакте ролика с дорожкой качения кольца наружного кольца	
				Gk = Pezo_koeff_1 * E1_rol_nk;

				// Определить безразмерный параметр нагрузки в контакте ролика с дорожкой качения кольца наружного кольца
				//Wk = *(QHU + nom_rolik)/(E1_rol_vk*Rxk*Rxk);
				Wk = Q_pog_uch/(E1_rol_nk*Rxk);
			}

			// Определить толщину маслянной пленки в центре контакта в мм
			h_centr = ( 2.69 * step(Uk,0.67) * step(Gk,0.53) * step(Wk,-0.067) ) * Rxk;

			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//

///			if ((nom_rolik == 0) && (vid_kolca == 'i') && (j == nom_centr_polosy_zona_kontakt) && (i == 149))
///			{
///				fprintf(f2,"\n  Ролик № 0, центр контакта с ВК  :   h_centr = %8.6f мм.      Uk = %19.12f        Gk = %12.6f       Wk = %19.12f      Rxk = %12.6f ",h_centr ,Uk ,Gk ,Wk ,Rxk);	    	
///			}	
			

			//
			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


			if (vid_kolca == 'i')
			{
				// Для внутреннего кольца.
				// Определить время релаксации смазки в секундах = времени прохождения контакта = Макс.ширина полосы контакта / Скорость качения ролика по дорожке
				t_relax = *(BVmax + nom_rolik)/fabs(U_kach);
			}
			else
			{
				// Для наружного кольца
				// Определить время релаксации смазки в секундах = времени прохождения контакта = Макс.ширина полосы контакта / Скорость качения ролика по дорожке
				t_relax = *(BNmax + nom_rolik)/fabs(U_kach);
			}

			// Определить касательное напряжение в кг/мм2 на текущем участке ролика с дорожкой качения кольца
			t_ = Nr * (1 - exp(-t_relax*Gsdw/Nr)) * V_skol_poverh/h_centr;

			// Сила трения в кг на участке контакта ролика с дорожкой качения кольца
			dF_tr = t_ * OM * OM;

			if ((RZB > 0) || (RZK > 0)) 
			{ 
				// В исходных данных задана шероховатость поверхности дорожки качения кольца или ролика.	
				// Определить дополнение  из за сухого трения поверхности ролика о поверхность дорожки качения кольца

				// Определить коэффициент лямбда1 который характеризует степень сухости трения
                        	lambda1 = h_centr / sqrt(RZB*RZB + RZK*RZK);
			
				// Определить значение вспомогательной переменной exp(-1.8*lambda^1.2) используемой для определения добавки на сухое трение на участке контакта.
				exp_lambda = exp(-1.8*step(lambda1,1.2));		

				// Определить добавку из за сухого трения
				dF_tr_suh = dF_tr * exp_lambda / (1-exp_lambda);

				//printf("\n  lambda1 = %8.5f       dF_tr = %8.5f      dF_tr_suh =  %8.5f ", lambda1, dF_tr,  dF_tr_suh  );	

				// Определить силу трения в контакте с учётом добавки из за сухого трения
				dF_tr = dF_tr + dF_tr_suh;
			}

			// Определить потерю мощности в ВТ на участке контакта 
			dN = fabs(dF_tr * 9.8 * V_skol_poverh / 1000);

			// Нарастить силу трения в контакте ролика с дорожкой качения указанного кольца на величину силы трения на текущем участке
			F_tren += dF_tr;

			// Нарастить силу трения по полосе № i
			F_tren_polosa_i += dF_tr; 

			// Нарастить суммарную потерю мощности в ВТ в контакте ролика с дорожкой качения кольца
			N_sum += dN;

			if (j == nom_centr_polosy_zona_kontakt) 
			{
				// Для центральной продольной полосы в контакте ролика с дорожкой качения кольца
				Q_i 		= Q_uch;		// Запомнить нормальное усилие в кг в центре полосы № i контакта ролика с дорожкой качения кольца	
				P_i 		= P_uch;		// Запомнить нормальное напряжение в кг/мм2 в центре полосы № i контакта ролика с дорожкой качения кольца
				V_skol_poverh_i = V_skol_poverh;	// Запомнить скорость скольжения поверхностей в мм/сек в центре полосы № i контакта ролика с дорожкой качения кольца
				U_kach_i 	= U_kach;		// Запомнить скорость качения ролика по дорожке качения кольца в мм/сек	
				t_i 		= t_;                   // Запомнить касательное напряжение в кг/мм2 в центре полосы № i контакта ролика с дорожкой качения кольца
				h_centr_i 	= h_centr;		// Запомнить толщину маслянной плёнки в мм. в центре полосы № i контакта ролика с дорожкой качения кольца
				Nr_i 		= Nr;			// Запомнить динамическую вязкость смазки в кг*сек/мм2 в центре полосы № i контакта ролика с дорожкой качения кольца		
			}
		}
	}

	if (nom_rolik == nom_rolik_QJ_max)
	{
		/// Для самого нагруженного ролика 
		if (vid_kolca == 'i')
		{
			/// Для контакта самого нагруженного ролика с дорожкой качения внутреннего кольца
			* (Q_centr_0_I+i)		= Q_i;			// Записать нормальное усилие в кг на участке № i центральной полосы
			* (P_centr_0_I+i)		= P_i;			// Записать нормальное напряжение в кг/мм2 на участке № i центральной полосы 
			* (V_skol_poverh_centr_0_I+i)	= V_skol_poverh_i;	// Записать скорость скольжения поверхностей в мм/сек на участке № i центральной полосы 
			* (U_kach_centr_0_I+i)		= U_kach_i;		// Записать скорость качения в мм/сек на участке № i центральной полосы 
			* (t_centr_0_I+i)		= t_i;			// Записать касательное напряжение в кг/мм2 на участке № i центральной полосы
			* (h_centr_0_I+i)		= h_centr_i;		// Записать толщину смазочной плёнки в мм на участке № i центральной полосы
			* (Nr_centr_0_I+i)		= Nr_i;			// Записать динамическую вязкость в кг*сек/мм2 на участке № i центральной полосы
			* (Def_0_I+i)			= * (DB2 + N*kol_uch_shirina*0 + kol_uch_shirina*i + nom_centr_polosy_zona_kontakt);	// Записать деформацию в мм на участке № i центральной полосы
		}		
		else
		{
			/// Для контакта самаого нагруженного ролика с дорожкой качения наружного кольца
			* (Q_centr_0_O+i)		= Q_i;			// Записать нормальное усилие в кг на участке № i центральной полосы
			* (P_centr_0_O+i)		= P_i;			// Записать нормальное напряжение в кг/мм2 на участке № i центральной полосы 
			* (V_skol_poverh_centr_0_O+i)	= V_skol_poverh_i;	// Записать скорость скольжения поверхностей в мм/сек на участке № i центральной полосы
			* (U_kach_centr_0_O+i)		= U_kach_i;		// Записать скорость качения в мм/сек на участке № i центральной полосы
			* (t_centr_0_O+i)		= t_i;			// Записать касательное напряжение в кг/мм2 на участке № i центральной полосы
			* (h_centr_0_O+i)		= h_centr_i;		// Записать толщину смазочной плёнки в мм на участке № i центральной полосы
			* (Nr_centr_0_O+i)		= Nr_i;			// Записать динамическую вязкость в кг*сек/мм2 на участке № i центральной полосы
			* (Def_0_O+i)			= * (DH2 + N*kol_uch_shirina*0 + kol_uch_shirina*i + nom_centr_polosy_zona_kontakt);	// Записать деформацию в мм на участке № i центральной полосы
		}
	}

}

// Записать найденную мощность потерь в выходной параметр
*N_sum1 = N_sum;


// Выход из подпрограммы с возвратом найденного значения силы трения в контакте ролика с дорожкой качения указанного кольца в кг
return F_tren;

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////		ПОДПРОГРАММА ОПРЕДЕЛЕНИЯ НЕВЯЗКИ УРАВНЕНИЯ РАВНОВЕСИЯ МОМЕНТОВ СИЛ		/////////////////////////////////////
///////////////		ДЕЙСТВУЮЩИХ НА РОЛИК								/////////////////////////////////////
///
///
///		Входные параметры :				DR	- Сближение в мм осей внутреннего и наружного кольца из за действия нагрузки.
///								x1	- Сближение в мм оси ролика с дорожкой качения наружного кольца из за действия нагрузки.
///								x2	- Угол перекоса ролика в радианах.
///	    							W_sep	- Угловая скорость в радианах/сек сепаратора.
///								T_w  	- Рабочая температура ролика в градусах Цельсия
///`								T_vk 	- Рабочая температура внутреннего кольца  в градусах Цельсия
///								T_nk 	- Рабочая температура наружного кольца  в градусах Цельсия
///								W_rol 	- Угловая скорость ролика в радиана/секунда
///							      nom_rolik - Номер ролика для которого произвродиться определение невязки
///							   priz_pechat1 - Признак печати строки по состоянию ролика
///							   priz_pechat2 - Признак печати распределения напряжения в контакте ролика с дорожками качения колец
///
///		Выходные параметры :			   * F_rol_sep1 - Сила в кг действующая на перемычку сепаратора со стороны ролика 
///							      * N_hdr_w1 - Полная потеря мощности на ролике в ваттах
///							 * F_tr_rol_sep1 - Сила трения в кг в контакте ролика с перемычкой сепаратора
///
///	 Возвращаемое значение :				Nev	- Невязка уравнения равновесия моментов сил действующих на ролик
///

double Nev_mom_rol( double DR, double x1, double x2, double W_sep, double T_w, double T_vk, double T_nk, double W_rol, int nom_rolik, double * F_rol_sep1, int priz_pechat1, int priz_pechat2, double * N_hdr_w1, double * F_tr_rol_sep1)
{

double F_tr_i;				// Сила трения в кг в контакте ролика с дорожкой качения внутреннего кольца
double F_tr_o;				// Сила трения в кг в контакте ролика с дорожкой качения наружного кольца
double C_fi;				// Рабочий радиальный зазор в мм для ролика с угловой координатой fi
double QLi;				// Тормозящий момент в кг*мм из за набегания смазки по ходу качения ролика на дорожке качения внутреннего кольца		
double QLo; 				// Тормозящий момент в кг*мм из за набегания смазки по ходу качения ролика на дорожке качения наружного кольца		
double F_tr_sep;			// Cила трения ролика о перемычку сепаратора в кг
double Nev;				// Невязка укравнения равновесия моментов сил действующих на ролик в кг*мм
double Mom_rol_t;			// Тянущий момент действующий на ролик в кг * мм
double T_mom;				// Тормозящий момент в кг*мм от сил жидкостного трения действующих на ролик
double fi;				// Угловая координата ролика
double N_hdr_w;				// Потеря мощности на преодоление гидромеханического сопротивления ролика в ваттах
double N_tr_i;				// Потеря мощности в контакте ролика с дорожкой качения внутреннего кольца в ВТ.
double N_tr_o;				// Потеря мощности в контакте ролика с дорожкой качения наружного кольца в ВТ.
double N_tr_sep;			// Потеря мощности в контакте ролика с перемычкой сепаратора в ВТ.
double Megkolech_zazor_mm;		// Межколечный зазор для ролика в мм.


// Определить F_tr_i - силу трения в контакте ролика с дорожкой качения внутреннего кольца в кг, и N_tr_i - потерю мощности в контакте в ВТ. 
F_tr_i = F_tren_kontakt_rolik_dorogka( nom_rolik, W_sep, W_rol, T_vk, 'i', priz_pechat2, &N_tr_i);

// Определить F_tr_o - силу трения в контакте ролика с дорожкой качения наружного кольца в кг, и N_tr_o - потерю мощности в контакте в ВТ. 
F_tr_o = F_tren_kontakt_rolik_dorogka( nom_rolik, W_sep, W_rol, T_nk, 'o', priz_pechat2, &N_tr_o );


// Определить силу действующую на перемычку сепаратора со стороны нагруженного ролика в кг
//* F_rol_sep1 = F_tr_i + F_tr_o;
* F_rol_sep1 = F_tr_i + F_tr_o	- *(Dop_usil_sep + nom_rolik);


// Определить тормозящий момент в кг*мм из за набегания смазки по ходу качения ролика на дорожке качения внутреннего кольца		
QLi = 0;

// Определить тормозящий момент в кг*мм из за набегания смазки по ходу качения ролика на дорожке качения наружного кольца		
QLo = 0;

// Определить силу трения ролика о перемычку сепаратора в кг
F_tr_sep = 0.065 * (* F_rol_sep1) * fabs(W_rol)/W_rol;

// Потеря мощности в контакте ролика с перемычкой сепаратора в ВТ.
N_tr_sep = fabs(F_tr_sep*9.8*Rw/1000*W_rol);


// Записать найденную силу трения в выходной параметр "Сила трения в кг в контакте ролика с перемычкой сепаратора".
* F_tr_rol_sep1 = F_tr_sep;

// Определить тормозящий момент действующий на ролик из за вращения в масляном тумане и 
// потери мощености на перемешивание масляного тумана.
T_mom =	Trmz_mom_rol( W_rol, &N_hdr_w );

// Определить суммарный момент действующий на ролик
Nev =  Rw * (F_tr_i - F_tr_o - F_tr_sep) + QLi + QLo + T_mom;

// Полная потеря мощности на ролике в ВТ
* N_hdr_w1 = N_hdr_w + N_tr_i + N_tr_o + N_tr_sep;


if (priz_pechat1 == 1)
{
	// Установлен признак выдачи на экран результатов рассчета 	

	// Определить тянущий момент действующий на ролик
	Mom_rol_t = Rw * (F_tr_i - F_tr_o);

	// Определить зазор в мм для ролика
	Megkolech_zazor_mm = Rnk - Rvk - DR*cos(2*pi*nom_rolik/Z) + *(F1X+nom_rolik) + P/2;
	if (Megkolech_zazor_mm < Dw) 
	{
		C_fi = 0;
	}
	else
	{
		C_fi = Megkolech_zazor_mm - Dw;
	}

	// Определить угловую  координату текущего ролика 
	fi = 2 * pi * (double) nom_rolik / ((double) Z);

	// Печать строки по силам действующим на ролик, перемычку сепаратора, потери мощности на ролике
	fprintf(f2,"\n  | %6.3f |%10.3f| %11.3f | %11.3f | %12.3f | %12.3f | %8.5f | %8.3f | %8.3f | %13.5f | %10.3f | %10.3f |%10.3f | %13.3f | %10.3f  |", fi, W_rol, F_tr_i, F_tr_o, *(Dop_usil_sep + nom_rolik), * F_rol_sep1, C_fi, Mom_rol_t, T_mom, Nev, N_tr_i, N_tr_o, N_tr_sep, N_hdr_w,* N_hdr_w1);	
}



// Выход из подпрограммы с возвратом суммарного момента действующего на ролик
return Nev;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////		ПОДПРОГРАММА ОПРЕДЕЛЕНИЯ СУММАРНОГО ПРИРАЩЕНИЯ УГЛОВЫХ СКОРОСТЕЙ ВСЕХ РОЛИКОВ	/////////
//
//		Входные параметры :		DR		- Сближение в мм осей внутреннего и наружного кольца из за действия нагрузки.
//	    						W_sep	- Угловая скорость в радианах/сек сепаратора.
//								T_w		- Рабочая температура ролика в градусах Цельсия
//`								T_vk	- Рабочая температура внутреннего кольца  в градусах Цельсия
//								T_nk	- Рабочая температура наружного кольца  в градусах Цельсия
//								W_rol	- Угловуая скорость ролика в радиана/секунда
//
//	Возвращаемое значение :		sum_dw	- Суммарное приращение угловых скоростей всех роликов
//
//


double Sum_dw_rol( double DR, double W_sep, double T_w, double T_vk, double T_nk, double W_rol )
{

double dfi;			// Шаг изменения угла поворота ролика в радианах
double dt;			// Временной шаг соответствующий шагу изменения угла поворота
double dw_rol;			// Приращение угловой скорости ролика 
double sum_dw_rol;		// Суммарное приращение угловых скоростей всех роликов
double F_rol_sep2;		// Сила действующая на перемычку сепаратора в кг
double F_tr_rol_sep2;		// Сила трения в контакте вращающегося ролика с перемычкой сепаратора в кг
double S_mom_rol;		// Суммарный момент сил действующих на ролик
double N_hdr_w;			// Потеря мощности на преодоление гидромеханического сопротивления ролика в ваттах
int n_rol;			// Номер ролика, счетчик цикла роликов

// Задать шаг изменения угла поворота ролика в радианах
dfi = 2*pi/((double) Z);

// Определить временной шаг соответствующий шагу изменения угла поворота
dt = dfi / W_sep;

// Обнулить суммарное приращение скоростей всех роликов
sum_dw_rol = 0;

// Перебор в цикле всех роликов и определение суммарного приращения угловых скоростей всех роликов
for (n_rol = 0; n_rol < Z; n_rol++)
{
	// Определить суммарный момент сил действующий на ролик и силу действующую со стороны ролика на перемычку сепаратора и 
	// Выдать в отчет угл.скорость, силу трения с дорожками ВК и НК, силу на сепаратор, тянущий и тормозящий момент наролик, невязку уравнения моментов.
	S_mom_rol = Nev_mom_rol( DR, *(F1X+n_rol), *(F2X+n_rol), W_sep, T_w, T_vk, T_nk, W_rol, n_rol, &F_rol_sep2, 0, 0, &N_hdr_w,	&F_tr_rol_sep2);

	// Определить приращение угловой скорости ролика из уравнения равновесия моментов действующих на ролик
	dw_rol = S_mom_rol * dt / Jw;

	// Определить угловую скорость ролика в следующей угловой координате
	W_rol += dw_rol;

	// Нарастить суммарное приращение скоростей всех роликов
	sum_dw_rol += dw_rol;
}


// Выход из подпрограммы с возвратом найденного суммарного приращения угловых скоростей роликов
return sum_dw_rol; 

}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////		ПОДПРОГРАММА ОПРЕДЕЛЕНИЯ УГЛОВОЙ СКОРОСТИ ВРАЩЕНИЯ ВСЕХ РОЛИКОВ		/////////////////////
///////////////		ВОКРУГ СВОЕЙ ОСИ ВО ВРЕМЯ ДВИЖЕНИЯ ПО КРУГОВОЙ ОРБИТЕ			/////////////////////
//////////////		В ГНЕЗДЕ СЕПАРАТОРА							/////////////////////
///
///
///	    Входные параметры :				  DR - Сближение в мм осей внутреннего и наружного кольца из за действия нагрузки.
///	    					       W_sep - Угловая скорость в радианах/сек сепаратора.
///							 T_w - Рабочая температура ролика в градусах Цельсия
///							T_vk - Рабочая температура внутреннего кольца  в градусах Цельсия
///							T_nk - Рабочая температура наружного кольца  в градусах Цельсия
///						   priz_pech - Признак выдачи в отчет промежуточных результатов 
///
///	   Выходные параметры :		    F_rol_sep[]  - Глобальный массив сил действующих со стороны роликов на перемычку сепаратора
///					  * Sum_N_hdr_w1 - Суммарная потеря мощности на преодоление гидромеханического сопротивления всех роликов в ваттах
///


void w_rolik( double DR, double W_sep, double T_w, double T_vk, double T_nk, int priz_pech, double * Sum_N_hdr_w1)
{

double dfi;			// Шаг изменения угла поворота ролика в радианах
double dt;			// Временной шаг соответствующий шагу изменения угла поворота
double dw_rol;			// Приращение угловой скорости ролика 

double W_rol;			// Угловая скорость ролика при вращении вокруг своей оси
double W_rol_1;			// Угловая скорость ролика при вращении вокруг своей оси ченная после шагания по методу Ньютона-Рафсона

double t;			// Время
double eps1;			// Малое значение определяющее точность решения уравнения равновесия моментов действующих на ролик

double sum_dw_rol;		// Суммарное приращение угловых скоростей всех роликов
double F_rol_sep1;		// Сила действующая на перемычку сепаратора в кг
double F_tr_rol_sep1;		// Сила трения в контакте вращающегося ролика с перемычкой сепаратора в кг

double Nev_0;			// Невязка уравнения равновесия моментов действующих на ролик для скорости № 0
double Nev_plus_1;		// Невязка уравнения равновесия моментов действующих на ролик для скорости № +1
double Sum_mom_rol;		// Суммарный момент сил действующий на ролик

double Sum_N_hdr_w;		// Суммарные потери мощности на преодоление гидромеханического сопротивления всех роликов в ваттах
double N_hdr_w;			// Потеря мощности на преодоление гидромеханического сопротивления ролика в ваттах

int nom_it;			// Счетчик итераций
int n_rol;			// Номер ролика, счетчик цикла роликов

int	priz_pech1;		// Признак печати таблицы сил действующих на ролик
int	priz_pech2;		// Признак печати таблицы касательных напряжений в контакте ролика с дорожкой качения кольца



 // Задать малое значение определяющее точность решения уравнения равновесия моментов сил действующих на ролик
//eps1 = 0.00005;
eps1 = 0.00002;

 // Задать начальное приближение угловой скорости ролика в радианах/сек
W_rol = -0.5*W_w_epicikl;


 // Если угловая скорость ролика близка к 0 тогда установить ее равной 0.01 радиан/сек
if (fabs(W_rol) < 0.01) W_rol = 0.01;

 // Задать начальное значение счетчика итераций
nom_it = 1;


// Итерационный цикл в котором идет шагание с помощью метода Ньютона-Рафсона 
// так чтобы найти такую скорость роликов чтобы суммарное ускорение всех роликов было близко к 0.
//  
while(1)
{
	 // Задать приращение угловой скорости ролика
	dw_rol = fabs(W_rol)/100;
	
	 // Получить невязку в точке 0
	Nev_0 = Sum_dw_rol( DR, W_sep, T_w, T_vk, T_nk, W_rol );
	if (fabs(Nev_0) < eps1) 
	{
		 // Невязка в точке 0 меньше заданной точности. Выход из итерационного цикла.
		break;
	}

	 // Получить невязку в точке +1
	Nev_plus_1 = Sum_dw_rol( DR, W_sep, T_w, T_vk, T_nk, W_rol+dw_rol );
	if (fabs(Nev_plus_1) < eps1)
	{
		 // Невязка в точке +1 меньше заданной точности. Выход из итерационного цикла.
		W_rol += dw_rol;
		break;
	}

	 // Шаг по методу Ньютона-Рафсона и получение следующего значения угловой скорости ролика
	W_rol_1 = W_rol - 0.2*Nev_0/((Nev_plus_1-Nev_0)/dw_rol);

	// Выдать в отчет новое значение угл.скорости ролика
	//fprintf(f2,"\n  Новое значение угл.скорости ролика = %17.8f  | ", W_rol_1 );	

	 // Нарастить счетчик итераций
	nom_it++;

	 // Считать текущим следующее значение скорости ролика
	W_rol = W_rol_1;
}

 // Задать шаг изменения угла поворота ролика в радианах
dfi = 2*pi/((double) Z);

 // Определить временной шаг соответствующий шагу изменения угла поворота
dt = dfi / W_sep;

 // Задать начальное значение момента времени в сек
t = 0.0;

 // Выдача в отчет таблицы сил действующих на ролик и распределения касательных напряжений в контакте ролика с дорожками качения колец.
for (nom_it = 0; nom_it < 2; nom_it++ )
{
	if (priz_pech == 1)
	{
		if (nom_it == 0)
		{
			priz_pech1 = 1;
			priz_pech2 = 0;
		}
		else
		{
			priz_pech1 = 0;
			priz_pech2 = 1;
		}
	}
	else
	{
		priz_pech1 = 0;
		priz_pech2 = 0;
	}

	if (priz_pech1 == 1)
	{
		// Выдать в отчет шапку таблицы сил действующих на ролик
		fprintf(f2,"\n\n  ");
		fprintf(f2,"\n  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ");	
		fprintf(f2,"\n  |        | Угловая  | Сила трения | Сила трения |   Сила по    | Сила давления|  Зазор   | Тянущий  |Тормозящий| Невязка урав- |  Потеря    |  Потеря    |  Потеря   |Потеря мощности|Полная потеря|  Угловое    | ");		
		fprintf(f2,"\n  | Угол   | скорость | в контакте  | в контакте  | втаскиванию  | в контакте   | ролик-ВК |момент на |момент на | нения моментов| мощности в | мощности в | мощности в| из за трения  |мощности на  | ускорение   | ");		
		fprintf(f2,"\n  |   в    | ролика в | ролика с ВК | ролика с НК |   ролика     |   ролика     |          |  ролик   |  ролик   |  действующих  |  контакте  |  контакте  | контакте  |ролика о масло-|  ролике     |  ролика     | ");		
		fprintf(f2,"\n  |        |          |             |             |   в клин     |с перемычкой  |          |          |          |   на ролик    |  ролик-ВК  |  ролик-НК  | ролик-сеп.|воздушную смесь|             |             | ");		
		fprintf(f2,"\n  |        |          |             |             |              | сепаратора   |          |          |          |               |            |            |           |               |             |             | ");		
		fprintf(f2,"\n  |        |          |             |             |              |              |          |          |          |               |            |            |           |               |             |             | ");		
		fprintf(f2,"\n  |радианах|радиан/сек|     в кг    |    в кг     |    в кг.     |    в кг      |  в мм.   | в кг*мм  | в кг*мм  |    в кг*мм    |    в вт.   |   в вт.    |    в вт.  |      в вт.    |   в вт.     | в рад./сек2 | ");		
		fprintf(f2,"\n  +--------+----------+-------------+-------------+--------------+--------------+----------+----------+----------+---------------+------------+------------+-----------+---------------+-------------+-------------+ ");	
	}

	// Обнулить суммарное приращение скоростей всех роликов
	sum_dw_rol = 0;

	// Обнулить суммарные потери мощности на преодоление гидромеханического сопротивления всех роликов в ваттах
	Sum_N_hdr_w = 0;

	// Перебор в цикле всех роликов 
	for (n_rol = 0; n_rol < Z; n_rol++)
	{
		// Определить суммарный момент сил действующий на ролик, силу действующую со стороны ролика на перемычку сепаратора
		// и потери мощности на преодоление гидромеханического сопротивления этого ролика.
		Sum_mom_rol = Nev_mom_rol( DR, *(F1X+n_rol), *(F2X+n_rol), W_sep, T_w, T_vk, T_nk, W_rol, n_rol, &F_rol_sep1, priz_pech1, priz_pech2, &N_hdr_w, &F_tr_rol_sep1 );

		// Записатиь в массив найденную силу действующую со стороны ролика на перемычку сепаратора в кг.
		*(F_rol_sep + n_rol) = F_rol_sep1;

		// Записать в массив найденную силу трения в контакте вращающегося ролика с перемычкой сепаратора в кг.
		*(F_tr_rol_sep + n_rol) = F_tr_rol_sep1;

		// Определить приращение угловой скорости ролика из уравнения равновесия моментов действующих на ролик
		dw_rol = Sum_mom_rol * dt / Jw;

		if (priz_pech1 == 1)
		{
			// Выдать в отчет приращение угловой скорости ролика
			fprintf(f2,"%12.6f |",dw_rol);	
		}

		// Перейти к следующему моменту времени
		t += dt;		

		// Определить угловую скорость ролика в следующей угловой координате
		W_rol += dw_rol;

		// Нарастить суммарное приращение скоростей всех роликов
		sum_dw_rol += dw_rol;

		// Нарастить суммарные потери мощности на преодоления гидромеханического сопротивления всех роликов 
		Sum_N_hdr_w += N_hdr_w;
	}

	if (priz_pech1 == 1)
	{
		// Выдать в отчет конец таблицы и выполнить перевод строки
		fprintf(f2,"\n  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------");	
		fprintf(f2,"\n\n ");	
	}
}

// Записать в выходной параметр суммарные потери мощности на преодоление гидромеханического сопротивления всех роликов в ваттах.
* Sum_N_hdr_w1 = Sum_N_hdr_w;



 // Завершение работы подпрограммы
return;

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////		ПОДПРОГРАММА ОПРЕДЕЛЕНИЯ ТОРМОЗЯЩЕГО МОМЕНТА ОТ СИЛ ЖИДКОСТНОГО ТРЕНИЯ ДЕЙСТВУЮЩЕГО НА СЕПАРАТОР	//////////
///////		И ПОТЕРЮ МОЩНОСТИ НА ПЕРЕМЕШИВАНИЯ СМАЗКИ								//////////
///
///	Входные параметры :		       W_sep - Угловая скорость сепаратора в РАДИАНАХ/СЕКУНДУ	
///
///	Выходные параметры : 		* N_hdr_sep1 - Потеря мощности на преодоление гидромеханического сопротивления сепаратора в ВАТТАХ
///
///	Возвращаемое значение :		      TM_sep - Тормозящий момент действующий на сепаратор в КИЛОГРАММАХ*МИЛЛИМЕТРЫ
///
///	Примечание :	Если тормозящий момент действующий на сепаратор получился со знаком минус, это означает на самом деле то
///			что на сепаратор через слой смазки действуют толкающий момент со стороны внутреннего кольца, и он больше 
///			по модулю чем тормозящие моменты действующие со стороны наружной и боковой поверхности сепаратора
///			Это бывает когда очень высокая доля смазки в масловоздушной смеси, или слишком малый зазор между
///			внутренней цилиндрической поверхностью сепаратора и внутреннем кольцом.
///

double Trmz_mom_sep( double W_sep,  double * N_hdr_sep1 )
{

double Okno_sep_H1_m;	// Ширина окна сепаратора в МЕТРАХ.
double Okno_sep_H2_m;	// Длина окна сепаратора в МЕТРАХ.

double Rnk_m;		// Радиус дорожки качения наружного кольца в МЕТРАХ.
double Rvk_m;		// Радиус дорожки качения внутреннего кольца в МЕТРАХ.

double Rco_m;		// Радиус наружной цилиндрической поверхности сепаратора в МЕТРАХ.
double Rci_m;		// Радиус внутренней цилиндрической поверхности сепаратора в МЕТРАХ.

double Dc_m;		// Диаметр поверхности на дорожке качения кольца (наружного или внутреннего)  которая центрирует сепаратор в МЕТРАХ.
double Dcb_m;		// Диаметр центрирующей поверхности сепаратора (поясков) в МЕТРАХ с учетом распухания от действия центробежной силы м температурного расширения

double Rc_m;		// Радиус поверхности на дорожке качения кольца (наружного или внутреннего)  которая центрирует сепаратор в МЕТРАХ.
double Rcb_m;		// Радиус центрирующей поверхности сепаратора (поясков) в МЕТРАХ с учетом распухания от действия центробежной силы м температурного расширения

double Lc_m;		// Ширина сепаратора в МЕТРАХ.
double Lcb_m;		// Ширина центрирующих поясков сепаратора в МЕТРАХ.

double W_O;		// Угловая скорость сепаратора относительно наружного кольца в РАДИАН/СЕКУНДУ
double abs_W_O;		// Угловая скорость сепаратора относительно наружного кольца в РАДИАН/СЕКУНДУ взятая по абсолютной величине

double W_I;		// Угловая скорость сепаратора относительно внутреннего кольца в РАДИАН/СЕКУНДУ
double abs_W_I;		// Угловая скорость сепаратора относительно внутреннего кольца в РАДИАН/СЕКУНДУ взятая по абсолютной величине

double Zazor_nk_sep_m;	// Зазор между дорожкой качения наружного кольца и наружной цилиндрической поверхностью сепаратора в МЕТРАХ.
double Zazor_vk_sep_m;	// Зазор между дорожкой качения внутреннго кольца и внутренней цилиндрической поверхностью сепаратора в МЕТРАХ.

double Vyaz_din_kg_s_mm2;// Динамическая вязкость смазки в КИЛОГРАММ*СЕКУНДА/МИЛИМЕТР2
double Vyaz_din_pa_s;	 // Динамическая вязкость смазки в ПАСКАЛЬ*СЕКУНДА
double RO_smes_sep_kg_m3;// Плотность масловоздушной смеси для сепаратора в КИЛОГРАММ/МЕТР3	
double Vyaz_kin_m2_s;	 // Кинематическая вязкость масловоздушной смеси для сепаратора в МЕТР2/СЕКУНДА	

double RE;		 // Число Рейнольдса для масловозхдушной смеси в зазоре между сепраратором и дорожклй качения 
double Ftr;		 // Коэффициент трения  для масловозхдушной смеси в зазоре между сепраратором и дорожклй качения 
double Cn;		 // Коэффициент режима обтекания боковых поверхностей сепаратора

double Re_p;		// Число Рейнольдса для масловоздушной смеси в зазоре между центрирующими поясками и центрирующей поверхностью кольца
double Ftr_p;		// Коэффициент трения для масловоздушной смеси в зазоре между центрирующими поясками и центрирующей поверхностью кольца

int znak;		// Знак тормозящего момента

double TM_nar_sep;	// Тормозящий момент действующий на наружную цилиндрическую поверхность сепаратора в НЬЮТОН*МЕТР
double TM_vnut_sep;	// Тормозящий момент действующий на внутреннюю цилиндрическую поверхность сепаратора в НЬЮТОН*МЕТР
double TM_bok_sep;	// Тормозящий момент действующий на боковые поверхности сепаратора  в НЬЮТОН*МЕТР
double TM_poyaski_sep1;	// Тормозящий момент действующий на действующий на центрирующие пояски сепаратора из за их трения о поверхность центрирования кольца в НЬЮТОН*МЕТР
double TM_poyaski_sep2;	// Тормозящий момент действующий на действующий на центрирующие пояски сепаратора из за их трения о масловоздушную смесь в НЬЮТОН*МЕТР
double TM_poyaski_sep;	// Итоговый тормозящий момент действующий на действующий на центрирующие пояски сепаратора в НЬЮТОН*МЕТР
double TM_sep;		// Тормозящий момент действующий на сепаратор в НЬЮТОН*МЕТР

double F_sep_poyaski_x_kg;	// Проекция на ось OX усилия в контакте поясков сепаратора и центрирующей поверхности кольца в КИЛОГРАММАХ.
double F_sep_poyaski_y_kg;	// Проекция на ось OY усилия в контакте поясков сепаратора и центрирующей поверхности кольца в КИЛОГРАММАХ.
double F_sep_poyaski_kg;	// Усилие в контакте поясков сепаратора и центрирующей поверхности кольца в КИЛОГРАММАХ

int n_rol;			// Счётчик роликов

double ksi;			// Относительный эксцентриситет сепаратора
double ksi1;			// Относительный эксцентриситет сепаратора ( вспомогательная переменная используемая в итерационном цикле )
double ksi2;			// Относительный эксцентриситет сепаратора ( вспомогательная переменная используемая в итерационном цикле )
double ksi1_;			// Следующее приближение относительного эксцентриситета сепаратора
double ksi_nach;		// Начальное значение эксцекнтриситета сепаратора


double fi;			// Угол нагрузки в РАДИАНАХ
double SC_m;			// Средняя величина зазора между центрирующими поясками сепаратора и центрирующей поверхностью кольца  в МЕТРАХ  
double Rad_nagr_sep_n;		// Радиальная нагрузка на сепаратор в НЬЮТОНАХ

double Rc1_kg;			// Усилие в КИЛОГРАММАХ в контакте центрирующих поверхностей кольца и сепаратора вычисленное при помощи относительного эксцентриситета ( вспомогательная переменная используемая в итерационном цикле )
double Rc2_kg;			// Усилие в КИЛОГРАММАХ в контакте центрирующих поверхностей кольца и сепаратора вычисленное при помощи относительного эксцентриситета( вспомогательная переменная используемая в итерационном цикле )

double nev1;			// Ошибка в вычислении усилия в контакте центрирующих поверхностей кольца и сепаратора ( вспомогательная переменная используемая в итерационном цикле )
double nev2;			// Ошибка в вычислении усилия в контакте центрирующих поверхностей кольца и сепаратора ( вспомогательная переменная используемая в итерационном цикле )

double N_nar_sep;		// Потери мощности в ВТ на наружной цилиндрической поверхности сепаратора.
double N_vnut_sep;		// Потери мощности в ВТ на внутренней цилиндрической поверхности сепаратора
double N_bok_sep;		// Потери мощности в ВТ на боковой поверхности сепаратора
double N_poyaski_sep1;		// Потеря мощности в ВТ на центрирующих поясках сепаратора из за их трения о поверхность центрирования кольца.
double N_poyaski_sep2;		// Потеря мощности в ВТ на центрирующих поясках сепаратора из за их трения о масловоздушную смесь
double N_poyaski_sep;		// Итоговая потеря мощности в ВТ на центрирующих поясках сепаратора

double Pezo_koeff_1;


 // Определить знак на который будет умножаться найденный тормозящий момент
if (W_sep > 0) znak=-1;  else znak=1;

 // Взять угловую скорость сепаратора по абсолютной величине
W_sep = fabs(W_sep);	


if (W_sep > 0.0) 
{
	// Сепаратор вращается
	
	Okno_sep_H1_m = Okno_sep_H1/1000;	// Получить ширину окна сепаратора в МЕТРАХ.
	Okno_sep_H2_m = Okno_sep_H2/1000;	// Получить длину окна сепаратора в МЕТРАХ

	Rnk_m	  = Rnk/1000;			// Получить радиус дорожки качения наружного кольца в МЕТРАХ.	
	Rvk_m	  = Rvk/1000;			// Получить радиус дорожки качения внутреннего кольца в МЕТРАХ.
	
	Rco_m	  = Rco/1000;			// Получить радиус наружной цилиндрической поверхности сепаратора в МЕТРАХ
	Rci_m	  = Rci/1000;			// Получить радиус внутренней цилиндрической поверхности сепаратора в МЕТРАХ.
	
	Dc_m	  = Dc/1000;			// Диаметр поверхности на дорожке качения кольца (наружного или внутреннего)  которая центрирует сепаратор в МЕТРАХ.
	Dcb_m	  = Dcb/1000;			// Диаметр центрирующей поверхности сепаратора (поясков) в метрах с учетом распухания от действия центробежной силы м температурного расширения
	Lc_m	  = Lc/1000;			// Ширина сепаратора в МЕТРАХ.
	Lcb_m	  = Lcb/1000;			// Ширина центрирующих поясков сепаратора в МЕТРАХ.

	Rc_m	  = Dc_m/2;			// Радиус поверхности на дорожке качения кольца (наружного или внутреннего)  которая центрирует сепаратор в МЕТРАХ.
	Rcb_m	  = Dcb_m/2;			// Радиус центрирующей поверхности сепаратора (поясков) в МЕТРАХ с учетом распухания от действия центробежной силы м температурного расширения

	RO_smes_sep_kg_m3 = RO1_smes_sep * 1000000000;				// Получить плотность масловоздушной смеси для сепаратора в КИЛОГРАММ/МЕТР3	
	Vyaz_din_kg_s_mm2 = Vyaz_Rolands(Patm, T_nk+273, &Pezo_koeff_1 );	// Получить динамическую вязкость смазки для наружной цилиндрической поверхности сепаратора в КИЛОГРАММ*СЕКУНДА/МИЛЛИМЕТР2  по формуле Роландса 
	Vyaz_din_pa_s = Vyaz_din_kg_s_mm2 * 1000000 * 9.8;			// Получить динамическую вязкость смазки для наружной цилиндрической поверхности сепаратора в ПАСКАЛЬ*СЕКУНДА
	Vyaz_kin_m2_s = Vyaz_din_pa_s/RO_smes_sep_kg_m3;			// Получить кинематическую вязкость масловоздушной смеси для наружной цилиндрической поверхности сепаратора  в МЕТР2/СЕКУНДА

	// Определить тормозящий момент в НЬЮТОН*МЕТР действующий на наружную цилиндрическую поверхность сепаратора
	//
	W_O	= W_sep-W_nk;					// Получить угловую скорость сепаратора относительно наружного кольца в РАДИАН/СЕКУНДА
	abs_W_O	= fabs(W_O);					// Получить угловую скорость сепаратора относительно наружного кольца в РАДИАН/СЕКУНДА взятую по абсолютной величине
	Zazor_nk_sep_m	= Rnk_m - Rco_m;			// Получить зазор между дорожкой качения наружного кольца и наружной цилиндрической поверхностью сепаратора в МЕТРАХ.
	RE = Rco_m * abs_W_O * Zazor_nk_sep_m / Vyaz_kin_m2_s;	// Получить число Рейнольдса для масловоздушной смеси в зазоре между сепаратором и дорожкой качения наружного кольца

	if (RE >= 2500) 
	{
		 // Получить коэффициент трения для турбулентного течения Куэтта ( дисс.Акифьева стр.61 ф-ла 47 )
		Ftr = 3.0 * 16.0 / RE * step(RE/2500.0 , 0.85596);	
	}
	else
	{
		 // Получить коэффициент трения для ламинарного режима ( дисс.Акифьева стр.61 ф-ла 50 )
		Ftr = 16.0 / RE;
	}

	if (Dc_m < Dcb_m)
	{
		 //   Диаметр поверхности центрирования сепаратора ( на дорожке качения кольца)  меньше диаметра центрирующей поверхности сепаратора ( на сепараторе).
		 //   В подшипнике центрирование сепаратора идет по внутреннему кольцу.  
		 //   Центрирующие поверхности расположены на внутренней поверхности сепаратора.
		 //   (на основе дисс. Акифьева стр.71 ф-ла 80)	
		 //	
		 //	  Определить тормозящий момент в Н*М действующий на наружную цилиндрическую поверхность сепаратора	
		 //	
		TM_nar_sep = abs_W_O/W_O * Ftr * RO_smes_sep_kg_m3 * (Rco_m*Rco_m*Rco_m) * (W_O*W_O) * (2*pi*Rco_m*Lc_m - Okno_sep_H1_m*Okno_sep_H2_m*Z);
	}
	else
	{
		 //  В подшипнике центрирование сепаратора идет по наружному кольцу.  
		 //  Центрирующие пояски расположены на наружной поверхности сепаратора 
		 //  (на основе дисс. Акифьева стр.71 ф-ла 80)	
		 //
		 //	 Определить тормозящий момент в Н*М действующий на наружную цилиндрическую поверхность сепаратора	
		 //	
		TM_nar_sep = abs_W_O/W_O * Ftr * RO_smes_sep_kg_m3 * (Rco_m*Rco_m*Rco_m) * (W_O*W_O) * (2*pi*Rco_m*(Lc_m-Lcb_m)- Okno_sep_H1_m*Okno_sep_H2_m*Z);
	}
	
	// Определить потери мощности в ВТ на наружной цилиндрической поверхности сепаратора
	N_nar_sep = fabs(W_O * TM_nar_sep);


	// Определить тормозящий момент в Н*м действующий на внутреннюю цилиндрическую поверхность сепаратора
	// 
	W_I	= W_sep-W_vk;			// Получить угловую скорость сепаратора относительно внутреннего кольца в РАДИАН/СЕКУНДА
	abs_W_I = fabs(W_I);			// Получить угловую скорость сепаратора относительно внутреннего кольца в РАДИАН/СЕКУНДА взятую  по абсолютной величине 
	Zazor_vk_sep_m = Rci_m - Rvk_m;		// Получить зазор между дорожкой качения внутреннего кольца и внутренней цилиндрической поверхностью сепаратора в МЕТРАХ.

	Vyaz_din_kg_s_mm2 = Vyaz_Rolands(Patm, T_vk+273, &Pezo_koeff_1);	// Получить динамическую вязкость смазки для внутренней цилиндрической поверхности сепаратора в КИЛОГРАММ*СЕКУНДА/МИЛЛИМЕТР2  по формуле Роландса 
	Vyaz_din_pa_s = Vyaz_din_kg_s_mm2 * 1000000 * 9.8;			// Получить динамическую вязкость смазки для внутренней цилиндрической поверхности сепаратора в ПАСКАЛЬ*СЕКУНДА
	Vyaz_kin_m2_s = Vyaz_din_pa_s/RO_smes_sep_kg_m3;			// Получить кинематическую вязкость масловоздушной смеси для внутренней цилиндрической поверхности сепаратора  в МЕТР2/СЕКУНДА
	RE = Rci_m * abs_W_I * Zazor_vk_sep_m / Vyaz_kin_m2_s;			// Получить число Рейнольдса для масловоздушной смеси в зазоре между сепаратором и дорожкой качения внутреннего кольца ( дисс.Акифьева стр.61 ф-ла 48 )

	if (RE >= 2500) 
	{
		 // Получить коэффициент трения для турбулентного течения Куэтта ( дисс.Акифьева стр.61 ф-ла 47 )
		Ftr = 3.0 * 16.0 / RE * step(RE/2500.0 , 0.85596);	
	}
	else
	{
		 // Получить коэффициент трения для ламинарного режима ( дисс.Акифьева стр.61 ф-ла 50 )
		Ftr = 16.0 / RE;
	}

	if (Dc_m < Dcb_m)
	{
		 //   Диаметр поверхности центрирования сепаратора ( на дорожке качения кольца)  меньше диаметра центрирующей поверхности сепаратора ( на сепараторе).
		 //   В подшипнике центрирование сепаратора идет по внутреннему кольцу.  
		 //   Центрирующие поверхности расположены на внутренней поверхности сепаратора.
		 //   (на основе дисс. Акифьева стр.71 ф-ла 81)	
		 //	
		 //   Определить тормозящий момент в Н*М действующий на внутреннюю цилиндрическую поверхность сепаратора	
		 //	
		TM_vnut_sep = abs_W_I/W_I * Ftr * RO_smes_sep_kg_m3 * (Rci_m*Rci_m*Rci_m) * (W_I*W_I) * (2*pi*Rci_m*(Lc_m-Lcb_m) - Okno_sep_H1_m*Okno_sep_H2_m*Z);
	}
	else
	{
		 //  В подшипнике центрирование сепаратора идет по наружному кольцу.  
		 //  Центрирующие пояски расположены на наружной поверхности сепаратора 
		 //  (на основе дисс. Акифьева стр.71 ф-ла 81)	
		 //
		 //  Определить тормозящий момент в Н*М действующий на внутреннюю цилиндрическую поверхность сепаратора	
		 //	
		TM_vnut_sep = abs_W_I/W_I * Ftr * RO_smes_sep_kg_m3 * (Rci_m*Rci_m*Rci_m) * (W_I*W_I) * (2*pi*Rci_m*Lc_m - Okno_sep_H1_m*Okno_sep_H2_m*Z);
	}

	// Определить потери мощности в ВТ на внутренней цилиндрической поверхности сепаратора
	N_vnut_sep = fabs(W_I * TM_vnut_sep);


	// Определить тормозящий момент в НЬЮТОН*МЕТР действующий на боковые поверхности сепаратора
	Vyaz_din_kg_s_mm2 = Vyaz_Rolands(Patm, T_maslo_vh+273, &Pezo_koeff_1 );		// Получить динамическую вязкость смазки для боковых поверхностей сепаратора в КИЛОГРАММ*СЕКУНДА/МИЛЛИМЕТР2  по формуле Роландса 
	Vyaz_din_pa_s = Vyaz_din_kg_s_mm2 * 1000000 * 9.8;				// Получить динамическую вязкость смазки для боковых поверхностей сепаратора в ПАСКАЛЬ*СЕКУНДА
	Vyaz_kin_m2_s = Vyaz_din_pa_s/RO_smes_sep_kg_m3;				// Получить кинематическую вязкость масловоздушной смеси для боковых поверхностей сепаратора  в МЕТР2/СЕКУНДА

	if (Dc_m < Dcb_m)
	{
		 //   Диаметр поверхности центрирования сепаратора ( на дорожке качения кольца)  меньше диаметра центрирующей поверхности сепаратора ( на сепараторе).
		 //   В подшипнике центрирование сепаратора идет по внутреннему кольцу.  
		 //   Центрирующие поверхности расположены на внутренней поверхности сепаратора.
		 //	  Получить число Рейнольдса (на основе дисс.Акифьева стр.62  ф-ла 54).
		 //	
		RE = Rco_m*Rco_m * W_sep / Vyaz_kin_m2_s;	
	}
	else
	{
		 //  В подшипнике центрирование сепаратора идет по наружному кольцу.  
		 //  Центрирующие пояски расположены на наружной поверхности сепаратора 
		 //  Получить число Рейнольдса (на основе дисс.Акифьева стр.62  ф-ла 54).
		 //
		RE = (Dcb_m*Dcb_m/4) * W_sep / Vyaz_kin_m2_s;
	}

	if ( RE > 300000 )
	{
		// Вычисление коэффициента "Cn" для турбулентного режима обтекания (дисс.Акифьева стр.62 ф-ла 53)
		Cn = 0.146 * step(RE,-0.2);
	}
	else
	{
		// Вычисление коэффициента "Cn" для ламинарного режима обтекания (дисс.Акифьева стр.62 ф-ла 52)
		Cn = 3.87 * step(RE,-0.5);
	}

	if (Dc_m < Dcb_m)
	{
		 //   Диаметр поверхности центрирования сепаратора ( на дорожке качения кольца)  меньше диаметра центрирующей поверхности сепаратора ( на сепараторе).
		 //   В подшипнике центрирование сепаратора идет по внутреннему кольцу.  
		 //   Центрирующие поверхности расположены на внутренней поверхности сепаратора.
		 //   (на основе дисс.Акифьева стр.71 ф-ла 82)	
		 //
		 //   Определить тормозящий момент в Н*М действующий на боковые поверхности сепаратора	
		 //
		TM_bok_sep = RO_smes_sep_kg_m3 * (W_sep*W_sep) * (Rco_m*Rco_m*Rco_m) * ((Rco_m*Rco_m)-(Dcb_m*Dcb_m/4)) * Cn * 0.5;
	}
	else
	{
		 //  В подшипнике центрирование сепаратора идет по наружному кольцу.  
		 //  Центрирующие пояски расположены на наружной поверхности сепаратора. 
		 //  (на основе дисс.Акифьева стр.71 ф-ла 82)	
		 //
		 //  Определить тормозящий момент в Н*М действующий на боковые поверхности сепаратора	
		 //
		TM_bok_sep = RO_smes_sep_kg_m3 * (W_sep*W_sep) * (Dcb_m*Dcb_m*Dcb_m/8) * ((Dcb_m*Dcb_m/4)-(Rci_m*Rci_m)) * Cn * 0.5;
	}

	// Определить потери мощности в ВТ на боковых поверхностях сепаратора  ??????????????
	N_bok_sep = fabs(TM_bok_sep * W_sep);

	if (Lcb_m > 0) 
	{
		// У сепаратора есть центрирующие пояски 

		// Определить тормозящий момент в НЬЮТОН*МЕТР действующий на центрирующие пояски сепаратора

		// Определить усилие в контакте поясков сепаратора и центрирующей поверхности кольца в КГ. Здесь ось 0Y направлена вниз.
		F_sep_poyaski_x_kg = 0;
		F_sep_poyaski_y_kg = M_sep_kg;

		for (n_rol=0; n_rol<Z; n_rol++)
		{	
			F_sep_poyaski_x_kg = F_sep_poyaski_x_kg + *(F_rol_sep+n_rol)*cos(2*pi/Z*n_rol) - *(F_tr_rol_sep + n_rol)*sin(2*pi/Z*n_rol);
			F_sep_poyaski_y_kg = F_sep_poyaski_y_kg - *(F_rol_sep+n_rol)*sin(2*pi/Z*n_rol) - *(F_tr_rol_sep + n_rol)*cos(2*pi/Z*n_rol);
		}

		F_sep_poyaski_kg = sqrt(F_sep_poyaski_x_kg*F_sep_poyaski_x_kg + F_sep_poyaski_y_kg*F_sep_poyaski_y_kg);

		// Определить усилие в контакте поясков сепаратора и центрирующей поверхности кольца в НЬЮТОНАХ  
		Rad_nagr_sep_n = F_sep_poyaski_kg * 9.8;

		if (Dc_m < Dcb_m)
		{
			//   Диаметр поверхности центрирования сепаратора (на дорожке качения кольца)  меньше диаметра центрирующих поясков сепаратора (на сепараторе).
			//   В подшипнике центрирование сепаратора идет по внутреннему кольцу.  
			//   Центрирующие пояски расположены на внутренней поверхности сепаратора.
			Vyaz_din_kg_s_mm2 = Vyaz_Rolands(Patm, T_vk+273, &Pezo_koeff_1);	// Получить динамическую вязкость смазки для внутренней цилиндрической поверхности сепаратора в КИЛОГРАММ*СЕКУНДА/МИЛЛИМЕТР2  по формуле Роландса 
			Vyaz_din_pa_s = Vyaz_din_kg_s_mm2 * 1000000 * 9.8;			// Получить динамическую вязкость смазки для внутренней цилиндрической поверхности сепаратора в ПАСКАЛЬ*СЕКУНДА
			Vyaz_kin_m2_s = Vyaz_din_pa_s/RO_smes_sep_kg_m3;			// Получить кинематическую вязкость масловоздушной смеси для внутренней цилиндрической поверхности сепаратора  в МЕТР2/СЕКУНДА

			// Определить среднюю величину зазора между центрирующими поясками сепаратора и центрирующей поверхностью кольца  в МЕТРАХ  		
			SC_m = (Dcb_m - Dc_m)/2;

			// Определить начальное приближение относительного эксцентриситета сепаратора
			ksi = fabs(Dcb_m-Dc_m)/Dcb_m;

			// Запомнить начальное значение относительного эксцентриситета сепаратора
			ksi_nach = ksi;

			// Взять начальное приближение относительного эксцентриситета сепаратора		
			ksi1 = ksi;	
		
			// Итерационный цикл уточнения относительного эксцентриситета сепаратора
			while (1)
			{
				// Определение усилия в контакте сепаратора с центрирующей поверхностью кольца в КИЛОГРАММАХ ??? по формуле из книги  А.Камерон Теория смазки в инженерном деле стр.123 ф-ла 29
				//Rc1_kg	= fabs(W_vk*Rc_m-W_sep*Rcb_m) * Vyaz_din_pa_s * (Lcb_m*Lcb_m*Lcb_m) / (SC_m*SC_m)* pi/4 * ksi1/sqr(1-ksi1*ksi1) * sqrt((16/(pi*pi)-1)*ksi1*ksi1 + 1);

				// Определение усилия в контакте сепаратора с центрирующей поверхностью кольца в КИЛОГРАММАХ ??? по формуле из дисс.Акифьева стр.72 ф-ла 85 б
				Rc1_kg	= fabs(W_vk*Rc_m-W_sep*Rcb_m) * Vyaz_din_pa_s * Lcb_m / (SC_m*SC_m)* pi/8 * ksi1/sqr(1-ksi1*ksi1) * sqrt((16/(pi*pi)-1)*ksi1*ksi1 + 1);

				// Определить невязку (разность) между усилиями в контакте сепаратора с центрирующей поверхностью кольца рассчитанной двумя способами
				nev1	= Rc1_kg - F_sep_poyaski_kg;

				if (fabs(nev1) < 0.01)	
				{
					// Невязка меньше 10 грамм. Запомнить найденный относительный эксцентриситет и выйти из итерационного цикла.	
					ksi = ksi1;
					break;
				}

				// Изменить текущую величину эксцентрисистета сепаратора на 1%
				ksi2	= ksi1 + ksi1*0.01;

				// Определение усилия в контакте сепаратора с центрирующей поверхностью кольца в КИЛОГРАММАХ ??? по формуле из книги  А.Камерон Теория смазки в инженерном деле стр.123 ф-ла 29
				//Rc2_kg	= fabs(W_vk*Rc_m-W_sep*Rcb_m) * Vyaz_din_pa_s * (Lcb_m*Lcb_m*Lcb_m) / (SC_m*SC_m)* pi/4 * ksi2/sqr(1-ksi2*ksi2) * sqrt((16/(pi*pi)-1)*ksi2*ksi2 + 1);

				// Определение усилия в контакте сепаратора с центрирующей поверхностью кольца в КИЛОГРАММАХ ??? по формуле из дисс.Акифьева стр.72 ф-ла 85 б			
				Rc2_kg	= fabs(W_vk*Rc_m-W_sep*Rcb_m) * Vyaz_din_pa_s * Lcb_m / (SC_m*SC_m)* pi/8 * ksi2/sqr(1-ksi2*ksi2) * sqrt((16/(pi*pi)-1)*ksi2*ksi2 + 1);

				// Определить невязку (разность) между усилиями в контакте сепаратора с центрирующей поверхностью кольца рассчитанной двумя способами
				nev2	= Rc2_kg - F_sep_poyaski_kg;

				if (fabs(nev2) < 0.01)
				{
					// Невязка меньше 10 грамм. Запомнить найденный относительный эксцентриситет и выйти из итерационного цикла.	
					ksi = ksi2;
					break;				
				}

				if ((nev2 == nev1) || (ksi2 == ksi1)) break;

				// Выполнить шаг по методу Ньютона и найти следующее приближение относительного эксцентриситета
				ksi1_ = ksi1 - nev1/((nev2-nev1)/(ksi2 - ksi1));
				ksi1 = 	ksi1_;	
			}

			// Угол нагрузки в РАДИАНАХ (дисс.Акифьева стр.72 ф-ла 84, А.Камерон Теория смазки в инженерном деле стр.125 ф-ла 31)
			fi = atan(pi*sqrt(1-ksi*ksi)/(4*ksi));

			// Тормозящий момент в НЬЮТОН*МЕТР действующий на центрирующие пояски сепаратора из за их трения о поверхность центрирования кольца. Формула получена на основе А.Камерон Теория смазки в инженерном деле стр.127 ф-ла 34
			TM_poyaski_sep1 = abs_W_I/W_I * (( (-1)*(SC_m * ksi * Rad_nagr_sep_n * sin(fi)/(2*Rcb_m)) + (2*pi*Vyaz_din_pa_s * fabs(W_sep*Rcb_m-W_vk*Rc_m) * Rcb_m*Lcb_m)/(sqrt(1-ksi*ksi) * SC_m)) ) * Rcb_m;

			// Тормозящий момент в НЬЮТОН*МЕТР действующий на центрирующие пояски сепаратора из за их трения о поверхность центрирования кольца. см. дисс. Акифьева стр.72 ф-ла 83б
			//TM_poyaski_sep1 = abs_W_I/W_I * ( ( (-1)*SC_m * ksi * Rad_nagr_sep_n * sin(fi)) + (pi*Vyaz_din_pa_s * fabs(W_sep*Rcb_m-W_vk*Rc_m) * Rcb_m*Rcb_m * Lcb_m)/(sqrt(1-ksi*ksi) * SC_m)) ;


			// Потеря мощности в ВТ на центрирующих поясках сепаратора из за их трения о поверхность центрирования кольца.
			N_poyaski_sep1 = fabs(TM_poyaski_sep1 * W_I);

			// Определить число Рейнольдса для течения масловоздушной смеси в зазоре между центрирующими поясками и центрирующей поверхностью внутреннего кольца
			Re_p = Dcb_m/2 * abs_W_I * SC_m / Vyaz_kin_m2_s;

			if (Re_p >= 2500)
			{
				// Получить коэффциент трения для турбулентного течения Куэтта
				Ftr_p = 3.0 * 16.0 / Re_p * step(Re_p/2500, 0.85596);
			}
			else
			{
				// Получить коэффициент трения для ламинарного течения	
				Ftr_p = 16.0 / Re_p;
			}

			// Тормозящий момент в НЬЮТОН*МЕТР действующий на центрирующие пояски сепаратора из за их вращения в масловоздушной смеси
			TM_poyaski_sep2 = abs_W_I/W_I * Ftr_p * RO_smes_sep_kg_m3 * (Dcb_m * Dcb_m * Dcb_m)/8 * (W_I * W_I) * (2*pi*Dcb_m/2*Lcb_m);

			// Потеря мощности в ВТ на центрирующих поясках сепаратора из за их трения о масловоздушную смесь
			N_poyaski_sep2 = fabs(TM_poyaski_sep2 * W_I);
		}
		else
		{
			//  В подшипнике центрирование сепаратора идет по наружному кольцу.  
			//  Центрирующие пояски расположены на наружной поверхности сепаратора 
			//
			Vyaz_din_kg_s_mm2 = Vyaz_Rolands(Patm, T_nk+273, &Pezo_koeff_1);	// Получить динамическую вязкость смазки для наружной цилиндрической поверхности сепаратора в КИЛОГРАММ*СЕКУНДА/МИЛЛИМЕТР2  по формуле Роландса 
			Vyaz_din_pa_s = Vyaz_din_kg_s_mm2 * 1000000 * 9.8;			// Получить динамическую вязкость смазки для наружной цилиндрической поверхности сепаратора в ПАСКАЛЬ*СЕКУНДА
			Vyaz_kin_m2_s = Vyaz_din_pa_s/RO_smes_sep_kg_m3;			// Получить кинематическую вязкость масловоздушной смеси для наружной цилиндрической поверхности сепаратора  в МЕТР2/СЕКУНДА

			// Определить среднюю величину зазора между центрирующими поясками сепаратора и центрирующей поверхностью кольца  в МЕТРАХ  		
			SC_m = (Dc_m - Dcb_m)/2;

			// Определить начальное приближение относительного эксцентриситета сепаратора
			ksi = fabs(Dcb_m-Dc_m)/Dcb_m;

			// Запомнить начальное значение относительного эксцентриситета сепаратора
			ksi_nach = ksi;

			// Взять начальное приближение относительного эксцентриситета сепаратора
			ksi1	= ksi;	

			// Итерационный цикл уточнения относительного эксцентриситета сепаратора
			while (1)
			{
				// Определение усилия в контакте сепаратора с центрирующей поверхностью кольца в КИЛОГРАММАХ ??? по формуле из книги  А.Камерон Теория смазки в инженерном деле стр.123 ф-ла 29
				//Rc1_kg	= fabs(W_sep*Rcb_m - W_nk*Rc_m) * Vyaz_din_pa_s * (Lcb_m*Lcb_m*Lcb_m) / (SC_m*SC_m)* pi/4 * ksi1/sqr(1-ksi1*ksi1) * sqrt((16/(pi*pi)-1)*ksi1*ksi1 + 1);

				// Определение усилия в контакте сепаратора с центрирующей поверхностью кольца в КИЛОГРАММАХ ??? по формуле из дисс.Акифьева ф-ла 85а
				Rc1_kg	= fabs(W_sep*Rcb_m - W_nk*Rc_m) * Vyaz_din_pa_s * Lcb_m / (SC_m*SC_m)* pi/8 * ksi1/sqr(1-ksi1*ksi1) * sqrt((16/(pi*pi)-1)*ksi1*ksi1 + 1);

				// Определить невязку (разность) между усилиями в контакте сепаратора с центрирующей поверхностью кольца рассчитанной двумя способами
				nev1	= Rc1_kg - F_sep_poyaski_kg;
				if (fabs(nev1) < 0.01)	
				{
					// Невязка меньше 10 грамм. Запомнить найденный относительный эксцентриситет и выйти из итерационного цикла.	
					ksi = ksi1;
					break;
				}

				// Изменить текущую величину эксцентрисистета сепаратора на 1%
				ksi2	= ksi1 + ksi1*0.01;

				// Определение усилия в контакте сепаратора с центрирующей поверхностью кольца в КИЛОГРАММАХ ??? по формуле из книги  А.Камерон Теория смазки в инженерном деле стр.123 ф-ла 29
				//Rc2_kg	= fabs(W_sep*Rcb_m - W_nk*Rc_m) * Vyaz_din_pa_s * (Lcb_m*Lcb_m*Lcb_m) / (SC_m*SC_m)* pi/4 * ksi2/sqr(1-ksi2*ksi2) * sqrt((16/(pi*pi)-1)*ksi2*ksi2 + 1);

				// Определение усилия в контакте сепаратора с центрирующей поверхностью кольца в КИЛОГРАММАХ ??? по формуле из дисс.Акифьева ф-ла 85а			
				Rc2_kg	= fabs(W_sep*Rcb_m - W_nk*Rc_m) * Vyaz_din_pa_s * Lcb_m / (SC_m*SC_m)* pi/8 * ksi2/sqr(1-ksi2*ksi2) * sqrt((16/(pi*pi)-1)*ksi2*ksi2 + 1);

				// Определить невязку (разность) между усилиями в контакте сепаратора с центрирующей поверхностью кольца рассчитанной двумя способами
				nev2	= Rc2_kg - F_sep_poyaski_kg;

				if (fabs(nev2) < 0.01)
				{
					// Невязка меньше 10 грамм. Запомнить найденный относительный эксцентриситет и выйти из итерационного цикла.	
					ksi = ksi2;
					break;				
				}

				if ((nev2 == nev1) || (ksi2 == ksi1)) break;

				// Выполнить шаг по методу Ньютона и найти следующее приближение относительного эксцентриситета
				ksi1_ = ksi1 - nev1/((nev2-nev1)/(ksi2 - ksi1));
				ksi1 = 	ksi1_;	
			}

			// Угол нагрузки в РАДИАНАХ (дисс.Акифьева стр.72 ф-ла 84, А.Камерон Теория смазки в инженерном деле стр.125 ф-ла 31)
			fi = atan(pi*sqrt(1-ksi*ksi)/(4*ksi));

			// Тормозящий момент в НЬЮТОН*МЕТР действующий на центрирующие пояски сепаратора из за их трения о поверхность центрирования кольца. Формула получена на основе А.Камерон Теория смазки в инженерном деле стр.127 ф-ла 34
			TM_poyaski_sep1 = abs_W_O/W_O * (( (SC_m * ksi * Rad_nagr_sep_n * sin(fi)/(2*Rcb_m)) + (2*pi*Vyaz_din_pa_s * fabs(W_sep*Rcb_m-W_nk*Rc_m) * Rcb_m*Lcb_m)/ (sqrt(1-ksi*ksi) * SC_m)) ) * Rcb_m;
			//fprintf(f2,"\n	По формуле Кэмерона:	Тормозящий момент на центрирующих поясках сепаратора из за их трения о поверхность центрирования кольца = %7.3f кг*мм  \n\n", TM_poyaski_sep1*1000/9.8);

			// Тормозящий момент в НЬЮТОН*МЕТР действующий на центрирующие пояски сепаратора из за их трения о поверхность центрирования кольца. Дисс.Акифьева стр.72 ф-ла 83а.
			//TM_poyaski_sep1 = abs_W_O/W_O * ( (SC_m * ksi * Rad_nagr_sep_n * sin(fi)) + (pi*Vyaz_din_pa_s * fabs(W_sep*Rcb_m-W_nk*Rc_m) * Rcb_m*Rcb_m*Lcb_m)/ (sqrt(1-ksi*ksi) * SC_m)) ;
			//fprintf(f2,"\n	По формуле Акифьева:	Тормозящий момент на центрирующих поясках сепаратора из за их трения о поверхность центрирования кольца = %7.3f кг*мм  \n\n", TM_poyaski_sep1*1000/9.8);

			// Потеря мощности в ВТ на центрирующих поясках сепаратора из за их трения о поверхность центрирования кольца.
			N_poyaski_sep1 = fabs(TM_poyaski_sep1 * W_O);

			// Определить число Рейнольдса для течения масловоздушной смеси в зазоре между центрирующими поясками и центрирующей поверхностью наружного кольца
			Re_p = Dcb_m/2 * abs_W_O * SC_m / Vyaz_kin_m2_s;

			if (Re_p >= 2500)
			{
				// Получить коэффциент трения для турбулентного течения Куэтта
				Ftr_p = 3.0 * 16.0 / Re_p * step(Re_p/2500, 0.85596);
			}
			else
			{
				// Получить коэффициент трения для ламинарного течения	
				Ftr_p = 16.0 / Re_p;
			}

			// Тормозящий момент в НЬЮТОН*МЕТР действующий на центрирующие пояски сепаратора из за их вращения в масловоздушной смеси
			TM_poyaski_sep2 = abs_W_O/W_O * Ftr_p * RO_smes_sep_kg_m3 * (Dcb_m * Dcb_m * Dcb_m)/8 * (W_O * W_O) * (2*pi*Dcb_m/2*Lcb_m);

			// Потеря мощности в ВТ на центрирующих поясках сепаратора из за их трения о масловоздушную смесь
			N_poyaski_sep2 = fabs(TM_poyaski_sep2 * W_O);
		}
	}
	else
	{
		// У сепаратора нет центрирующих поясков. 
		
		// Тормозящий момент на центрирующих поясках из за трения о поверхность центрирования кольца равен 0.
		TM_poyaski_sep1 = 0.0;

		// Потеря мощности в ВТ на центрирующих поясках сепаратора из за их трения о поверхность центрирования кольца.
		N_poyaski_sep1 = 0.0;

		// Тормозящий момент на центрирующих поясках из за трения о масловоздушную смесь равен 0.
		TM_poyaski_sep2 = 0.0;

		// Потеря мощности в ВТ на центрирующих поясках сепаратора из за их трения о масловоздушную смесь
		N_poyaski_sep2 = 0.0;
	}

	// Определить итоговый тормозящий момент в НЬЮТОН*МЕТР действующий на центрирующие пояски сепаратора
	TM_poyaski_sep = TM_poyaski_sep1 + TM_poyaski_sep2;

	if (TM_poyaski_sep > 0.0)
	{
		// Выдать относительный эксцентриситет сепаратора, угол нагрузки, массу сепаратора усилие в контакте сепаратора с центрирующей поверхностью кольца
		fprintf(f2,"\n\n	");
		fprintf(f2,"\n		Относительный эксцентриситет сепаратора начальный = %7.5f радиан ", ksi_nach);
		fprintf(f2,"\n		Относительный эксцентриситет сепаратора после уточнения = %7.5f радиан ", ksi);
		fprintf(f2,"\n		Угол нагрузки = %7.5f радиан ", fi);
		fprintf(f2,"\n		Масса сепаратора = %7.3f кг ", 	M_sep_kg);
		fprintf(f2,"\n		Усилие в контакте поясков сепаратора с центрирующей поверхностью кольца = %7.3f кг  \n\n", F_sep_poyaski_kg);
		fprintf(f2,"\n	");
	}

	// Определить полную потерю мощености в ВТ на центрирующих поясках сепаратора
	N_poyaski_sep = N_poyaski_sep1 + N_poyaski_sep2;

	// Выдать в отчет тормозящие моменты и потерю мощности на центрирующих поясках в ВТ.
	fprintf(f2,"\n\n	Тормозящий момент на центрирующих поясках сепаратора из за их трения о поверхность центрирования кольца = %10.3f кг*мм ", TM_poyaski_sep1*1000/9.8);	
	fprintf(f2,"\n	Потеря мощности на центрирующих поясках сепаратора из за их трения о поверхность центрирования кольца = %10.3f ВТ ", N_poyaski_sep1);

	fprintf(f2,"\n\n	Тормозящий момент на центрирующих поясках сепаратора из за их вращения в масловоздушной смеси = %10.3f кг*мм ", TM_poyaski_sep2*1000/9.8);
	fprintf(f2,"\n		Потеря мощности на центрирующих поясках сепаратора из за их вращения в масловоздушной смеси = %10.3f ВТ ", N_poyaski_sep2);

	fprintf(f2,"\n\n	Итоговый тормозящий момент на центрирующих поясках сепаратора  = %10.3f кг*мм ", TM_poyaski_sep*1000/9.8);	
	fprintf(f2,"\n		Итоговая потеря мощности на центрирующих поясках сепаратора = %10.3f ВТ \n\n ", N_poyaski_sep);

	// Тормозящий момент действующий на сепаратор в НЬЮТОНАХ*МЕТР является суммой тормозящихо моментов действующих на наружную, внутреннюю, боковую поверхности сепаратора 
	// и центрирующие пояски
	TM_sep = TM_nar_sep + TM_vnut_sep + TM_bok_sep + TM_poyaski_sep;

	// Определить полную потерю мощности на сепараторе (Сумма потерь мощности на наружной, внутренней, боковой поверхностях сепаратора и на центрирующих поясках).
	* N_hdr_sep1 = N_nar_sep + N_vnut_sep + N_bok_sep + N_poyaski_sep;

	fprintf(f2,"\n\n");
	fprintf(f2,"\n ------------------------------------------------------------------------------------ ");
	fprintf(f2,"\n |                                                      |  Тормозящий  |  Потери    | "); 
	fprintf(f2,"\n |       Поверхности сепаратора                         |    момент    | мощности   | ");
	fprintf(f2,"\n |                                                      |    в кг*мм   |  в вт.     | "); 
	fprintf(f2,"\n -------------------------------------------------------+--------------+------------- ");
	fprintf(f2,"\n | Наружная цилиндрическая  (без центрирующих поясков)  |  %10.3f  | %10.3f | ", TM_nar_sep*1000/9.8,	N_nar_sep);
	fprintf(f2,"\n | Внутренняя цилиндрическая (без центрирующих поясков) |  %10.3f  | %10.3f | ", TM_vnut_sep*1000/9.8,	N_vnut_sep);
	fprintf(f2,"\n | Центрирующие пояски                                  |  %10.3f  | %10.3f | ", TM_poyaski_sep*1000/9.8, N_poyaski_sep);
	fprintf(f2,"\n | Боковые                                              |  %10.3f  | %10.3f | ", TM_bok_sep*1000/9.8,	N_bok_sep);
	fprintf(f2,"\n -------------------------------------------------------+--------------+------------- ");
	fprintf(f2,"\n | Итого                                                |  %10.3f  | %10.3f | ",TM_sep*1000/9.8,		* N_hdr_sep1);	
	fprintf(f2,"\n ------------------------------------------------------------------------------------ ");	
	fprintf(f2,"\n\n");

}
else
{
	// Сепаратор не вращается

	// Момент сопротивления действующий на сепаратор отсуствует.
	TM_sep = 0.0;

	// Потеря мощности на сепараторе отсуствует
	* N_hdr_sep1 = 0;
}



// Перевод тормозящего момента действующего на сепаратор в КИЛОГРАММ*МИЛЛИМЕТР
TM_sep = TM_sep*1000/9.8;

// Установить знак тормозящего момента
TM_sep = TM_sep * znak; 




// Выход из подпрограммы с возвратом найденного тормозящего момента действующего на сепаратор в КИЛОГРАММАХ*МИЛЛИМЕТР
return TM_sep;



}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////			ПОДПРОГРАММА ОПРЕДЕЛЕНИЯ НЕВЯЗКИ УРАВНЕНИЯ МОМЕНТОВ СИЛ ДЕЙСТВУЮЩИХ НА СЕПАРАТОР	//////////////
///
///
///		Входные параметры :			   DR - Сближение в мм осей внутреннего и наружного кольца из за действия нагрузки.
///	    							W_sep - Угловая скорость в радианах/сек сепаратора.
///									  T_w - Рабочая температура ролика в градусах Цельсия
///`									 T_vk - Рабочая температура внутреннего кольца  в градусах Цельсия
///									 T_nk - Рабочая температура наружного кольца  в градусах Цельсия
///								priz_pech - Признак выдачи в отчет промежуточных результатов
///
///     Выходные параметры :	* Sum_N_hdr_w1- Суммарная потеря мощности на преодоление гидромеханического сопротивления всех роликов в ваттах
///							* N_hdr_sep1  - Потеря мощности на преодоление гидромеханического сопротивления сепаратора в ваттах
///
///	Возвращаекмое значение :	Невязка уравнения равновесия моментов действующих на сепаратор
///
///

double Nev_mom_sep( double DR, double W_sep, double T_w, double T_vk, double T_nk, int priz_pech , double * Sum_N_hdr_w1, double * N_hdr_sep1 )
{

double T_sep;			// Тормозящий момент действующий на сепаратор
double NEV;			// Невязка уравнения равновесия моментов действующих на сепаратор

double Sum_N_hdr_w;		// Суммарная потеря мощности на преодоление гидромеханического сопротивления всех роликов в ваттах
double N_hdr_sep;		// Потеря мощности на преодоление гидромеханического сопротивления сепаратора в ваттах

int n_rol;			// Счетчик роликов


// Определить силы действующие на сепаратор со стороны всех роликов (Результат помещается в массив F_rol_sep[] ).
w_rolik(DR, W_sep, T_w, T_vk, T_nk, priz_pech, &Sum_N_hdr_w );

// Определить невязку уравнения равновесия моментов сил действующих на сепаратор в кг*мм.
NEV = 0;
for (n_rol=0; n_rol<Z; n_rol++)
{
	NEV += *(F_rol_sep+n_rol)*RM_sep;
}

fprintf(f2,"\n\n											");
fprintf(f2,"\n       Толкающий момент действующий на сепаратор со стороны роликов в кг*мм = %13.8f ", NEV);

// Вызов подпрограммы определения тормозящего момента от сил жидкостного трения действующих на сепаратор 
// в кг*мм и потерю мощности на перемешивание смазки
T_sep = Trmz_mom_sep( W_sep, &N_hdr_sep );


// Определить невязку уравнения моментов сил действующих на сепаратор с учетом тормозящего момента
NEV += T_sep;

fprintf(f2,"\n Результирующий момент от сил жидкостного трения действующий на сепаратора в кг*мм = %13.8f ( + толкающий, - тормозящий)  ", T_sep);
fprintf(f2,"\n        Невязка уравнения равновесия моментов сил действующих на сепаратор в кг*мм = %13.8f ", NEV);
fprintf(f2,"\n														");


// Суммарная потеря мощности на преодоление гидромеханического сопротивления всех роликов в ваттах
* Sum_N_hdr_w1 = Sum_N_hdr_w;

// Потеря мощности на преодоление гидромеханического сопротивления сепаратора в ваттах
* N_hdr_sep1 = N_hdr_sep;


// Выход из подпрограммы с возвратом невязки уравнения моментов сил действующих на сепаратор
return NEV;

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////		ПОДПРОГРАММА ОПРЕДЕЛЕНИЯ УГЛОВОЙ СКОРОСТИ ВРАЩЕНИЯ СЕПАРАТОРА С УЧЕТОМ СМАЗКИ		//////////////
///
///		Входные параметры :		DR   - Сближение в мм осей внутреннего и наружного кольца из за действия нагрузки.
///						T_w  - Рабочая температура ролика в градусах Цельсия
///						T_vk - Рабочая температура внутреннего кольца  в градусах Цельсия
///						T_nk - Рабочая температура наружного кольца  в градусах Цельсия
///					  W_sep_nach - Исходная угловая скорость вращения сенпаратора	
///
///	   Выходные параметры :		* Sum_N_hdr_w1	- Суммарная потеря мощности на преодоление гидромеханического сопротивления всех роликов в ваттах
///					* N_hdr_sep1	- Потеря мощности на преодоление гидромеханического сопротивления сепаратора в ваттах
///					* N_hdr_pod1	- Итоговая потеря мощности на преодоление гидромеханического сопротивления всего подшипника в ваттвх
///						
///
///	Возвращаемое значение :	   W_sep - Полученная угловая скорость вращения сепаратора в радиан/сек
///

double W_separator( double DR, double T_w, double T_vk, double T_nk, double W_sep_nach, double * Sum_N_hdr_w1, double * N_hdr_sep1, double * N_hdr_pod1 )
{

double eps1;			// Допустимая погрешность решения уравнения равновесия моментов си действующих на ролик
double W_sep;			// Угловая скорость сепаратора в радианах/секунду
double W_sep_1;			// Следующее приближение угловой скорости сепаратора
double dw_sep;			// Приращение угловой скорости сепаратора
double Nev_0;			// Невязка уравнения равновесия моментов действующих на сепаратор для скорости № 0
double Nev_plus_1;		// Невязка уравнения равновесия моментов действующих на сепаратор для скорости № +1

double Sum_N_hdr_w;		// Суммарная потеря мощности на преодоление гидромеханического сопротивления всех роликов в ваттах.
double N_hdr_sep;		// Потеря мощности на преодоление гидромеханического сопротивления сепаратора в ваттах.

int nom_it;			// Счетчик итераций



// Задать малое значение определяющее точность решения уравнения
// равновесия моментов сил действующих на сепаратор
eps1 = 0.01;

// Задать начальное приближения угловой скорости сепаратора в радианах/секунда
W_sep = W_sep_nach;

// Если угловая скорость сепаратора близка к 0 тогда установить ее равной 0.01 радиан/секунда
if (fabs(W_sep) < 0.01) W_sep=0.01;

// Задать начальное значение счетчика итераций
nom_it = 1;


// Итерационный цикл в котором идет шагание с помощью метода Ньютона-Рафсона с целью минимизации невязки уравнения равновесия.
while (1)
{
	// Задать приращение угловой скорости сепаратора
	dw_sep = W_sep/1000;
	
	// Получить невязку в точке 0
	Nev_0 =	Nev_mom_sep(DR, W_sep, T_w, T_vk, T_nk, 1, &Sum_N_hdr_w, &N_hdr_sep );

	// Выдать невязку уравнения равновесия сепаратора при скорости сепаратора W_sep
	fprintf(f2,"\n  W_sep = %17.8f           Nev_0 = %17.8f    ", W_sep, Nev_0 );	
	printf("\n  W_sep = %17.8f           Nev_0 = %17.8f    ", W_sep, Nev_0 );	

	if (fabs(Nev_0) < eps1) 
	{
		// Невязка в точке 0 меньше заданной точности. Выход из итерационного цикла.
		break;
	}

	// Получить невязку в точке +1
	Nev_plus_1 = Nev_mom_sep(DR, W_sep+dw_sep, T_w, T_vk, T_nk, 1, &Sum_N_hdr_w, &N_hdr_sep );

	// Выдать невязку уравнения равновесия сепаратора при скорости сепаратора W_sep+dw_sep	
	fprintf(f2,"\n  W_sep = %17.8f           Nev+1 = %17.8f    ", W_sep+dw_sep, Nev_plus_1);	
	printf("\n  W_sep = %17.8f           Nev+1 = %17.8f    ", W_sep+dw_sep, Nev_plus_1);	

	if (fabs(Nev_plus_1) < eps1) 
	{
		// Невязка в точке +1 меньше заданной точности. Выход из итерационного цикла.
		W_sep+=dw_sep;
		break;
	}

	// Шаг по методу Ньютона-Рафсона и получение следующего значения угловой скорости сепаратора
	W_sep_1 = W_sep - 0.5*Nev_0 /((Nev_plus_1-Nev_0)/dw_sep);

	// Нарастить счетчик итераций
	nom_it++;

	// Считать текущим следующее значение скорости сепаратора
	W_sep = W_sep_1;

	// Перевод строки
	fprintf(f2,"\n  ");	
	printf("\n  ");	
}

// Суммарная потеря мощности на преодоление гидромеханического сопротивления всех роликов в ваттах
* Sum_N_hdr_w1 = Sum_N_hdr_w;

// Потеря мощности на преодоление гидродинамического сопротивления сепаратора в ваттах
* N_hdr_sep1 = N_hdr_sep;

//  Итоговая потеря мощности на преодоление гидромеханического сопротивления всего подшипника в ваттвх
* N_hdr_pod1 = Sum_N_hdr_w + N_hdr_sep;



// Выход из подпрограммы с возвратом найденной угловой скорости сепаратора в радианах / секунду
return W_sep;

}


//////////////////////////////////////////////////////////////////////////////////////////////////////
/////  ПОДПРОГРАММА ОСВОБОЖДЕНИЯ ВСЕХ БЛОКОВ ПАМЯТИ ВЫДЕЛЕННЫХ В ПОДПРОГРАММЕ ROL_MAX_NAPR() 	//////


void free_mem_rol_max_napr()
{

if (QJ 			!= NULL) 	free(QJ);
if (QHU 		!= NULL) 	free(QHU);
if (DEC 		!= NULL) 	free(DEC);
if (F1X 		!= NULL) 	free(F1X);
if (F2X 		!= NULL) 	free(F2X);
if (F1V 		!= NULL) 	free(F1V);
if (F2V 		!= NULL) 	free(F2V);
if (DB 			!= NULL) 	free(DB);
if (DH 			!= NULL) 	free(DH);
if (Bv 			!= NULL) 	free(Bv);
if (Bn 			!= NULL) 	free(Bn);
if (BVmax 		!= NULL) 	free(BVmax);
if (BNmax 		!= NULL) 	free(BNmax);
if (DB2 		!= NULL) 	free(DB2);
if (DH2 		!= NULL) 	free(DH2);
if (SIGI 		!= NULL) 	free(SIGI);
if (SIGO 		!= NULL) 	free(SIGO);
if (priz_uch 		!= NULL) 	free(SIGO);
if (FCOP 		!= NULL) 	free(FCOP);
if (SIGI_max 		!= NULL) 	free(SIGI_max);
if (SIGO_max 		!= NULL) 	free(SIGO_max);
if (SIGI2 		!= NULL) 	free(SIGI2);
if (SIGO2 		!= NULL) 	free(SIGO2);
if (k_sl 		!= NULL) 	free(k_sl);
if (k_sl1 		!= NULL) 	free(k_sl1);
if (priz_uch_neravn 	!= NULL) 	free(priz_uch_neravn);
if (NAPR_neravn 	!= NULL) 	free(NAPR_neravn);
if (profil 		!= NULL) 	free(profil);
if (F_rol_sep 		!= NULL) 	free(F_rol_sep);
if (F_tr_rol_sep 	!= NULL) 	free(F_tr_rol_sep);
if (kol_neravn_uch_polosa != NULL) 	free(kol_neravn_uch_polosa);
if (swaz_neravn_ravn 	!= NULL) 	free(swaz_neravn_ravn);
if (prav_gr_neravn_uch 	!= NULL) 	free(prav_gr_neravn_uch);
if (DEF_neravn 		!= NULL) 	free(DEF_neravn);

if (Q_centr_0_I			!= NULL)	free(Q_centr_0_I);
if (P_centr_0_I			!= NULL)        free(P_centr_0_I);
if (V_skol_poverh_centr_0_I 	!= NULL)  	free(V_skol_poverh_centr_0_I);
if (U_kach_centr_0_I		!= NULL)	free(U_kach_centr_0_I);		
if (t_centr_0_I			!= NULL)        free(t_centr_0_I);
if (h_centr_0_I			!= NULL)        free(h_centr_0_I);
if (Nr_centr_0_I		!= NULL)        free(Nr_centr_0_I);
if (Def_0_I			!= NULL)	free(Def_0_I);		

if (Q_centr_0_O			!= NULL)	free(Q_centr_0_O);
if (P_centr_0_O			!= NULL)        free(P_centr_0_O);
if (V_skol_poverh_centr_0_O 	!= NULL)  	free(V_skol_poverh_centr_0_O);
if (U_kach_centr_0_O		!= NULL)	free(U_kach_centr_0_O);		
if (t_centr_0_O			!= NULL)        free(t_centr_0_O);
if (h_centr_0_O			!= NULL)        free(h_centr_0_O);
if (Nr_centr_0_O		!= NULL)        free(Nr_centr_0_O);
if (Def_0_O			!= NULL)	free(Def_0_O);		

if (Vyaz_smazka	!= NULL)	free(Vyaz_smazka);		
if (Pezo_smazka	!= NULL)	free(Pezo_smazka);		
if (Temp_smazka	!= NULL)	free(Temp_smazka);		

if (k_lagr_vyaz	!= NULL)	free(k_lagr_vyaz);		
if (k_lagr_pezo	!= NULL)	free(k_lagr_pezo);		


////////////////////////////////////////////////////////////
//
if (Energ_def_rol != NULL)	free(Energ_def_rol);
if (Dop_usil_sep  != NULL)	free(Dop_usil_sep);
//
////////////////////////////////////////////////////////////

if (matr_mnk	!= NULL)	free(matr_mnk);
if (stolb_mnk 	!= NULL)	free(stolb_mnk);
if (koeff_mnk	!= NULL)	free(koeff_mnk);


return;

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////		РАСЧЁТ ДОЛГОВЕЧНОСТИ ПО КОНТАКТНОМУ НАПРЯЖЕНИЮ (ОДНОМЕРНАЯ СЕТКА)	//////////////////////////////
///
///
///	Возвращаемое значение : Долговечность подшипника по контактным напряжениям в миллионах оборотов
///

double DOLG1()
{
	int k;			// Счётчик роликов
	int i;			// Счётчик участков в контакте ролика с дорожкой качения 

	double Q_eq_vk;		// Эквивалентная нагрузка в контакте ролика с дорожкой качения внутреннего кольца
	double Q_eq_nk;		// Эквивалентная нагрузка в контакте ролика с дорожкой качения наружного кольца

	double Sum_Q_eq_vk;	// Суммарная эквивалентная нагрузка для внутреннего кольца
	double Sum_Q_eq_nk;	// Суммарная эквивалентная нагрузка для наружного кольца
	double Sq;		// Вспомогательная переменная 

	double Qc_vk;		// Динамическая нагрузочная способность для дорожки качения внутреннего кольца
	double Qc_nk;		// Динамическая нагрузочная способность для дорожки каченния наружного кольца

	double Q_ki;		// Усилие на участке контакта № i ролика № k 
	double Y;		// Отношение диаметра ролика к диаметру орбиты по которой бегают центры роликов

	double L_vk;		// Долговечность дорожки качения внутреннего кольца в миллионах оборотах
	double L_nk;		// Долговечность дорожки качения наружного кольца в миллионах оборотов
	double L_pod;		// Долговечность подшипника в миллионах оборотов

	// Определить отношение диаметра ролика к диаметру орбиты по которой бегают центры роликов
	Y = Dw/DM;

	// Определить динамическую нагрузочную способность для дорожки качения наружного кольца
	Qc_nk = Lambda * step(1+Y, 29.0/27.0) / step(1-Y, 1.0/4.0) * step(Y,2.0/9.0) * step(Dw,29.0/27.0) * step(RL,7.0/9.0)*step( (double) Z,-1.0/4.0 );

	// Определить суммарную эквивалентную нагрузку для дорожки качения наружного кольца
	Sum_Q_eq_nk = 0.0;

	// Перебор в цикле всех роликов
	for (k=0; k<Z; k++)
	{
		// Определение эквивалентной нагрузки для ролика № k
		Sq = 0;
		for (i=0; i<N; i++)
		{
			Q_ki =	(*(SIGO+k*N+i)) * (*(Bn+k*N+i));	
			Q_ki = step(Q_ki, 9.0/2.0);
			Sq += Q_ki;										
		}
		Q_eq_nk = step(RL,7.0/9.0)* step(OM, 2.0/9.0) * step(Sq, 2.0/9.0);

		// Нарастить суммарную эквивалентную нагрузку для наружного кольца
		Sum_Q_eq_nk += step(Q_eq_nk, 4.5);
	}

	Sum_Q_eq_nk /= (double) Z;
	Sum_Q_eq_nk = step(Sum_Q_eq_nk, 1.0/4.5);
	
	// Определить долговечность дорожки качения наружного кольца в миллионах оборотов
	L_nk = step(Qc_nk/Sum_Q_eq_nk, 4.0);


	
	// Определить динамическую нагрузочную способность для дорожки качения внутреннего кольца
	Qc_vk = Lambda * step(1-Y, 29.0/27.0) / step(1+Y, 1.0/4.0) * step(Y,2.0/9.0) * step(Dw,29.0/27.0) * step(RL,7.0/9.0)*step( (double) Z,-1.0/4.0 );

	// Определить суммарную эквивалентную нагрузку для дорожки качения внутреннего кольца
	Sum_Q_eq_vk	= 0.0;

	// Перебор в цикле всех роликов
	for (k=0; k<Z; k++)
	{
		// Определение эквивалентной нагрузки для ролика № k
		Sq = 0;
		for (i=0; i<N; i++)
		{
			Q_ki = (*(SIGI+k*N+i)) * (*(Bv+k*N+i));	
			Q_ki = step(Q_ki, 9.0/2.0);			
			Sq += Q_ki;										
		}
		Q_eq_vk = step(RL,7.0/9.0) * step(OM, 2.0/9.0) * step(Sq, 2.0/9.0);

		// Нарастить суммарную эквивалентную нагрузку для внутреннего кольца
		Sum_Q_eq_vk += step(Q_eq_vk,4);	
	}

	Sum_Q_eq_vk /= (double) Z;
	Sum_Q_eq_vk = step(Sum_Q_eq_vk, 1.0/4.0);


	// Определить долговечность дорожки качения внутреннего кольца в миллионах оборотов
	L_vk = step(Qc_vk/Sum_Q_eq_vk, 4.0);

	// Определить долговечность подшипника в миллионах оборотов
	L_pod = step(step(L_vk, -9.0/8.0) + step(L_nk, -9.0/8.0), -8.0/9.0);


	// Выход из функции с возвратом найденной долговечности подшипника  в миллионах оборотов
	return L_pod;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////	  РАСЧЁТ ДОЛГОВЕЧНОСТИ ПО КОНТАКТНОМУ НАПРЯЖЕНИЮ (ДВУМЕРНАЯ СЕТКА)	//////////////
//
//
//	Возвращаемое значение : Долговечность подшипника по контактным напряжениям в миллионах оборотов
//

double DOLG2()
{
	int k;			// Счётчик роликов
	int i,j;		// Счётчики участков в контакте ролика с дорожкой качения 

	double Q_eq_vk;		// Эквивалентная нагрузка в контакте ролика с дорожкой качения внутреннего кольца
	double Q_eq_nk;		// Эквивалентная нагрузка в контакте ролика с дорожкой качения наружного кольца

	double Sum_Q_eq_vk;	// Суммарная эквивалентная нагрузка для дорожки качения внутреннего кольца
	double Sum_Q_eq_nk;	// Суммарная эквивалентная нагрузка для дорожки качения наружного кольца

	double Qc_vk;		// Динамическая нагрузочная способность для дорожки качения внутреннего кольца
	double Qc_nk;		// Динамическая нагрузочная способность для дорожки каченния наружного кольца

	double Sq;		// Вспомогательная переменная 
	double Q_ki;		// Погонная нагрузка на полосе контакта № i ролика № k
	double Sigma_kij;	// Напряжение на участке контакта № i,j ролика № k 
	double Y;		// Отношение диаметра ролика к диаметру окружности по которой бегают центры роликов

	double L_vk;		// Долговечность дорожки качения внутреннего кольца в миллионах оборотах
	double L_nk;		// Долговечность дорожки качения наружного кольца в миллионах оборотов
	double L_pod;		// Долговечность подшипника в миллионах оборотов


	// Определить отношение диаметра ролика к диаметру дорожки по которой бегают центры роликов
	Y = Dw/DM;

	// Определить динамическую нагрузочную способность для дорожки качения наружного кольца
	Qc_nk = Lambda * step(1+Y, 29.0/27.0) / step(1-Y, 1.0/4.0) * step(Y,2.0/9.0) * step(Dw,29.0/27.0) * step(RL,7.0/9.0)*step( (double) Z,-1.0/4.0 );

	// Определить суммарную эквивалентную нагрузку для дорожки качения наружного кольца
	Sum_Q_eq_nk = 0.0;

	// Перебор в цикле всех роликов
	for (k=0; k<Z; k++)
	{
		// Определение эквивалентной нагрузки для ролика № k в контакте с дорожкой качения наружного кольца
		Sq = 0;
		for (i=0; i<N; i++)
		{
			// Определить погонную нагрузку на полосе № i ролика № k
			Q_ki = 0.0;	
			for (j=0; j<kol_uch_shirina; j++)  
			{	
				Sigma_kij = *(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+j);
				if (Sigma_kij < 0.0)  Sigma_kij = 0.0;				
				Q_ki += step(Sigma_kij * OM , 9.0/2.0);
			}
			Q_ki = step(*(Bn+k*N+i),7.0/9.0) * step(OM,2.0/9.0) * step(Q_ki,2.0/9.0);

			Sq += step(Q_ki,9.0/2.0);	// Нарастить сумму погонных нагрузок по ролику № k в контакте с дорожкой качения наружного кольца
		}
		Q_eq_nk = step(RL,7.0/9.0) * step(OM,2.0/9.0) * step(Sq, 2.0/9.0);						

		// Нарастить суммарную эквивалентную нагрузку для дорожки качения наружного кольца
		Sum_Q_eq_nk += step(Q_eq_nk, 4.5);
	}

	Sum_Q_eq_nk /= (double) Z;
	Sum_Q_eq_nk = step(Sum_Q_eq_nk, 1.0/4.5);
	
	// Определить долговечность дорожки качения наружного кольца в миллионах оборотов
	L_nk = step(Qc_nk/Sum_Q_eq_nk, 4.0);


	// Определить динамическую нагрузочную способность для дорожки качения внутреннего кольца
	Qc_vk = Lambda * step(1-Y, 29.0/27.0) / step(1+Y, 1.0/4.0) * step(Y,2.0/9.0) * step(Dw,29.0/27.0) * step(RL,7.0/9.0)*step( (double) Z,-1.0/4.0 );

	// Определить суммарную эквивалентную нагрузку для дорожки качения внутреннего кольца
	Sum_Q_eq_vk	= 0.0;

	// Перебор в цикле всех роликов
	for (k=0; k<Z; k++)
	{
		// Определение эквивалентной нагрузки для ролика № k в контакте с дорожкой качения внутреннего кольца
		Sq = 0;
		for (i=0; i<N; i++)
		{
			// Определить погонную нагрузку на полосе № i ролика № k
			Q_ki = 0.0;	
			for (j=0; j<kol_uch_shirina; j++)  
			{	
				Sigma_kij = *(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+j);
				if (Sigma_kij < 0.0)  Sigma_kij = 0.0;
				Q_ki += step(Sigma_kij * OM, 9.0/2.0);
			}
			Q_ki = step(*(Bv+k*N+i),7.0/9.0) * step(OM,2.0/9.0) * step(Q_ki,2.0/9.0);
			Sq += step(Q_ki,9.0/2.0);	// Нарастить сумму погонных нагрузок по ролику № k в контакте с дорожкой качения внутреннего кольца
		}
		Q_eq_vk = step(RL,7.0/9.0) * step(OM,2.0/9.0) * step(Sq, 2.0/9.0);	

		// Нарастить суммарную эквивалентную нагрузку для дорожки качения внутреннего кольца
		Sum_Q_eq_vk += step(Q_eq_vk,4);	
	}

	Sum_Q_eq_vk /= (double) Z;
	Sum_Q_eq_vk = step(Sum_Q_eq_vk, 1.0/4.0);

	// Определить долговечность дорожки качения внутреннего кольца в миллионах оборотов
	L_vk = step(Qc_vk/Sum_Q_eq_vk, 4.0);


	// Определить долговечность подшипника в миллионах оборотов
	L_pod = step(step(L_vk, -9.0/8.0) + step(L_nk, -9.0/8.0), -8.0/9.0);



	// Выход из функции с возвратом найденной долговечности подшипника  в миллионах оборотов
	return L_pod;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////	РАСЧЁТ ДОЛГОВЕЧНОСТИ ПО КОНТАКТНОМУ НАПРЯЖЕНИЮ (ОДНОМЕРНАЯ СЕТКА) ПО МЕТОДИКЕ БАТЕНКОВА   ////////////////
///
///
///	Возвращаемое значение : Долговечность подшипника по контактным напряжениям в миллионах оборотов
///


double DOLG1_BAT()

{
	int k;			// Счётчик роликов
	int i;			// Счётчик участков в контакте ролика с дорожкой качения	

	double Dw_sm;		// Диаметр ролика в см.
	double DM_sm;		// Диаметр орбиты по которой бегают центры роликов в см.
	double OM_sm;		// Длина участка ролика в см.
	double RL_sm;		// Рабочая длина ролика в см.

	double Y;		// Отношение диаметра ролика к диаметру орбиты по которой бегают центры роликов

	double Sq;		// Вспомогательная переменная 
	double Pke;		// Эквивалентная нагрузка на ролик № k

	double Pe_vk;		// Суммарная эквивалентная нагрузка для дорожки качения внутреннего кольца
	double Pe_nk;		// Суммарная эквивалентная нагрузка для дорожки качения наружного кольца

	double C_nk;		// Динамическая грузоподъёмность дорожки качения наружного кольца
	double C_vk;		// Динамическая грузоподъёмность дорожки качения внутреннего кольца

	double Sigma_N_sm;	// Среднее давление на участке № i  ролика № k   перевести из кг/мм2  в   Н/см2
	double B_sm;		// Ширина участка в см.
	double Q_ki;		// Погонная нагрузка на участке № i  ролика № k в Н/см	

	double L_nk;		// Долговечность наружного кольца в миллионах оборотов 
	double L_vk;            // Долговечность внутреннего кольца в миллионах оборотов
	double L_pod;		// Долговечность подшипника


	Dw_sm = Dw/10.0;	// Определить диаметр ролика в см.
	DM_sm = DM/10.0;	// Определить диаметр орбиты по которой бегают центры роликов в см.
	OM_sm = OM/10.0;	// Определить длину участка ролика в см.
	RL_sm = RL/10.0;	// Определить рабочую длину ролика в см.


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///
	fprintf(f2,"\n	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");	
	fprintf(f2,"\n	*                                                                                                                               * ");	
	fprintf(f2,"\n	 						Сообщения из DOLG1_BAT 	        ");
	fprintf(f2,"\n	                                                                                ");	
	fprintf(f2,"\n                                    Диаметр ролика в /см/ Dw_sm =   %13.7f  ",Dw_sm);
	fprintf(f2,"\n   Диаметр орбиты по которой бегают центры роликов в /см/ DM_sm =   %13.7f  ",DM_sm);
	fprintf(f2,"\n   				 Ширина участка в  /см/ OM_sm =   %13.7f  ",OM_sm);
	fprintf(f2,"\n   	                    Рабочая длина ролика в /см/ RL_sm =   %13.7f  ",RL_sm);
	///
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	// Определить отношение диаметра ролика к диаметру орбиты по которой бегают центры роликов
	Y = Dw/DM;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///
	fprintf(f2,"\n   	                                           Y = Dw/DM =   %13.7f  ",Y);
	///
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	
	// Определить динамическую грузоподъёмность дорожки качения наружного кольца
	C_nk = 32540.0 * step(1+Y, 29.0/27.0) / step(1-Y, 1.0/4.0) * step(Dw_sm, 29.0/27.0) * step(Y,2.0/9.0) * step(RL_sm,7.0/9.0) * step( (double) Z,-1.0/4.0 );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///
	fprintf(f2,"\n Динамическая грузоподъёмность дорожки качения наружного кольца C_nk =  %13.7f  ",C_nk);
	///
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	// Определить суммарную эквивалентную нагрузку для дорожки качения наружного кольца
	Pe_nk = 0.0;

	for (k=0; k<Z; k++)
	{
		// Определение эквивалентной нагрузки на ролик № k
		Sq = 0.0;						

		for (i=0; i<N; i++)
		{
			Sigma_N_sm = (*(SIGO+k*N+i)) * 1000.0;		// Среднее давление на участке № i  ролика № k   перевести из кг/мм2  в   Н/см2
			B_sm	   = (*(Bn+k*N+i)) / 10.0;		// Ширина участка в см.
			Q_ki	   = Sigma_N_sm * B_sm;			// Погонная нагрузка на участке № i  ролика № k в Н/см	
			Sq 	   = Sq + step(Q_ki, 9.0/2.0) * OM_sm;	// Наращивание эквивалентной нагрузка для ролика № k
		}

		Pke 	= step(RL_sm,7.0/9.0) * step(Sq,2.0/9.0);	// Определить эквивалентную нагрузку на ролик № k		
		Pe_nk 	= Pe_nk + step(Pke,9.0/2.0);			// Нарастить суммарную эквивалентную нагрузку для дорожки качения наружного кольца	

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		///
		fprintf(f2,"\n Эквивалентная нагрузка на ролик № %3d   Pke =  %13.7f ", k, Pke);
		///
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}

	Pe_nk = step(Pe_nk/Z, 2.0/9.0);					// Получить суммарную эквивалентную нагрузку для дорожки качения наружного кольца	

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///
	fprintf(f2,"\n Суммарная эквивалентная нагрузка для дорожки качения наружного кольца Pe_nk =  %13.7f  ",Pe_nk);
	///
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Определить долговечность наружного кольца в миллионах оборотов
	L_nk = step(C_nk/Pe_nk, 10.0/3.0);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///
	fprintf(f2,"\n Долговечность дорожки качения наружного кольца в миллионах оборотов  L_nk =  %13.7f  ",L_nk);
	///
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Определить динамическую грузоподъёмность дорожки качения внутреннего кольца
	C_vk = 32540.0 * step(1-Y, 29.0/27.0) / step(1+Y, 1.0/4.0) * step(Dw_sm, 29.0/27.0) * step(Y,2.0/9.0) * step(RL_sm,7.0/9.0) * step( (double) Z,-1.0/4.0 );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///
	fprintf(f2,"\n Динамическая грузоподъёмность дорожки качения внутреннего кольца C_vk =  %13.7f  ",C_vk);
	///
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Определить суммарную эквивалентную нагрузку для дорожки качения внутреннего кольца	
	Pe_vk = 0.0;

	for (k=0; k<Z; k++)
	{
		// Определение эквивалентной нагрузки на ролик № k
		Sq = 0.0;						

		for (i=0; i<N; i++)
		{
			Sigma_N_sm = (*(SIGI+k*N+i)) * 1000.0;		// Среднее давление на участке № i  ролика № k   перевести из кг/мм2  в   Н/см2
			B_sm	   = (*(Bv+k*N+i)) / 10.0;		// Ширина участка в см.
			Q_ki	   = Sigma_N_sm * B_sm;			// Погонная нагрузка на участке № i  ролика № k в Н/см	
			Sq 	   = Sq + step(Q_ki, 9.0/2.0) * OM_sm;	// Наращивание эквивалентной нагрузка для ролика № k
		}

		Pke 	= step(RL_sm,7.0/9.0) * step(Sq,2.0/9.0);	// Определить эквивалентную нагрузку на ролик № k		
		Pe_vk 	= Pe_vk + step(Pke,10.0/3.0);			// Нарастить суммарную эквивалентную нагрузку для дорожки качения наружного кольца	

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		///
		fprintf(f2,"\n Эквивалентная нагрузка на ролик № %3d   Pke =  %13.7f ", k, Pke);
		///
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	
	Pe_vk = step(Pe_vk/Z, 0.3);					// Получить суммарную эквивалентную нагрузку для дорожки качения наружного кольца	

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///
	fprintf(f2,"\n Суммарная эквивалентная нагрузка для дорожки качения внутреннего кольца Pe_vk =  %13.7f  ",Pe_vk);
	///
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Определить долговечность внутреннего кольца в миллионах оборотов
	L_vk = step(C_vk/Pe_vk, 10.0/3.0);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///
	fprintf(f2,"\n Долговечность дорожки качения внутреннего кольца в миллионах оборотов  L_vk =  %13.7f  ",L_vk);
	///
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Определить долговечность подшипника в миллионах оборотов
	L_pod = step(step(L_vk, -9.0/8.0) + step(L_nk, -9.0/8.0), -8.0/9.0);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///
	fprintf(f2,"\n Долговечность подшипника в миллионах оборотов  L_pod =  %13.7f  ",L_pod);
	fprintf(f2,"\n	*                                                                                                                               * ");	
	fprintf(f2,"\n	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");	
	///
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	// Выход из функции с возвратом найденной долговечности подшипника  в миллионах оборотов
	return L_pod;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	РАСЧЁТ ДОЛГОВЕЧНОСТИ ПОДШИПНИКА ПО МЕТОДИКЕ БЕЙЗЕЛЬМАМА 
//
//

double DOLG1_BEISELMAN()
{
	int	j;	// Счётчик роликов
 	double Qei;	// Эквивалентная нагрузка действующая на дорожку качения внутреннего кольца
 	double Qeo;	// Эквивалентная нагрузка действующая на дорожку качения наружного кольца
	double Y;	// Отношение диаметра ролика к диаметру орбиты по которой бегают центры роликов
	double Qci;	// Динамическая грузоподъёмность дорожки качения внутреннего кольца
	double Qco;	// Динамическая грузоподъёмность дорожки качения наружного кольца
	double Li;	// Долговечность внутреннего кольца в миллионах оборотов
	double Lo;	// Долговечность наружного кольца в миллионах оборотов	
	double L_pod;	// Долговечность подшипника в миллионах оборотов
	double lambda;	// Множетель ЛЯМБДА 


	// Задание лямбда
	lambda = 0.61;	

	// Определить эквивалентную нагрузку действующую на дорожку качения внутреннего кольца
	Qei = 0.0;
	for (j=0; j<Z; j++) Qei=Qei+step(*(QJ+j), 4.0); 
	Qei = Qei/Z;
	Qei = step(Qei, 1.0/4.0);

	// Определить эквивалентную нагрузку действующую на дорожку качения наружного кольца
	Qeo = 0.0;
	for (j=0; j<Z; j++) Qeo=Qeo+step(*(QHU+j), 4.5);	
	Qeo = Qeo/Z; 
	Qeo = step(Qeo, 1.0/4.5);

	// Определить отношение диаметра ролика к диаметру орбиты по которой бегают центры роликов
	Y = Dw/DM;

	// Определить динамическую грузоподъёмность дорожки качения внутреннего кольца
	Qci = 56 * lambda * step((1-Y), 29.0/27.0) / step((1+Y), 1.0/4.0) * step(Y, 2.0/9.0) * step(Dw, 29.0/27.0) * step(RL, 7.0/8.0) * step((double) Z, (-1.0/4.0));

	// Определить динамическую грузоподъёмность дорожки качения наружного кольца
	Qco = 56 * lambda * step((1+Y), 29.0/27.0) / step((1-Y), 1.0/4.0) * step(Y, 2.0/9.0) * step(Dw, 29.0/27.0) * step(RL, 7.0/8.0) * step((double) Z, (-1.0/4.0));

	// Определить долговечность внутреннего кольца в миллионах оборотов
	Li = step(Qci/Qei, 4.0);	

	// Определить долговечность наружного кольца в миллионах оборотов
	Lo = step(Qco/Qeo, 4.0);

	// Определить долговечность подшипника  в миллионах оборотов
	L_pod = step(step(Li,-1.11)+step(Lo,-1.11),-0.9);

	

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///
	fprintf(f2,"\n	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");	
	fprintf(f2,"\n	*                                                                                                                               * ");	
	fprintf(f2,"\n	 						Сообщения из DOLG1_BEISELMAN 	        	  ");
	fprintf(f2,"\n	                                                                                		  ");	
	fprintf(f2,"\n	                                                                                		  ");	
	fprintf(f2,"\n   Эквивалентная нагрузка действующая на дорожку качения внутреннего кольца     Qei =   %13.7f  ",Qei);
	fprintf(f2,"\n   Эквивалентная нагрузка действующая на дорожку качения наружного   кольца     Qeo =   %13.7f  ",Qeo);
	fprintf(f2,"\n	                                                                                		  ");	
	fprintf(f2,"\n   	 Динамическая грузоподъёмность дорожки качения внутреннего кольца     Qci =   %13.7f  ",Qci);
	fprintf(f2,"\n   	 Динамическая грузоподъёмность дорожки качения наружного кольца       Qco =   %13.7f  ",Qco);
	fprintf(f2,"\n	                                                                                		  ");	
	fprintf(f2,"\n   	 				  Долговечноть внутреннего кольца      Li =   %13.7f  ",Li);
	fprintf(f2,"\n   	   				    Долговечноть наружного кольца      Lo =   %13.7f  ",Lo);
	fprintf(f2,"\n   	   					  Долговечноть подшипника   L_pod =   %13.7f  ",L_pod);
	fprintf(f2,"\n	                                                                                		");	
	fprintf(f2,"\n   	   					       Количество роликов       Z =   %3d  ",Z);
	fprintf(f2,"\n	*                                                                                                                               * ");	
	fprintf(f2,"\n	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");	
	///
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	// Выход из функции с возвратом найденной долговечности подшипника  в миллионах оборотов
	return L_pod;
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///  РЕШЕНИЕ УРАВНЕНИЯ РАВНОВЕСИЯ СИЛ ДЕЙСТВУЮЩИХ НА ВНУТРЕННЕЕ КОЛЬЦО.							//
///	ОПРЕДЕЛЕНИЕ РАСПРЕДЕЛЕНИЯ НАПРЯЖЕНИЙ В КОНТАКТЕ САМОГО НАГРУЖЕННОГО РОЛИКА С ВНУТРЕННИМ КОЛЬЦОМ.		//
///	ОПРЕДЕЛЕНИЕ МАКСИМАЛЬНОГО НАПРЯЖЕНИЯ В КОНТАКТЕ САМОГО НАГРУЖЕННОГО РОЛИКА С ВНУТРЕННИМ КОЛЬЦОМ. 		//
///
///
///	Входные параметры : Param_X - Указатель на массив параметров целевой функции
///
///

double rol_max_napr( double * Param_X )
{

double br;			/// Вспомогательная переменная используемая при расчете радиуса кривизны бомбины ролика
double DR;			/// Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
double bmo;			/// Суммарный момент действующий со стороны роликов на внутреннее кольцо
double PMZ;			/// Начальное приближение нагрузки на нижний, самый нагруженный ролик.
double qrk;			/// Погонная нагрузка в контакте ролика с внутренним кольцом.
double DFI;			/// Начальное приближение сближения ролика с внутренним кольцом.
double FPZ;			/// Допустимая относительная погрешность при решении уравнения равновесия внутреннего кольца.
double h;			/// Величина малого преращения по переменной "DR", используется при нахождении производной.
double FRAZ;			/// Невязка уравнения равновесия внутреннего кольца.
double FRAZ_0;			/// Невязка уравнения равновесия внутреннего кольца в точке 0.
double DR_0;			/// Сближение колец в точке 0.
double FRAZ_1;			/// Невязка уравнения равновесия внутреннего кольца в точке 1.
double DR_1;			/// Сближение колец в точке 1.
double FRAZ_2;			/// Невязка уравнения равновесия внутреннего кольца в точке 2.
double DR_2;			/// Сближение колец в точке 2.
double FRAZ_m1;			/// Невязка уравнения равновесия внутреннего кольца в точке -1.
double DR_m1;			/// Сближение колец в точке -1.
double FRAZ_m2;			/// Невязка уравнения равновесия внутреннего кольца в точке -2.
double DR_m2;			/// Сближение колец в точке -2.
double dFRAZ_dDR;		/// Производная невязки уравнения равновесия внутреннего кольца по переменной "DR" (величина сближения колец).
int j,i,k;			/// Счетчики цикла
double SIGO_max1;		/// Напряжение на участке в контакте ролика с наружным кольцом.
double SIGI_max1;		/// Напряжение на участке в контакте ролика с внутренним кольцом.
double err_Q1;			/// Отклонение суммарного усилия в контакте полученного для найденного распределения напряжений от усилия в контакте ролика с внутренним кольцом. 
double err_Q2;			/// Отклонение суммарного усилия в контакте полученного для найденного распределения напряжений от усилия в контакте ролика с наружным кольцом. 
double eps1;			/// Допустимая погрешность отклонения усилия в контакте от усилия в контакте рассчитанного подпрограммой "napr_usil_kontakt()".
double S0,S1,S2;		/// Координаты точек в которых профиль Лундберга апроксимируется окружностями
double P0,P1,P2;		/// Значение функции профиля Лундберга в точках где происходит апроксимация профиля Лундберга окружностями
int kol_okr;			/// Количество окружностей проходящих через две точки на профиле Лундберга 
double di;			/// Дискриминант квадратного уравнения используемого для нахождения радиуса 2ой окружности апроксимирующей профиль Лундберга на участке S_d1_d2 - Lw/2
double otn_err;			/// Относительная ошибка, при нахождении распределения напряжений в контакте ролика с кольцами.
double max_pol_shirina;		/// Максимальная полуширина области контакта
double def_i_o, def_i_j;	/// Деформация на участке контакта ролика с кольцом	
double xi;			/// Плечо участка ролика (растояние от участка до середины ролика).
double abs_xi;			/// Плечо участка ролика взятое по абсалютной величине.
double ci;			/// Уменьшение профиля ролика
double DL_b2;			/// Длина бомбины № 2 (с одной стороны от центра ролика) /мм/
double Lx1, Lx2, Lx3;		/// Вспомогательная переменная
double X_b1_b2, Y_b1_b2;	/// Координаты точки сопряжения бомбины № 1 и бомбины № 2
double X_b2_f, Y_b2_f;		/// Координаты точки сопряжения бомбины № 2 и фаски.
double Xb2_c1, Yb2_c1;		/// Координаты для первого варианта центра бомбины № 2
double Xb2_c2, Yb2_c2;		/// Координаты для второго варианта центра бомбины № 2
double Xb2f, Yb2f;		/// Координаты точки сопряжения бомбины № 2 и фаски
double Xf_c1, Yf_c1;		/// Координаты для первого варианта центра фаски 
double Xf_c2, Yf_c2;		/// Координаты для второго варианта центра фаски 
double Y_cel_func;		/// Максимальное напряжение в контакте самого нагруженного ролика с внутренним кольцом. Является результатом работы функции "rol_max_napr".

double polushirina_tek_uch;			/// Полуширина текущего участка области контакта
double a_k, b_k, c_k;				/// Коэффициенты квадратного уравнения используемого для нахождения радиуса 2ой окружности апроксимирующей профиль Лундберга на участке S_d1_d2 - Lw/2
double RAST0, RAST01, RAST02;			/// Коэффициент влияния участка самого на себя.
double Q1,Q2;					/// Суммарное усилие в контакте для найденного распределения напряжений в контакте.
double Xc1_1, Yc1_1, Xc1_2, Yc1_2;		/// Координаты центров окружностей проходящих через две точки на профиле Лундберга
double max_shir_polos_kont_rol_vnut_kolcom;	/// Максимальная ширина контакта ролика с внутренним кольцом.
double max_shir_polos_kont_rol_narug_kolcom;	/// Максимальная ширина контакта ролика с наружным кольцом.
int k_nagr_u;					/// Количество нагруженных участков на самом нагруженном сеченнии контакта (вспомогательная переменная)
double Param_Log_1, Param_Log_2;		/// Параметры логарифмической формулы описывающий профиль ролика.


int 	nom_it_w_sep;		/// Cчетчик итераций цикла поиска угловой скорости сепаратора
double 	YY;			/// Отношение диаметра ролика к среднему диаметру подшипника

double 	Qpog;			/// Погонная нагрузка в кг/мм на участке контакта
double 	sigma_i_o;		/// Нормальное напряжение в кг/мм2 в центре сечения № i в контакте 
double 	sigma_i_j;		/// Напряжение в кг/мм2 на участках контакта
double 	Sum_Q1;			/// Усилие в контакте ролика с дорожкой качения как сумма произведений напряжений на участках умноженных на площади участков. 
double 	k_q;			/// Коэффициент на который происходит умножение для двухмерного массива напряжений в контакте ролика с дорожкой качения кольца
double 	max_shirina_v;		/// Вспомогательная переменная используется для нахрждения максимальной ширины полосы контакта ролика с внутренним кольцом
double 	max_shirina_n;		/// Вспомогательная переменная используется для нахрждения максимальной ширины полосы контакта ролика с наружным кольцом
double 	W_sep;			/// Угловая скорость сепаратора в радианах/секунда
double 	W_w;			/// Угловая скорость вращения ролика в радиан/секунда 

double 	Sum_N_hdr_w;		/// Суммарная потеря мощности на преодоление гидромеханического сопротивления всех роликов в ваттах
double 	N_hdr_sep;		/// Потеря мощности на преодоление гидромеханического сопротивления сепаратора
double 	N_hdr_pod;		/// Итоговая потеря мощности на преодоление гидромеханического сопротивления всего подшипника
double 	Proskals_sep_proc;	/// Процент проскальзывания сепаратора

double 	W_sep_1;		/// Угловая скорость вращения сепаратора полученная на предыдущей итнрации
double 	otn_otkl_w_sep;		/// Относительное отклонение угловой скорости сепаратора на текущей и предыдущей итерации

double 	L_pod;			/// Долговечность подшипника в миллионах оборотов
double 	L_pod_h;		/// Долговечность подшипника в часах

double 	L_BAT_pod;		/// Долговечность подшипника в миллионах оборотов вычисленная по методике  С.В. Батенкова
double 	L_BAT_pod_h;		/// Долговечность подшипника в часах вычисленная по методике  С.В. Батенкова

double 	L_BEISELMAN_pod;	/// Долговечность подшипника в миллионах оборотов вычисленная по методике Бейзельмана
double 	L_BEISELMAN_pod_h;	/// Долговечность подшипника в часах вычисленная по методике Бейзельмана


double 	k_tren_skol;		/// Коэффициент трения скольжения
double 	proizved1;		/// Вспомагательная переменная служащая для хранения произведения при вычислении коэффициентов полинома Лагранжа

long 	rezult_mnk;		/// Код результата возвращаемого функцией "mnk"	


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
double	Energ_kont_rol_nk;	/// Суммарная потенциальная энергия в контакте ролика с дорожкой качения наружного кольца
double	Energ_kont_rol_vk;	/// Суммарная потенциальная энергия в контакте ролика с дорожкой качения внутреннего кольца		
double  dLcr;			/// Определить длину пути который проходит центр ролика при перемещении из одной угловой позиции в другую.
///
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// Нарастить счетчик вычислений целевой функции
kol_wych_Y_cel++;

// Задание массива коэффициентов для пересчета расстояния участка от самого до себя 
k_rast0[0]= 1;
k_rast0[1]= 1.9;		
k_rast0[2]= 2.9;		

// Считать параметры целевой функции и присвоить их рабочим переменным. 
D1H	= *(Param_X+0);		// Внутренний диаметр подшипника в мм.
DT	= *(Param_X+1);		// Наружный диаметр подшипника в мм.
Pm	= *(Param_X+2);		// Номинальный радиальный зазор в подшипнике в мм.

Priz_P_rab = (int) *(Param_X+3);// Признак расчета радиального зазора в рабочих условиях (1-да,0-нет). 

Z	= (int) *(Param_X+4);	// Количество роликов
Dw	= *(Param_X+5);		// Диаметр ролика в мм.	
Lw	= *(Param_X+6);		// Полная длина ролика в мм.		

vid_profil = (int) *(Param_X+7);// Вид профиля ролика.

switch (vid_profil)
{
	case 1:
	{
		// Для профиля № 1 (цилиндрический с бомбиной и фаской).
		//
		SL 		= *(Param_X+8);			// Длина цилиндрической части ролика в мм.
		PBO		= *(Param_X+9);			// Свес бомбины в мм.
		dFx		= *(Param_X+10);		// Длина фаски  в мм.
		dFy		= *(Param_X+11);		// Высота фаски в мм.
		Priz_R_faska	= (int) *(Param_X+12); 		// Способ получения радиуса фаски (0-расчет, 1-задание в исходных данных).
		Rf           	= *(Param_X+13);		// Радиус фаски в мм.
		break;
	}

	case 2:
	{
		// Для профиля № 2 (Лундберга).
		//
		Q_Lund 	= *(Param_X+14);		// Усилие в контакте в кгс.
		a_Lund 	= *(Param_X+15);		// Полуширина полосы контакта в мм.
		break;
	}

	case 3:
	{
		// Для профиля № 3 (апроксимация профиля Лундберга двумя окружностями).
		// 
		Q_Lund 			= *(Param_X+16);	// Усилие в контакте в кгс.
		a_Lund 			= *(Param_X+17);	// Полуширина полосы контакта в мм.
		koeff_toch_soprag	= *(Param_X+18);	// Коэффициент задающий точку сопряжения дуг 2х окружностей апроксимирующих профиль Лундберга.
		break;
	}

	case 4:
	{
		// Для профиля № 4 (цилиндрический с двумя бомбинами и фаской).
		// 
		SL	= *(Param_X+19);	// Длина цилиндрической части ролика в мм.
		DL_b1	= *(Param_X+20);	// Длина бомбины № 1 в мм.
		PBO1	= *(Param_X+21);	// Свес бомбины № 1 (относительно цилиндрической части) в мм.
		SDW_B2  = *(Param_X+22); 	// Сдвиг центра кривизны бомбины № 2 (относительно вертикальной средней линии ролика) в мм.
		PBO2	= *(Param_X+23);	// Свес бомбины № 2 (относительно бомбины № 1) в мм.
		dFx     = *(Param_X+24);	// Длина фаски в мм.
		dFy     = *(Param_X+25);	// Высота фаски в мм.
		Rf      = *(Param_X+26);	// Радиус фаски в мм.
		break;
	}
}

Rvk   = *(Param_X+27);		// Радиус дорожки качения внутреннего кольца без учета отклонения от идеальной формы в мм.
APO   = *(Param_X+28);		// Большая полуось эллипса профиля дорожки качения внутреннего кольца в мм.
BPO   = *(Param_X+29);		// Малая полуось эллипса профиля дорожки качения внутреннего кольца в мм.
FTT   = *(Param_X+30);		// Угол между малой полуосью эллипса дорожки качения внутреннего кольца и радиальной нагрузкой в мин.

Dco = *(Param_X+31);		// Диаметр наружной цилиндрической поверхности сепаратора в мм.
Dci = *(Param_X+32);		// Диаметр внутренней цилиндрической поверхности сепаратора в мм.
Lc  = *(Param_X+33);		// Ширина сепаратора в мм.	
Dcb = *(Param_X+34);		// Диаметр центрирующих поясков сепаратора в мм 
Lcb = *(Param_X+35);		// Суммарная ширина обоих центрирующих поясков сепаратора в мм

Okno_sep_H2 	= *(Param_X+36);	// Длина окна сепаратора в мм.
Okno_sep_H1 	= *(Param_X+37);	// Ширина окна сепаратора в мм.	
Dc		= *(Param_X+38);	// Диаметр в мм поверхности на дорожке качения кольца ( наружного или внутреннего) которая центрирует сепаратор 
Dbort		= *(Param_X+39); 	// Диаметр бортика в мм.

DZ    = *(Param_X+40);	// Внутренний диаметр полого вала в мм.
DDZ   = *(Param_X+41);	// Наружный диаметр корпуса в мм.

RO_w  = *(Param_X+42);	// Плотность материала ролика в граммах/см3
RO_vk = *(Param_X+43);	// Плотность материала внутреннего кольца в граммах/см3
RO_nk = *(Param_X+44);	// Плотность материала наружного кольца в граммах/см3
RO_sep= *(Param_X+45);	// Плотность материала сепаратора в граммах/см3
RO_v  = *(Param_X+46);	// Плотность материала вала в граммах/см3
RO_k  = *(Param_X+47);	// Плотность материала корпуса в граммах/см3

E_w   = *(Param_X+48);	// Модуль упругости материала ролика в кг/мм2
E_vk  = *(Param_X+49);	// Модуль упругости материала внутреннего кольца в кг/мм2
E_nk  = *(Param_X+50);	// Модуль упругости материала наружного кольца в кг/мм2
E_sep = *(Param_X+51);	// Модуль упругости материала сепаратора в кг/мм2
E_v   = *(Param_X+52);	// Модуль упругости материала вала в кг/мм2
E_k   = *(Param_X+53);	// Модуль упругости материала корпуса в кг/мм2

EP_w  = *(Param_X+54);	// Коэффициент Пуассона материала ролика
EP_vk =	*(Param_X+55);	// Коэффициент Пуассона материала внутреннего кольца
EP_nk = *(Param_X+56);	// Коэффициент Пуассона материала наружного кольца
EP_sep= *(Param_X+57);	// Коэффициент Пуассона материала сепаратора
EP_v  = *(Param_X+58);	// Коэффициент Пуассона материала вала.
EP_k  = *(Param_X+59);	// Коэффициент Пуассона материала корпуса

At_r  = *(Param_X+60);	// Коэффициент температурного расширения материала ролика в 1/градус	
At_vk = *(Param_X+61);	// Коэффициент температурного расширения материала внутреннего кольца в 1/градус	
At_nk = *(Param_X+62);	// Коэффициент температурного расширения материала наружного кольца в 1/градус	

At_sep= *(Param_X+63);	// Коэффициент температурного расширения материала сепаратора в 1/градус
At_v  = *(Param_X+64);	// Коэффициент температурного расширения материала вала в 1/градус	
At_k  = *(Param_X+65);	// Коэффициент температурного расширения материала корпуса в 1/градус	

HB    = *(Param_X+66);	// Натяг в соединении вал-подшипник при монтаже в мм
HK    = *(Param_X+67);	// Натяг в соединении подшипник-корпус при монтаже в мм
RZB   = *(Param_X+68);	// Чистота обработки поверхности вала в мм
RZK   = *(Param_X+69);	// Чистота обработки поверхности корпуса в мм
B_N   = *(Param_X+70);	// Частота вращения внутреннего кольца и вала в оборотах/минуту
N_N   = *(Param_X+71);	// Частота вращения наружного кольца в оборотах/минуту

FR    = *(Param_X+72);	// Радиальная нагрузка в кгс.
FA    = *(Param_X+73);	// Осевая нагрузка в кгс

TT    = *(Param_X+74);	// Угол перекоса дорожки качения внутреннего кольца в минутах.
Doly  = *(Param_X+75);	// Объемная доля масла в масловоздушной смеси

T_w   = *(Param_X+76);	// Рабочая температура ролика в градусах Цельсия.
T_vk  = *(Param_X+77);	// Рабочая температура внутреннего кольца в градусах Цельсия.
T_nk  = *(Param_X+78);	// Рабочая температура наружного кольца в градусах Цельсия.
T_v   = *(Param_X+79);	// Рабочая температура вала в градусах Цельсия.
T_k   = *(Param_X+80);	// Рабочая температура корпуса в градусах Цельсия.

T_maslo_vh	= *(Param_X+81);	// Температура масла на входе в подшипник в градусах Цельсия
Tm		= *(Param_X+82);	// Температура монтажа подшипника.

Maslo 		= (int) *(Param_X+83);	// Номер масла
vid_aprox 	= (int) *(Param_X+84);	// Вид апроксимации таблицы зависимости вязкости смазки от температуры			

N0		= *(Param_X+85);	// Динамическая вязкость в кг*c/мм2 при нулевом давлении и начальной температуре (используется для определения вязкости в формуле Роландса).
RO1_maslo	= *(Param_X+86);	// Плотность масла в кг/мм3
T0		= *(Param_X+87);	// Температура T0 в градусах Кельвина при которой задана дин.вязкость масла
Z1		= *(Param_X+88);	// Пъезовязкостный параметр (используется для определения вязкости в формуле Роландса)
Gsdw		= *(Param_X+89);	// Модуль сдвига смазки в кг/мм2
SS0		= *(Param_X+90);	// Термовязкостный параметр (используется для определения вязкости в формуле Роландса)
Pezo_koeff	= *(Param_X+91);	// Пъезокоэффициент вязкости смазки
Lambda		= *(Param_X+92);	// Коэффициент применяемый для расчёта долговечности по контактному напряжению

N	   		= (int) *(Param_X+93);	// Количество участков на которые разбивается полная длина ролика.
priz_sliyan_uch		= (int) *(Param_X+94);	// Признак вида сетки ( 1 - неравномерная сетка со слиянием участков , 0 - равномерная сетка без слияния участков)  
Priz_napr_kray_effect	= (int) *(Param_X+95);	// Признак расчета концентраторов напряжений на краю ролика ( 1 - да,  0 - нет )
Priz_profil_nk		= (int) *(Param_X+96);	// Признак чтения профиля дорожки качения наружного кольца из файла PROF_NK.DAT

koeff_shag_1 = *(Param_X+97);	// Коэффициент умножения шага при решении методом Ньютона уравнений равновесия роликов	
koeff_shag_2 = *(Param_X+98);	// Коэффициент умножения шага при решении методом Ньютона уравнений равновесий внутреннего кольца.
koeff_shag_3 = *(Param_X+99);	// Коэффициент умножения шага при решении методом Ньютона урввнений во время поиска распределения напряжений в контакте ролика с кольцом.


// Выдать на экран сообщение об очередном вычислении целевой функции, список варируемых параметров, границ изменения варируемых параметров и шага.
printf("\n\n  								                                        ");
printf("\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
printf("\n  Wychislenie celevoi funkcii N %3d ",kol_wych_Y_cel );
for (i=0; i<Kol_Param; i++) if (priz_var_param[i]) printf("\n x[%2d]=%9.7f (%9.7f; %9.7f) h=%9.7f (x_max-x_min)/h=%9.7f ", i, *(Param_X+i), xx_min[i], xx_max[i], hh[i], fabs((xx_max[i]-xx_min[i])/hh[i])  );

// Записать в файл протокола сообщение об очередном вычислении целевой функции, список варируемых параметров, границ изменения варируемых параметров и шага.
fprintf(f3,"\n\n  								                                        ");
fprintf(f3,"\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
fprintf(f3,"\n  Вычисление целевой функции N %3d ",kol_wych_Y_cel );
for (i=0; i<Kol_Param; i++) if (priz_var_param[i]) fprintf(f3,"\n x[%2d]=%9.7f (%9.7f; %9.7f) h=%9.7f (x_max-x_min)/h=%9.7f ", i, *(Param_X+i), xx_min[i], xx_max[i], hh[i], fabs((xx_max[i]-xx_min[i])/hh[i])  );

fprintf(f2,"\n                                                                                     ");
fprintf(f2,"\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
fprintf(f2,"\n                    ВЫЧИСЛЕНИЕ ЦЕЛЕВОЙ ФУНКЦИИ № %3d                  ",kol_wych_Y_cel);
fprintf(f2,"\n                                                                                     ");
fprintf(f2,"\n                                                                        		   ");
fprintf(f2,"\n  РОЛИКОВЫЙ ПОДШИПНИК : "); 
fprintf(f2,"\n    Внутренний диаметр .........................................../мм/  %13.7f  ",D1H); 
fprintf(f2,"\n    Наружный диаметр ............................................./мм/  %13.7f  ",DT);
fprintf(f2,"\n    Номинальный радиальный зазор ................................./мм/  %13.7f  ",Pm);
fprintf(f2,"\n    Выполнять расчет радиального зазора в рабочих условиях (1-да,0-нет) %3d    ",Priz_P_rab);
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  POЛИKИ                                                                       ");
fprintf(f2,"\n    Количество ....................................................     %3d    ",Z);
fprintf(f2,"\n    Диаметр ....................................................../мм/  %13.7f  ",Dw);
fprintf(f2,"\n    Полная длина ................................................./мм/  %13.7f  ",Lw);
fprintf(f2,"\n                                                                               ");


switch ( vid_profil )
{
	case 1:
	{ 	// Ролик с профилем цилиндрическим с бомбиной и фаской.
		//	
		fprintf(f2,"\n  ДЛЯ ЦИЛИНДРИЧЕСКОГО С БОМБИНОЙ И ФАСКОЙ               ( 1 )                  ");
		fprintf(f2,"\n    Длина цилиндрической части ролика............................./мм/  %13.7f  ",SL);
		fprintf(f2,"\n    Свес бомбины ................................................./мм/  %13.8f  ",PBO);
		fprintf(f2,"\n    Длина фаски ................................................../мм/  %13.7f  ",dFx);
		fprintf(f2,"\n    Высота фаски ................................................./мм/  %13.7f  ",dFy);

		if (Priz_R_faska == 0)	
		{	
			fprintf(f2,"\n Радиус фаски вычисляется в программе                                      ");  
		}
		else
		{
			fprintf(f2,"\n    Радиус фаски задается в исходных данных                                ");  
			fprintf(f2,"\n    Радиус фаски ................................................./мм/  %13.7f  ",Rf);
		}

		fprintf(f2,"\n                                                                               ");
		break;
	}

	case 2:
	{ 	// Ролик с профилем Лундберга 
		//	
		fprintf(f2,"\n  ДЛЯ ПРОФИЛЯ ЛУНДБЕРГА                                 ( 2 )                  ");
		fprintf(f2,"\n    Параметр профиля усилие в контакте ........................../кгс/  %13.7f  ",Q_Lund); 
		fprintf(f2,"\n    Параметр профиля полуширина полосы контакта ................../мм/  %13.7f  ",a_Lund);
		fprintf(f2,"\n                                                                               ");
		break;
	}

	case 3:
	{  	// Ролик с профилем апроксимация профиля Лундберга двумя окружностями
		//
		fprintf(f2,"\n  ДЛЯ АПРОКСИМАЦИИ ПРОФИЛЯ ЛУНДБЕРГА ДВУМЯ ОКРУЖНОСТЯМИ ( 3 )                  ");
		fprintf(f2,"\n    Параметр профиля усилие в контакте ........................../кгс/  %13.7f  ",Q_Lund);
		fprintf(f2,"\n    Параметр профиля полуширина полосы контакта ................../мм/  %13.7f  ",a_Lund);
		fprintf(f2,"\n    Коэфф.задающий точку сопряжения дуг 2х окружн.апрокс.профиль .....  %13.7f  ",koeff_toch_soprag); 
		fprintf(f2,"\n                                                                               ");
		break;
	}

	case 4:
	{  	// Ролик с профилем цилиндрическим с двумя бомбинами и фаской
		//
		fprintf(f2,"\n  ДЛЯ ЦИЛИНДРИЧЕСКОГО С ДВУМЯ БОМБИНАМИ И ФАСКОЙ        ( 4 )                  ");     
		fprintf(f2,"\n    Длина цилиндрической части ролика ............................/мм/  %13.7f  ",SL);
		fprintf(f2,"\n    Длина бомбины № 1 ............................................/мм/  %13.7f  ",DL_b1);
		fprintf(f2,"\n    Свес бомбины № 1 (относительно цилиндрической части) ........./мм/  %13.7f  ",PBO1);
		fprintf(f2,"\n    Сдвиг центра кривизны бомб.№2 относ.верт.средней линии ролика /мм/  %13.7f  ",SDW_B2); 
		fprintf(f2,"\n    Свес бомбины № 2 (относительно бомбины № 1) ................../мм/  %13.7f  ",PBO2);
		fprintf(f2,"\n    Длина фаски ................................................../мм/  %13.7f  ",dFx);
		fprintf(f2,"\n    Высота фаски ................................................./мм/  %13.7f  ",dFy);
		fprintf(f2,"\n    Радиус фаски ................................................./мм/  %13.7f  ",Rf);
		fprintf(f2,"\n                                                                               ");
		break;
	}
}	

fprintf(f2,"\n  ДОРОЖКА КАЧЕНИЯ ВНУТРЕННЕГО КОЛЬЦА                                           ");
fprintf(f2,"\n    Радиус без учета отклонения от идеальной формы  ............../мм/  %13.7f  ",Rvk);
fprintf(f2,"\n    Большая полуось эллипса профиля дорожки качения внутр.кольца ./мм/  %13.7f  ",APO);
fprintf(f2,"\n    Малая полуось эллипса профиля дорожки качения внутр.кольца .../мм/  %13.7f  ",BPO);
fprintf(f2,"\n    Угол между малой п-осью эллипса дорожки ВК и рад.нагрузкой ../мин/  %13.7f  ",FTT); 
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  СЕПАРАТОР                                                                    ");
fprintf(f2,"\n    Диаметр наружной цилиндрической поверхности ................./мм/  %9.3f  ", Dco); 
fprintf(f2,"\n    Диаметр внутренней цилиндрической поверхности .............../мм/  %9.3f  ", Dci); 
fprintf(f2,"\n    Ширина ....................................................../мм/  %9.3f  ", Lc); 
fprintf(f2,"\n    Диаметр центрирующих поясков ................................/мм/  %9.3f  ", Dcb); 
fprintf(f2,"\n    Ширина обоих центрирующих поясков .........................../мм/  %9.3f  ", Lcb); 
fprintf(f2,"\n    Длина окна ................................................../мм/  %9.3f  ", Okno_sep_H2); 
fprintf(f2,"\n    Ширина окна ................................................./мм/  %9.3f  ", Okno_sep_H1); 
fprintf(f2,"\n    Диаметр поверх.кольца(нар,внут) которая центрирует сепаратор./мм/  %9.3f  ", Dc); 
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  БОРТИК                                                                       ");
fprintf(f2,"\n    Диаметр ....................................................../мм/  %9.3f  ", Dbort); 
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  ВАЛ                                                                          ");
fprintf(f2,"\n    Внутренний диаметр .......................................... /мм/  %13.7f  ",DZ);
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  КОРПУС                                                                       ");
fprintf(f2,"\n    Наружный диаметр ............................................ /мм/  %13.7f  ",DDZ);
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  ХАРАКТЕРИСТИКИ МАТЕРИАЛОВ                                                    ");
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n    Плотность                                                                  ");
fprintf(f2,"\n        Ролик ........................................... /грамм/cм3/   %13.7f  ",RO_w); 
fprintf(f2,"\n        Внутреннее кольцо ............................... /грамм/cм3/   %13.7f  ",RO_vk);
fprintf(f2,"\n        Наружное кольцо ................................. /грамм/cм3/   %13.7f  ",RO_nk); 
fprintf(f2,"\n        Сепаратор ....................................... /грамм/cм3/   %9.3f  ",RO_sep);	
fprintf(f2,"\n        Вал ............................................. /грамм/cм3/   %13.7f  ",RO_v);
fprintf(f2,"\n        Корпус .......................................... /грамм/cм3/   %13.7f  ",RO_k);
fprintf(f2,"\n                                                                                ");
fprintf(f2,"\n    Модуль упругости                                                            ");
fprintf(f2,"\n        Ролик .............................................. /кг/мм2/   %13.7f  ",E_w);
fprintf(f2,"\n        Внутреннее кольцо .................................. /кг/мм2/   %13.7f  ",E_vk);
fprintf(f2,"\n        Наружное кольцо .................................... /кг/мм2/   %13.7f  ",E_nk);
fprintf(f2,"\n        Сепаратор .......................................... /кг/мм2/   %13.7f  ",E_sep);
fprintf(f2,"\n        Вал ................................................ /кг/мм2/   %13.7f  ",E_v);
fprintf(f2,"\n        Корпус ............................................. /кг/мм2/   %13.7f  ",E_k);
fprintf(f2,"\n                                                                                ");
fprintf(f2,"\n    Коэффициенты Пуассона                                                       ");
fprintf(f2,"\n        Ролик .......................................................   %13.7f  ",EP_w);
fprintf(f2,"\n        Внутреннее кольцо ...........................................   %13.7f  ",EP_vk);
fprintf(f2,"\n        Наружное кольцо .............................................   %13.7f  ",EP_nk);
fprintf(f2,"\n        Сепаратор ...................................................   %13.7f  ",EP_sep);
fprintf(f2,"\n        Вал .........................................................   %13.7f  ",EP_v);
fprintf(f2,"\n        Корпус ......................................................   %13.7f  ",EP_k);
fprintf(f2,"\n                                                                                ");
fprintf(f2,"\n    Коэффициент теплового расширения                                            ");
fprintf(f2,"\n        Ролик ........................................... /Градус -1/   %13.7f  ",At_r); 
fprintf(f2,"\n        Внутреннее кольцо ................................/Градус -1/   %13.7f  ",At_vk);
fprintf(f2,"\n        Наружное кольцо ................................../Градус -1/   %13.7f  ",At_nk);
fprintf(f2,"\n        Сепаратор ......................................../Градус -1/   %13.7f  ",At_sep);
fprintf(f2,"\n        Вал ............................................../Градус -1/   %13.7f  ",At_v); 
fprintf(f2,"\n        Корпус .........................................../Градус -1/   %13.7f  ",At_k);
fprintf(f2,"\n                                                                                ");
fprintf(f2,"\n  НАТЯГИ В СОЕДИНЕНИЯХ ПРИ МОНТАЖЕ                                              ");
fprintf(f2,"\n    Вал-подшипник .............................................../мм/  %13.7f   ",HB); 
fprintf(f2,"\n    Подшипник-корпус............................................./мм/  %13.7f   ",HK);
fprintf(f2,"\n                                                                                ");
fprintf(f2,"\n  ЧИСТОТА ОБРАБОТКИ ПОВЕРХНОСТИ                                                 ");
fprintf(f2,"\n    Вала ......................................................../мм/  %13.7f   ",RZB);
fprintf(f2,"\n    Корпуса ...................................................../мм/  %13.7f   ",RZK); 
fprintf(f2,"\n                                                                                ");
fprintf(f2,"\n  РАБОЧИЕ УСЛОВИЯ                                                               ");
fprintf(f2,"\n    Частота вращения внутреннего кольца и вала ............. /об/мин/  %13.7f   ",B_N);
fprintf(f2,"\n    Частота вращения наружного кольца ...................... /об/мин/  %13.7f  ",N_N);
fprintf(f2,"\n    Pадиальная нагрузка ....................................... /кгс/  %13.7f   ",FR);
fprintf(f2,"\n    Осевая нагрузка ........................................... /кгс/  %13.7f   ",FA);
fprintf(f2,"\n    Угол перекоса дорожки качения внутреннего кольца .......... /MИH/  %13.7f   ",TT);
fprintf(f2,"\n    Доля масла в масловоздушной смеси ...............................   %9.3f   ", Doly);	
fprintf(f2,"\n                                                                                ");
fprintf(f2,"\n  РАБОЧАЯ ТЕМПЕРАТУРА                                                           ");
fprintf(f2,"\n      Ролик ........................................ /Градус Цельсия/   %13.7f  ",T_w);
fprintf(f2,"\n      Внутреннее кольцо ............................ /Градус Цельсия/   %13.7f  ",T_vk); 
fprintf(f2,"\n      Наружное кольцо .............................. /Градус Цельсия/   %13.7f  ",T_nk);
fprintf(f2,"\n      Вал .......................................... /Градус Цельсия/   %13.7f  ",T_v);
fprintf(f2,"\n      Корпус ....................................... /Градус Цельсия/   %13.7f  ",T_k);
fprintf(f2,"\n      Масла на входе ............................... /Градус Цельсия/   %13.7f  ",T_maslo_vh);
fprintf(f2,"\n                                                                                ");
fprintf(f2,"\n  ТЕМПЕРАТУРА МОНТАЖА ПОДШИПНИКА.................... /Градус Цельсия/   %13.7f  ",Tm);
fprintf(f2,"\n                                                                              ");

switch (Maslo)
{
	case 1:
		// Для смазки № 1. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 1   МС-20                                                             ");
		break;
	case 2:
		// Для смазки № 2. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 2   75% МС-20 + 25% трансформаторного                                 ");
		break;	
	case 3:
		// Для смазки № 3. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 3   50% МС-20 + 50% трансформаторного                                 ");
		break;
	case 4:
		// Для смазки № 4. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 4   25% МС-20 + 75% трансформаторного                                 ");
		break;
	case 5:
		// Для смазки № 5. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 5   Веретенное 2                                                      ");
		break;
	case 6:
		// Для смазки № 6. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 6   МК-8                                                              ");
		break;
	case 7:
		// Для смазки № 7. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 7   Трансформаторное                                                  ");
		break;
	case 8:
		// Для смазки № 8. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 8   МН 7-5                                                            ");
		break;
	case 9:
		// Для смазки № 9. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 9   ВНИИНП-7                                                          ");
		break;
	case 10:
		// Для смазки № 10. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 10  Б-38                                                              ");
		break;
	case 11:
		// Для смазки № 11. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 11  ЛНМ3-36/1-K                                                       ");
		break;
	case 12:
		// Для смазки № 12. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 12  50-1-4Ф                                                           ");
		break;
	case 13:
		// Для смазки № 13 (произвольная задаваемая с помощью формулы Роландса).	
		fprintf(f2,"\n  РЕОЛОГИЧЕСКИЕ ХАРАКТЕРИСТИКИ СМАЗКИ N 13 ( Вязкость по Роландсу )           ");
		fprintf(f2,"\n      Динам.вязкость масла при давлении=0 и темп=T0 ......./кг*с/мм2/  %10.9f  ", N0);
		fprintf(f2,"\n      Плотность масла при температуре=T0 ..................../кг/мм3/  %10.9f  ", RO1_maslo);
		fprintf(f2,"\n      Температура T0 при которой задана дин.вязкость /Градус Кельвина/ %9.2f  ", T0);
		fprintf(f2,"\n      Пъезовязкостный параметр ( Z1 ) ................................ %9.3f  ", Z1);
		fprintf(f2,"\n      Модуль сдвига смазки ( G сдвиг ) ............................... %9.3f  ", Gsdw);
		fprintf(f2,"\n      Термовязкостный параметр ( SS0 )  .............................. %9.3f  ", SS0);
		fprintf(f2,"\n      Пъезокоэффициент вязкости смазки  .............................. %9.3f  ", Pezo_koeff);
		fprintf(f2,"\n                                                                              ");
		break;
	default:
		// Для других видов смазки. Выдать наименование смазки.
		fprintf(f2,"\n  ОШИБКА !!! УКАЗАН НЕИЗВЕСТНЫЙ ВИД СМАЗКИ !!!                              ");
		break;
}

fprintf(f2,"\n                                                                               ");

switch (vid_aprox)
{
	case 1:
		// Для случая апроксимации таблицы вязкости полиномом Лагранжа.
		fprintf(f2,"\n  Таблица вязкости апроксимируется полиномом ЛАГРАНЖА");
		break;
	case 2:
		// Для случая апроксимации таблицы вязкости формулой Баруса.
		fprintf(f2,"\n  Таблица вязкости апроксимируется формулой БАРУСА");
		break;
	case 3:
		// Для случая апроксимации таблицы вязкости формулой Роландса.
		fprintf(f2,"\n  Таблица вязкости апроксимируется формулой РОЛАНДСА");
		break;
	default:
		// Для других видов апроксимации.
		fprintf(f2,"\n  ОШИБКА !!! УКАЗАН НЕИЗВЕСТНЫЙ СПОСОБ АПРОКСИМАЦИИ !!! ");	
		break;
}

fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  КОЭФФИЦИЕНТ ДЛЯ РАСЧЁТА ДОЛГОВЕЧНОСТИ.............. /Градус Цельсия/  %9.3f  ", Lambda);
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  НАСТРОЙКИ ПРОГРАММЫ                                                           ");
fprintf(f2,"\n    Kол-во участков на которые разбивается полная длина ролика ........   %3d  ",N);
fprintf(f2,"\n                                                                               ");

if (priz_sliyan_uch == 1)  
	fprintf(f2,"\n    НЕРАВНОМЕРНАЯ СЕТКА ДЛЯ УВЕЛИЧЕНИЯ СКОРОСТИ ВЫЧИСЛЕНИЙ         ");
else
	fprintf(f2,"\n    РАВНОМЕРНАЯ СЕТКА                                              ");

if ( Priz_napr_kray_effect == 1 )
	fprintf(f2,"\n    ВЫПОЛНЯЕТСЯ РАСЧЕТ КОНЦЕНТРАТОРОВ НАПРЯЖЕНИЙ НА КРАЯХ РОЛИКА        ");
else
	fprintf(f2,"\n    БЕЗ РАСЧЕТА КОНЦЕНТРАТОВ НАПРЯЖЕНИЙ НА КРАЯХ РОЛИКА                 ");

if ( Priz_profil_nk == 1 )
	fprintf(f2,"\n    БЕРЁМ ПРОФИЛЬ ДОРОЖКИ КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА ИЗ ФАЙЛА PROF_NK.DAT  %3d ТОЧЕК ", kol_toch_profil_nk);
else
	fprintf(f2,"\n    КРУГЛАЯ ДОРОЖКА КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА ");

fprintf(f2,"\n                                                                                ");
fprintf(f2,"\n    Коэффициенты умножения шага при решении методом Ньютона :                   ");
fprintf(f2,"\n       Уравнений равновесия ролика ...................................  %13.7f  ",koeff_shag_1);
fprintf(f2,"\n       Уравнений равновесия внутреннего кольца .......................  %13.7f  ",koeff_shag_2);
fprintf(f2,"\n       Поиск распределения напряжений в контакте ролика с кольцом ....  %13.7f  ",koeff_shag_3);
fprintf(f2,"\n:                                                                      : ");


/// Выделить область памяти для хранения массива усилий в контакте всех роликов с внутренним кольцом.
QJ = (double *) malloc(Z * sizeof(double));
if (QJ == NULL)
{
	// Неудача при выделении памяти для хранения массива усилий в контакте всех роликов с внутренним кольцом. 		
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива усилий в контакте роликов с внутренним кольцом. ");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива усилий в контакте роликов с внутренним кольцом. ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива усилий в контакте всех роликов с наружным кольцом.
QHU = (double *) malloc(Z * sizeof(double));
if (QHU == NULL)
{
	// Неудача при выделении памяти для хранения массива усилий в контакте всех роликов с наружным кольцом. 		
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива усилий в контакте роликов с наружным кольцом. ");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива усилий в контакте роликов с наружным кольцом. ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива эксцентриситетов нагрузки всех роликов.
DEC = (double *) malloc(Z * sizeof(double));
if (DEC == NULL)
{
	// Неудача при выделении памяти для хранения массива эксцентриситетов нагрузки всех роликов.
	// Освободить память
	free_mem_rol_max_napr();
	
	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива эксцентриситетов нагрузки всех роликов. ");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива эксцентриситетов нагрузки всех роликов. ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива сближений ролика с наружным кольцом.
F1X = (double *) malloc(Z * sizeof(double));
if (F1X == NULL)
{
	// Неудача при выделении памяти для хранения массива сближений ролика с наружным кольцом.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива сближений ролика с наружным кольцом. ");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива сближений ролика с наружным кольцом. ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива углов перекоса роликов в минутах.
F2X = (double *) malloc(Z * sizeof(double));
if (F2X == NULL)
{
	// Неудача при выделении памяти для хранения массива углов перекоса роликов в минутах.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива углов перекоса роликов в минутах. ");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива углов перекоса роликов в минутах. ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива невязок уравнений равновесия сил действующих на ролик.
F1V = (double *) malloc(Z * sizeof(double));
if (F1V == NULL)
{
	// Неудача при выделении памяти для хранения массива невязок уравнений равновесия сил действующих на ролик.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива невязок уравнений равновесия сил действующих на ролик. ");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива невязок уравнений равновесия сил действующих на ролик. ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива невязок уравнений равновесия моментов действующих на ролик.
F2V = (double *) malloc(Z * sizeof(double));
if (F2V == NULL)
{
	// Неудача при выделении памяти для хранения массива невязок уравнений равновесия моментов действующих на ролик
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива невязок уравнений равновесия моментов действующих на ролик. ");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива невязок уравнений равновесия моментов действующих на ролик. ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива деформаций на участках контакта роликов с внутренним кольцом.
DB = (double *) malloc(Z*N*sizeof(double));
if (DB == NULL)
{
	// Неудача при выделении памяти для хранения массива деформаций на участках контакта роликов с внутренним кольцом.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива деформаций на участках контакта роликов с внутренним кольцом. ");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива деформаций на участках контакта роликов с внутренним кольцом. ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива ширин вдоль полоски контакта ролика с внутренним кольцом.
Bv =  (double *) malloc(Z*N*sizeof(double));
if (Bv == NULL)
{
	// Неудача при выделении памяти для хранения массива ширин вдоль полоски контакта ролика с внутренним кольцом.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива ширин вдоль полоски контакта ролика с внутренним кольцом. ");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива ширин вдоль полоски контакта ролика с внутренним кольцом. ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива ширин вдоль полоски контакта ролика с наружным кольцом.
Bn =  (double *) malloc(Z*N*sizeof(double));
if (Bn == NULL)
{
	// Неудача при выделении памяти для хранения массива ширин вдоль полоски контакта ролика с наружным кольцом.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива ширин вдоль полоски контакта ролика с наружным кольцом. ");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива ширин вдоль полоски контакта ролика с наружным кольцом. ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива деформаций на участках контакта роликов с наружным кольцом.
DH = (double *) malloc(Z*N*sizeof(double));
if (DH == NULL)
{
	// Неудача при выделении памяти для хранения массива деформаций на участках контакта роликов с наружным кольцом.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива деформаций на участках контакта роликов с наружным кольцом.");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива деформаций на участках контакта роликов с наружным кольцом.");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива средних напряжений на участках контакта всех роликов с внутренним кольцом.
SIGI = (double *) malloc(Z*N*sizeof(double));
if (SIGI == NULL)
{
	// Неудача при выделении памяти для хранения массива средних напряжений на участках контакта всех роликов с внутренним кольцом.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива средних напряжений на участках контакта всех роликов с внутренним кольцом");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива средних напряжений на участках контакта всех роликов с внутренним кольцом");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива средних напряжений на участках контакта всех роликов с наружным кольцом.
SIGO = (double *) malloc(Z*N*sizeof(double));
if (SIGO == NULL)
{
	// Неудача при выделении памяти для хранения массива средних напряжений на участках контакта всех роликов с наружным кольцом.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива средних напряжений на участках контакта всех роликов с наружным кольцом");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива средних напряжений на участках контакта всех роликов с наружным кольцом");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива значений центробежныой сиды действующей на ролики.
FCOP = (double *) malloc(Z*sizeof(double));
if (FCOP == NULL)
{
	// Неудача при выделении памяти для хранения массива значений центробежныой сиды действующей на ролики.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива значений центробежныой сиды действующей на ролики");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива значений центробежныой сиды действующей на ролики");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива максимальных напряжений в контакте всех роликов с внутренним кольцом.
SIGI_max = (double *) malloc(Z*sizeof(double));
if (SIGI_max ==  NULL)
{
	// Неудача при выделении памяти для хранения массива максимальных напряжений в контакте всех роликов с внутренним кольцом.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива максимальных напряжений в контакте всех роликов с внутренним кольцом");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива максимальных напряжений в контакте всех роликов с внутренним кольцом");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива максимальных напряжений в контакте всех роликов с наружным кольцом.
SIGO_max = (double *) malloc(Z*sizeof(double));	
if (SIGO_max == NULL)
{
	// Неудача при выделении памяти для хранения массива максимальных напряжений в контакте всех роликов с наружным кольцом.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива максимальных напряжений в контакте всех роликов с наружным кольцом");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива максимальных напряжений в контакте всех роликов с наружным кольцом");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива в который записан профиль ролика
profil = (double *) malloc(N*sizeof(double));
if (profil == NULL)
{
	// Неудача при выделении области памяти для хранения массива в который записывается профиль ролика
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти для хранения массива профиля ролика ");
	fprintf(f2,"\n Неудача при выделении памяти для хранения массива профиля ролика ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения одномерного массива сил действующих на перемычку сепаратора со стороны роликов
F_rol_sep = (double *) malloc(Z*sizeof(double));
if (F_rol_sep == NULL)
{
	// Неудача при выделении области памяти для хранения одномерного массива сил действующих на перемычку 
	// сепаратора со стороны роликов.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении области памяти для хранения массива сил действующих на перемычку сепаратора со стороны роликов ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива сил действующих на перемычку сепаратора со стороны роликов ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения одномерного массива сил трения в контакте роликов с перемычками сепаратора
F_tr_rol_sep = (double *) malloc(Z*sizeof(double));
if (F_tr_rol_sep == NULL)
{
	// Неудача при выделении области памяти для хранения одномерного массива сил трения в контакте роликов с перемычками сепаратора
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении области памяти для хранения массива сил трения в контакте роликов с перемычками сепаратора ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива сил трения в контакте роликов с перемычками сепаратора ");
	
	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения одномерного массива максимальных ширин полос контакта ролика с дорожкой качения внутреннего кольца
BVmax = (double *) malloc(Z*sizeof(double));
if (BVmax == NULL)
{
	// Неудача при выделении области памяти для хранения одномерного массива максимальных ширин полос контакта ролика с дорожкой качения 
	// внутреннего кольца.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении области памяти для хранения массива максимальных ширин полос контакта ролика с дорожкой качения внутреннего кольца ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива максимальных ширин полос контакта ролика с дорожкой качения внутреннего кольца ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения одномерного массива максимальных ширин полос контакта ролика с дорожкой качения наружного кольца
BNmax = (double *) malloc(Z*sizeof(double));
if (BNmax == NULL)
{
	// Неудача при выделении области памяти для хранения одномерного массива максимальных ширин полос контакта ролика с дорожкой качения 
	// наружного кольца.
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении области памяти для хранения массива максимальных ширин полос контакта ролика с дорожкой качения наружного кольца ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива максимальных ширин полос контакта ролика с дорожкой качения наружного кольца ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}


/// Выделить область памяти для хранения массива нормальных усилий на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в кг.
Q_centr_0_I = (double *) malloc(N*sizeof(double));		
if (Q_centr_0_I == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива нормальных усилий на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в кг. ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива нормальных усилий на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в кг.");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива нормальных напряжений на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в кг/мм2
P_centr_0_I = (double *) malloc(N*sizeof(double));		
if (P_centr_0_I == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива нормальных напряжений на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в кг/мм2 ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива нормальных напряжений на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в кг/мм2 ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива скоростей скольжения поверхностей на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм/сек.
V_skol_poverh_centr_0_I	= (double *) malloc(N*sizeof(double));		
if (V_skol_poverh_centr_0_I == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива скоростей скольжения поверхностей на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм/сек. ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива скоростей скольжения поверхностей на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм/сек.");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива скоростей качения на участках центральной полосы 0 го ролика с дорожкой качения внутреннего кольца в мм/сек.
U_kach_centr_0_I = (double *) malloc(N*sizeof(double));  
if (U_kach_centr_0_I == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива скоростей качения на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм/сек. ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива скоростей качения на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм/сек.");

	// Выход из программы с признаком неудачи.
	return -1.0;
}


/// Выделить область памяти для хранения массива напряжений на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в кг/мм2
t_centr_0_I = (double *) malloc(N*sizeof(double));		
if (t_centr_0_I == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива напряжений на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в кг/мм2 ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива напряжений на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в кг/мм2");

	// Выход из программы с признаком неудачи.
	return -1.0;
}


/// Выделить область памяти для хранения массива толщин смазочной плёнки на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм.
h_centr_0_I = (double *) malloc(N*sizeof(double));		
if (h_centr_0_I == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива толщин смазочной плёнки на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм. ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива толщин смазочной плёнки на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм.");

	// Выход из программы с признаком неудачи.
	return -1.0;
}


/// Выделить область памяти для хранения массива динамической вязкости на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в кг*сек/мм2
Nr_centr_0_I = (double *) malloc(N*sizeof(double));		
if (Nr_centr_0_I == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива динамической вязкости на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в кг*сек/мм2 ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива динамической вязкости на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в кг*сек/мм2");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива деформаций на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм.
Def_0_I = (double *) malloc(N*sizeof(double));		
if (Def_0_I == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива деформаций на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива деформаций на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива нормальных усилий на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца в кг.
Q_centr_0_O = (double *) malloc(N*sizeof(double));		
if (Q_centr_0_O == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива нормальных усилий на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца в кг. ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива нормальных усилий на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца в кг.");

	// Выход из программы с признаком неудачи.
	return -1.0;
}


/// Выделить область памяти для хранения массива нормальных напряжений на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца в кг/мм2
P_centr_0_O = (double *) malloc(N*sizeof(double));		
if (P_centr_0_O == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива нормальных напряжений на участках центральной полосы  контакта 0 го ролика с дорожкой качения наружного кольца в кг/мм2 ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива нормальных напряжений на участках центральной полосы  контакта 0 го ролика с дорожкой качения наружного кольца в кг/мм2");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива скоростей скольжения поверхностей на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца  в мм/сек.
V_skol_poverh_centr_0_O	= (double *) malloc(N*sizeof(double));		
if (V_skol_poverh_centr_0_O == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива скоростей скольжения поверхностей на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца  в мм/сек. ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива скоростей скольжения поверхностей на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца  в мм/сек.");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива скоростей качения на участках центральной полосы 0 го ролика с дорожкой качения наружного кольца в мм/сек.
U_kach_centr_0_O = (double *) malloc(N*sizeof(double));  
if (U_kach_centr_0_O == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива скоростей качения на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца в мм/сек. ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива скоростей качения на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца в мм/сек.");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива касательных напряжений на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца  в кг/мм2
t_centr_0_O = (double *) malloc(N*sizeof(double));		
if (t_centr_0_O == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива касательных напряжений на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца  в кг/мм2 ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива касательных напряжений на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца  в кг/мм2");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива толщин смазочной плёнки на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца  в мм.
h_centr_0_O = (double *) malloc(N*sizeof(double));		
if (h_centr_0_O == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива толщин смазочной плёнки на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца  в мм. ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива толщин смазочной плёнки на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца  в мм.");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива динамической вязкости на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца в кг*сек/мм2
Nr_centr_0_O = (double *) malloc(N*sizeof(double));		
if (Nr_centr_0_O == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива  динамической вязкости на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца в кг*сек/мм2");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива динамической вязкости на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца в кг*сек/мм2");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива деформаций на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца в мм.
Def_0_O = (double *) malloc(N*sizeof(double));		
if (Def_0_O == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива деформаций на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива деформаций на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца в мм ");

	// Выход из программы с признаком неудачи.
	return -1.0;
}


/// Выделить область памяти для хранения массива  вязкости смазки  при различных температурах
Vyaz_smazka = (double *) malloc(kol_toch_temp*sizeof(double));		
if (Vyaz_smazka == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива вязкости смазки при различных температурах");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива вязкости смазки  при различных температурах");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива пъезокоэффициента вязкости смазки при различных тепературах
Pezo_smazka = (double *) malloc(kol_toch_temp*sizeof(double));				
if (Pezo_smazka == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива пъезокоэффициента вязкости смазки при различных температурах");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива пъезокоэффициента вязкости смазки  при различных температурах");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива значений температуры смазки при которых производилось измерение её вязкости и пъезокоэффициента
Temp_smazka = (double *) malloc(kol_toch_temp*sizeof(double));				
if (Temp_smazka == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива температур смазки");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива температур смазки");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

/// Выделить область памяти для хранения массива коэффициентов полинома Лагранжа задающего вязкость смазки при различных температурах.
k_lagr_vyaz = (double *) malloc(kol_toch_temp*sizeof(double));				
if (k_lagr_vyaz == NULL) 
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива коэффициентов полинома Лагранжа задающего вязкость смазки при различных температурах");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива коэффициентов полинома Лагранжа задающего вязкость смазки при различных температурах");

	// Выход из программы с признаком неудачи.
	return -1.0;
}


/// Выделить область памяти для хранения массива коэффициентов полинома Лагранжа задающего пъезокоэффициент вязкости смазки при различных температурах.
k_lagr_pezo = (double *) malloc(kol_toch_temp*sizeof(double));				
if (k_lagr_pezo == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива коэффициентов полинома Лагранжа задающего пъезокоэффициент вязкости смазки при различных температурах");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива коэффициентов полинома Лагранжа задающего пъезокоэффициент вязкости смазки при различных температурах");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
///

// Выделить область памяти для хранения массива энергий деформаций роликов при втаскивании их в клин
Energ_def_rol = (double *) malloc(Z*sizeof(double));
if (Energ_def_rol == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива энергий деформаций роликов");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива энергий деформаций роликов");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

// Выделить область памяти для хранения массива дополнительных усилий на перемычку сепаратора возникающих при втаскивании ролика в клин.
Dop_usil_sep = (double *) malloc(Z*sizeof(double));
if (Dop_usil_sep == NULL)
{
 	// Неудача при выделении памяти для хранения массива
	// Освободить память
	free_mem_rol_max_napr();

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении области памяти для хранения массива дополнительных усилий на перемычку сепаратора возникающих при втаскивании ролика в клин ");
	fprintf(f2,"\n Неудача при выделении области памяти для хранения массива дополнительных усилий на перемычку сепаратора возникающих при втаскивании ролика в клин");

	// Выход из программы с признаком неудачи.
	return -1.0;
}

///
///////////////////////////////////////////////////////////////////////////////////////////////////////


/// Задать значения массива температуры смазки в градусах Цельсия.
* (Temp_smazka+0) =  50.0;
* (Temp_smazka+1) =  60.0;
* (Temp_smazka+2) =  80.0;
* (Temp_smazka+3) = 100.0;
* (Temp_smazka+4) = 120.0;
* (Temp_smazka+5) = 140.0;
* (Temp_smazka+6) = 150.0;

switch (Maslo)
{
	case 1:
	{   	// Для смазки № 1  MC-20

		// Задать значения массива вязкости смазки в 100*Па*с  при различных температурах  
		* (Vyaz_smazka+0) = 11.40;
		* (Vyaz_smazka+1) =  7.60;
		* (Vyaz_smazka+2) =  3.40;
		* (Vyaz_smazka+3) =  1.84;
		* (Vyaz_smazka+4) =  1.05;
		* (Vyaz_smazka+5) =  0.70;
		* (Vyaz_smazka+6) =  0.57;
		
		// Задать значения массива пъезокоэффициента вязкости смазки в 10^9*Па^(-1) при различных температурах
		* (Pezo_smazka+0) = 22.30;	
		* (Pezo_smazka+1) = 20.70;	
		* (Pezo_smazka+2) = 17.60;	
		* (Pezo_smazka+3) = 14.50;	
		* (Pezo_smazka+4) = 11.30;	
		* (Pezo_smazka+5) =  8.30;	
		* (Pezo_smazka+6) =  6.80;	

		break;
	}

	case 2:
	{
		// Для смазки № 2  Смесь  75% МС-20 + 25% трансформаторного

		// Задать значения массива вязкости смазки в 100*Па*с при различных температурах
		* (Vyaz_smazka+0) =  5.84;
		* (Vyaz_smazka+1) =  4.00;
		* (Vyaz_smazka+2) =  1.91;
		* (Vyaz_smazka+3) =  1.08;
		* (Vyaz_smazka+4) =  0.67;
		* (Vyaz_smazka+5) =  0.47;
		* (Vyaz_smazka+6) =  0.39;
		
		// Задать значения массива пъезокоэффициента вязкости  в 10^9*Па^(-1) смазки при различных температурах
		* (Pezo_smazka+0) = 20.60;	
		* (Pezo_smazka+1) = 19.20;	
		* (Pezo_smazka+2) = 16.50;	
		* (Pezo_smazka+3) = 13.70;	
		* (Pezo_smazka+4) = 10.90;	
		* (Pezo_smazka+5) =  8.20;	
		* (Pezo_smazka+6) =  6.80;	

		break;
	}

	case 3:
	{
		// Для смазки № 3  Смесь  50% МС-20 + 50% трансформаторного

		// Задать значения массива вязкости смазки в 100*Па*с при различных температурах
		* (Vyaz_smazka+0) =  2.85;
		* (Vyaz_smazka+1) =  2.09;
		* (Vyaz_smazka+2) =  1.05;
		* (Vyaz_smazka+3) =  0.64;
		* (Vyaz_smazka+4) =  1.41;
		* (Vyaz_smazka+5) =  0.30;
		* (Vyaz_smazka+6) =  0.26;
		
		// Задать значения массива пъезокоэффициента вязкости смазки  в 10^9*Па^(-1) при различных температурах
		* (Pezo_smazka+0) = 19.20;	
		* (Pezo_smazka+1) = 18.00;	
		* (Pezo_smazka+2) = 15.40;	
		* (Pezo_smazka+3) = 13.00;	
		* (Pezo_smazka+4) = 10.50;	
		* (Pezo_smazka+5) =  8.10;	
		* (Pezo_smazka+6) =  6.80;	

		break;
	}

	case 4:
	{
		// Для смазки № 4  Смесь  25% МС-20 + 75% трансформаторного

		// Задать значения массива вязкости смазки в 100*Па*с при различных температурах
		* (Vyaz_smazka+0) =  1.46;
		* (Vyaz_smazka+1) =  1.08;
		* (Vyaz_smazka+2) =  0.60;
		* (Vyaz_smazka+3) =  0.39;
		* (Vyaz_smazka+4) =  0.27;
		* (Vyaz_smazka+5) =  0.21;
		* (Vyaz_smazka+6) =  0.19;
		
		// Задать значения массива пъезокоэффициента вязкости смазки  в 10^9*Па^(-1) при различных температурах
		* (Pezo_smazka+0) = 17.60;	
		* (Pezo_smazka+1) = 16.50;	
		* (Pezo_smazka+2) = 14.40;	
		* (Pezo_smazka+3) = 12.30;	
		* (Pezo_smazka+4) = 10.20;	
		* (Pezo_smazka+5) =  8.00;	
		* (Pezo_smazka+6) =  6.90;	

		break;
	}

	case 5:
	{
		// Для смазки № 5  Веретённое 2 

		// Задать значения массива вязкости смазки в 100*Па*с при различных температурах
		* (Vyaz_smazka+0) = 1.16;
		* (Vyaz_smazka+1) = 0.86;
		* (Vyaz_smazka+2) = 0.47;
		* (Vyaz_smazka+3) = 0.31;
		* (Vyaz_smazka+4) = 0.22;
		* (Vyaz_smazka+5) = 0.17;
		* (Vyaz_smazka+6) = 0.16;
		
		// Задать значения массива пъезокоэффициента вязкости смазки  в 10^9*Па^(-1) при различных температурах
		* (Pezo_smazka+0) = 12.8;	
		* (Pezo_smazka+1) = 12.3;	
		* (Pezo_smazka+2) = 11.4;	
		* (Pezo_smazka+3) = 10.5;	
		* (Pezo_smazka+4) =  9.5;	
		* (Pezo_smazka+5) =  8.7;	 
		* (Pezo_smazka+6) =  8.2;	

		break;
	}

	case 6:
	{
		// Для смазки № 6  МК-8

		// Задать значения массива вязкости смазки в 100*Па*с при различных температурах
		* (Vyaz_smazka+0) = 0.74;
		* (Vyaz_smazka+1) = 0.55;
		* (Vyaz_smazka+2) = 0.30;
		* (Vyaz_smazka+3) = 0.20;
		* (Vyaz_smazka+4) = 0.16;
		* (Vyaz_smazka+5) = 0.13;
		* (Vyaz_smazka+6) = 0.12;
		
		// Задать значения массива пъезокоэффициента вязкости смазки  в 10^9*Па^(-1) при различных температурах
		* (Pezo_smazka+0) = 15.9;	
		* (Pezo_smazka+1) = 15.0;	
		* (Pezo_smazka+2) = 13.2;	
		* (Pezo_smazka+3) = 11.4;	
		* (Pezo_smazka+4) =  9.6;	
		* (Pezo_smazka+5) =  7.8;	
		* (Pezo_smazka+6) =  6.9;	

		break;
	}

	case 7:
	{
		// Для смазки № 7  Трансформаторное

		// Задать значения массива вязкости смазки в 100*Па*с при различных температурах
		* (Vyaz_smazka+0) = 0.74;
		* (Vyaz_smazka+1) = 0.55;
		* (Vyaz_smazka+2) = 0.32;
		* (Vyaz_smazka+3) = 0.22;
		* (Vyaz_smazka+4) = 0.16;
		* (Vyaz_smazka+5) = 0.14;
		* (Vyaz_smazka+6) = 0.13;
		
		// Задать значения массива пъезокоэффициента вязкости смазки  в 10^9*Па^(-1) при различных температурах
		* (Pezo_smazka+0) = 15.9;	
		* (Pezo_smazka+1) = 15.0;	
		* (Pezo_smazka+2) = 13.2;	
		* (Pezo_smazka+3) = 11.4;	
		* (Pezo_smazka+4) =  9.6;	 
		* (Pezo_smazka+5) =  7.8;	
		* (Pezo_smazka+6) =  6.9;	

		break;
	}

	case 8:
	{
		// Для смазки № 8  МН-7.5

		// Задать значения массива вязкости смазки в 100*Па*с при различных температурах
		* (Vyaz_smazka+0) = 0.310;
		* (Vyaz_smazka+1) = 0.214;
		* (Vyaz_smazka+2) = 1.140;
		* (Vyaz_smazka+3) = 0.700;
		* (Vyaz_smazka+4) = 0.490;
		* (Vyaz_smazka+5) = 0.360;
		* (Vyaz_smazka+6) = 0.320;
		
		// Задать значения массива пъезокоэффициента вязкости смазки  в 10^9*Па^(-1) при различных температурах
		* (Pezo_smazka+0) = 12.8;	
		* (Pezo_smazka+1) = 12.3;	
		* (Pezo_smazka+2) = 11.1;	
		* (Pezo_smazka+3) = 10.1;	
		* (Pezo_smazka+4) =  9.0;	
		* (Pezo_smazka+5) =  7.9;	
		* (Pezo_smazka+6) =  7.4;	

		break;
	}

	case 9:
	{
		// Для смазки № 9  ВНИИНП-7

		// Задать значения массива вязкости смазки в 100*Па*с при различных температурах
		* (Vyaz_smazka+0) = 3.24;
		* (Vyaz_smazka+1) = 1.69;
		* (Vyaz_smazka+2) = 1.01;
		* (Vyaz_smazka+3) = 0.64;
		* (Vyaz_smazka+4) = 0.46;
		* (Vyaz_smazka+5) = 0.34;
		* (Vyaz_smazka+6) = 0.31;
		
		// Задать значения массива пъезокоэффициента вязкости смазки  в 10^9*Па^(-1) при различных температурах
		* (Pezo_smazka+0) = 12.3;	
		* (Pezo_smazka+1) = 12.0;	
		* (Pezo_smazka+2) = 11.2;	
		* (Pezo_smazka+3) = 10.5;	
		* (Pezo_smazka+4) =  9.9;	
		* (Pezo_smazka+5) =  9.2;	
		* (Pezo_smazka+6) =  8.8;	

		break;
	}

	case 10:
	{
		// Для смазки № 10  Б-3В

		// Задать значения массива вязкости смазки в 100*Па*с при различных температурах
		* (Vyaz_smazka+0) = 2.32;
		* (Vyaz_smazka+1) = 1.63;
		* (Vyaz_smazka+2) = 0.83;
		* (Vyaz_smazka+3) = 0.52;
		* (Vyaz_smazka+4) = 0.35;
		* (Vyaz_smazka+5) = 0.26;
		* (Vyaz_smazka+6) = 0.22;
		
		// Задать значения массива пъезокоэффициента вязкости смазки  в 10^9*Па^(-1) при различных температурах
		* (Pezo_smazka+0) = 8.4;	
		* (Pezo_smazka+1) = 8.3;	
		* (Pezo_smazka+2) = 8.2;	
		* (Pezo_smazka+3) = 8.1;	
		* (Pezo_smazka+4) = 8.1;	
		* (Pezo_smazka+5) = 8.1;	
		* (Pezo_smazka+6) = 8.1;	

		break;
	}

	case 11:
	{
		// Для смазки № 11  ЛНМЗ-36/1-К

		// Задать значения массива вязкости смазки в 100*Па*с при различных температурах
		* (Vyaz_smazka+0) = 1.01;
		* (Vyaz_smazka+1) = 0.74;
		* (Vyaz_smazka+2) = 0.43;
		* (Vyaz_smazka+3) = 0.29;
		* (Vyaz_smazka+4) = 0.22;
		* (Vyaz_smazka+5) = 0.17;
		* (Vyaz_smazka+6) = 0.15;
		
		// Задать значения массива пъезокоэффициента вязкости смазки  в 10^9*Па^(-1) при различных температурах
		* (Pezo_smazka+0) = 9.4;	
		* (Pezo_smazka+1) = 9.1;	
		* (Pezo_smazka+2) = 8.4;	
		* (Pezo_smazka+3) = 7.7;	
		* (Pezo_smazka+4) = 7.1;	
		* (Pezo_smazka+5) = 6.4;	
		* (Pezo_smazka+6) = 6.1;	

		break;
	}

	case 12:
	{
	 	// Для смазки № 12 50-1-4Ф

		// Задать значения массива вязкости смазки в 100*Па*с при различных температурах
		* (Vyaz_smazka+0) = 0.68;
		* (Vyaz_smazka+1) = 0.55;
		* (Vyaz_smazka+2) = 0.38;
		* (Vyaz_smazka+3) = 0.28;
		* (Vyaz_smazka+4) = 0.21;
		* (Vyaz_smazka+5) = 0.16;
		* (Vyaz_smazka+6) = 0.15;
		
		// Задать значения массива пъезокоэффициента вязкости смазки  в 10^9*Па^(-1) при различных температурах
		* (Pezo_smazka+0) = 9.45;	
		* (Pezo_smazka+1) = 9.10;	
		* (Pezo_smazka+2) = 8.40;	
		* (Pezo_smazka+3) = 7.80;	
		* (Pezo_smazka+4) = 7.30;	
		* (Pezo_smazka+5) = 6.80;	
		* (Pezo_smazka+6) = 6.50;	

		break;
	}

	default :
	{
		// Для других смазок
	}
}


if ((Maslo >= 1) && (Maslo <= 12))
{
	/// Для масел с номерами от 1 до 12.
	switch (vid_aprox)
	{
		case 1:
		{   	
			/// Апроксимация вязкости и пъезокоэффициента с помощью полиномов Лагранжа
			/// Определить коэффициенты полиномов Лагранжа задающих вязкость в 100*Па*с и пъезокоэффициент вязкости смазки  в 10^9*Па^(-1) при различных температурах
			for (k=0; k < kol_toch_temp; k++)
			{
				///                           kol_toch_smazka-1
				/// Найти произведение 	    	-------               
				///				|     |								
				///				|     |	 (Tk - Tj)							
				///				|     |								
				///			       j=0  j<>k
				///
				proizved1 = 1.0;
				for (j=0; j < kol_toch_temp; j++)
				{
					if (k != j) proizved1 *= ( *(Temp_smazka+k) - *(Temp_smazka+j) );
				}

				if (proizved1 == 0)
				{
					/// Выдать сообщение об ошибке
					printf("\n  Ошибка при задании массива температур, заданы две одинаковые температуры в разных элементах массива  ");
					fprintf(f2,"\n Ошибка при задании массива температур, заданы две одинаковые температуры в разных элементах массива ");
					free_mem_rol_max_napr();	/// Освободить память
					return -1.0;			/// Выход из программы с признаком неудачи.
				}

				*(k_lagr_vyaz + k) = * (Vyaz_smazka + k) / proizved1;	/// Определить коэффициент полинома Лагранжа задающего вязкость смазки в 100*Па*с при различных температурах
				*(k_lagr_pezo + k) = * (Pezo_smazka + k) / proizved1;	/// Определить коэффицент полинома Лагранжа задающего пъезокоэффициент вязкости смазки  в 10^9*Па^(-1) при различных температурах
			}
			break;
		}

		default :
		{
			/// Апроксимация вязкости и пъезокоэффициента с помощью экспонент

			/// Выделить область памяти для хранения матрицы входных параметров используемых для поиска по МНК 
			matr_mnk = (double *) malloc ( N_matr_mnk * M_matr_mnk * sizeof(double));
			if (matr_mnk == NULL)
			{
				/// Неудача при выделении области памяти для хранения матрицы входных параметров используемой для МНК
				free_mem_rol_max_napr();												/// Освободить память
				printf("\n Неудача при выделении области памяти для хранения матрицы входных параметров используемых для МНК");		/// Выдать сообщение об ошибке
				fprintf(f2,"\n Неудача при выделении области памяти для хранения матрицы входных параметров используемых для МНК");	/// Выдать сообщение об ошибке
				return -1.0;														/// Выход из программы с признаком неудачи.
			}	

			/// Выделить область памяти для хранения столбца выходных параметров используемого для поиска по МНК
			stolb_mnk = (double *) malloc (N_stolb_mnk * M_stolb_mnk * sizeof(double));
			if (stolb_mnk == NULL)
			{
				/// Неудача при выделении памяти для хранения столбца выходных параметров используемых для поиска по МНК
				free_mem_rol_max_napr();												/// Освободить память
				printf("\n Неудача при выделении области памяти для хранения столбца выходных параметров используемых для МНК");	/// Выдать сообщение об ошибке
				fprintf(f2,"\n Неудача при выделении области памяти для хранения столбца выходных параметров используемых для МНК");	/// Выдать сообщение об ошибке
				return -1.0;														/// Выход из программы с признаком неудачи.
			}

			/// Заполнение нулями матрицы  входных измереннных параметров
			for (j=0; j<N_matr_mnk*M_matr_mnk; j++) *(matr_mnk + j) = 0.0;

			/// Заполнение матрицы входных измеренных параметров и столбца выходных параметров для поиска термокоэффициента формулы Баруса.
			for (j=0; j<kol_toch_temp; j++)
			{
				*(matr_mnk  + j) = (Temp_smazka[j] - Temp_smazka[0]);		/// Заполнение матрицы входных параметров.
				*(stolb_mnk + j) = -log(Vyaz_smazka[j]/Vyaz_smazka[0]);		/// Заполнение столбца выходных параметров.
			}

			/// Поиск термокоэффициента в формуле Баруса по МНК 
			rezult_mnk = mnk( matr_mnk, N_matr_mnk, M_matr_mnk, stolb_mnk, N_stolb_mnk, M_stolb_mnk, &koeff_mnk, &N_koeff_mnk, &M_koeff_mnk );	

			if (rezult_mnk == 1)
			{
				/// МНК преобразование прошло удачно, термокоэффициент формулы Баруса найден. 

				/// Считать термокоэффициент формулы Баруса.
				Termo_koeff_Barus = koeff_mnk[0];	

				/// Выдать в отчёт термокоэффициент формулы Баруса
				fprintf(f2,"\n  Термокоэффициент 'B' в формуле Баруса  N = N0 * exp(-B*(T-T0))  для масла № %3d    =  %20.16f  :  ", Maslo, Termo_koeff_Barus);	

/*
				double NN, TT;	

				/// Табуляция функции 	N = N0 * exp(-B*(T-T0))    с найденным термокоэффициентом B.
				fprintf(f2,"\n T  \t N ");			
				TT=-50.0;		
				while (TT < 250.0)
				{
					NN = Vyaz_smazka[0] * exp(-Termo_koeff_Barus*(TT-Temp_smazka[0]));	/// Получить вязкость по формуле Баруса для текущей температуры
					fprintf(f2,"\n %20.16f \t  %20.16f ",  TT, NN);				/// Выдать текущую температуру и вязкость
					TT += 5.0;								/// Нарастить температуру на 5 градусов
				}
*/

				/// Освободить область памяти выделенную под хранение столбца коэффициентов найденных по МНК 	
				free(koeff_mnk);		
			}
			else
			{
				/// При неудачном МНК преобразовании выдать предупреждающее сообщение 
				free_mem_rol_max_napr();							/// Освободить память
				printf("\n Неудача при поиске по МНК термокоэффициента  формулы Баруса ");	/// Выдать сообщение об ошибке
				fprintf(f2,"\n Неудача при поиске по МНК термокоэффициента  формулы Баруса");	/// Выдать сообщение об ошибке
				return -1.0;									/// Выход из программы с признаком неудачи.
			}

			/// Заполнение матрицы входных измеренных параметров и столбца выходных параметров для поиска коэффицента на который умножается показатель степени экспоненты.
			for (j=0; j<kol_toch_temp; j++)
			{
				*(matr_mnk  + j) = (Temp_smazka[j] - Temp_smazka[0]);		/// Заполнение матрицы входных параметров.
				*(stolb_mnk + j) = -log(Pezo_smazka[j]/Pezo_smazka[0]);		/// Заполнение столбца выходных параметров.
			}

			/// Поиск коэффициента на который умножается показатель степени экспоненты по МНК 
			rezult_mnk = mnk( matr_mnk, N_matr_mnk, M_matr_mnk, stolb_mnk, N_stolb_mnk, M_stolb_mnk, &koeff_mnk, &N_koeff_mnk, &M_koeff_mnk );	

			if (rezult_mnk == 1)
			{
				/// Если МНК преобразование прошло удачно. Найден коэффициент на который умножается степень экспоненты используемой для поиска пъезокоэффицента формула Баруса

				/// Считать коэффициент на который умножается степень экспоненты используемой для поиска пъезокоэффицента формула Баруса
				Koeff_exp_pezo	 = koeff_mnk[0];		

				/// Выдать в отчёт коэффициент на который умножается степень экспоненты используемой для поиска пъезокоэффициента формулы Баруса
				fprintf(f2,"\n  Коэффициент на который умножается степень экспоненты используемой для поиска пъезокоэффициента формулы Баруса  для масла № %3d    =  %20.16f  :  ", Maslo, Koeff_exp_pezo);		

/*				/// Табуляция функции  Пъезокоэффициент = Пъезокоэффициент(T0)  * exp(-A*(T-T0)) 
				fprintf(f2,"\n T  \t Pezo ");			

				double NN, TT;	

				TT=-50.0;		
				while (TT < 250.0)
				{
					NN = Pezo_smazka[0] * exp(-Koeff_exp_pezo*(TT-Temp_smazka[0]));	/// Получить пъезокоэффициент для текущей температуры
					fprintf(f2,"\n %20.16f \t  %20.16f ",  TT , NN);		/// Выдать текущую температуру и пъезокоэффициент
					TT += 5.0;							/// Нарастить температуру на 5 градусов
				}
*/
				/// Освободить область памяти выделенную под хранение столбца коэффициентов найденных по МНК 	
				free(koeff_mnk);		
			}
			else
			{
				/// При неудачном МНК преобразовании выдать предупреждающее сообщение 
				free_mem_rol_max_napr();										/// Освободить память
				printf("\n Неудача при поиске по МНК коэффициента на который умножается показатель экспоненты  ");	/// Выдать сообщение об ошибке
				fprintf(f2,"\n Неудача при поиске по МНК коэффициента на который умножается показатель экспоненты");	/// Выдать сообщение об ошибке
				return -1.0;												/// Выход из программы с признаком неудачи.
			}

			free(stolb_mnk);		// Освободить область памяти выделенную под хранение столбца выходных параметров
			free(matr_mnk);			// Освободить область памяти выделенную под хранение матрицы входных параметров
		}
	}

}


/// Если коэффициенты шагания выходят из диапазона ( 0.01  - 4.00 ) тогда принудительно установить их так чтобы они лежали внутри этого интервала.
if ((koeff_shag_1 > 4.0) || (koeff_shag_1 < 0.01)) koeff_shag_1 = 1;
if ((koeff_shag_2 > 4.0) || (koeff_shag_2 < 0.01)) koeff_shag_2 = 1;
if ((koeff_shag_3 > 4.0) || (koeff_shag_3 < 0.01)) koeff_shag_3 = 0.5;

/// Установить ширину зона окаймления в зависимости от количества участков разбиения.
if (N <=100) 
	max_nom_okaim=1;
else 
	if (N <=200) 
		max_nom_okaim=2;
	else
		if (N <=300) 
			max_nom_okaim=3;
		else
			if (N <=400) 
				max_nom_okaim=4;
			else
				if (N <=500) 
					max_nom_okaim=5;
				else
					if (N <=600) 
						max_nom_okaim=6;
					else
						if (N <=700) 
							max_nom_okaim=7;
						else
							if (N <=800) 
								max_nom_okaim=8;
							else
								max_nom_okaim=9;

switch (vid_profil)
{
	case 1:
	{
		// Ролик имеет профиль "Цилиндрический с бомбиной и фаской".

		// Определить рабочую длину ролика (без учета фасок) РАБОЧАЯ ДЛИНА = ПОЛНАЯ ДЛИНА - 2 * ДЛИНА ФАСКИ
		RL = Lw - 2*dFx;

		// Определить радиус кривизны бомбины ролика.
		br = (PBO*PBO + RL*RL/4 - SL*SL/4)/(2*PBO);
		R = sqrt(br*br + SL*SL/4);

		if (Priz_R_faska == 0)
		{
			// В исходных данных установлено что радиус фаски долженг быть автоматически определен программой

			// Определить радиус кривизны фаски.
			Rf = (Lw-RL)/(2-RL/R);

			// Определить центр кривизны правой фаски ролика.
			Xfc = RL/2*(1-Rf/R);
			Yfc = sqrt(R*R-RL*RL/4)*(1-Rf/R);
		}
		else
		{
			// В исходных данных установлено что необходимо использовать заданный радиус фаски.

			// Определить Рабочую длина = Полная длина - 2 * Длина фаски
			RL = Lw-2*dFx;
			
			// Определить координаты точки сопряжения бомбины и фаски
			Xbf = Lw/2 - dFx;
			Ybf = Dw/2 - PBO;

			// Определить координаты точки сопряжения фаски и торца ролика
			Xft = Lw/2;
			Yft = Dw/2 - dFy;

			// Определить координаты центра кривизны правой фаски ролика.
			kol_okr = poisk_peresech_dvuh_okrug( Xbf,Ybf,Rf, Xft,Yft,Rf, &Xc1_1,&Yc1_1, &Xc1_2, &Yc1_2 );

			if (kol_okr == 0)
			{
				// Нельзя построить фаску радиуса Rf для данного ролика.
				fprintf(f2,"\n Нельзя построить фаску радиуса %8.3f для этого ролика ",Rf);                 
				printf("\n  Nelsya postroit fasku radiusa %8.3f dlya etogo rolika  ", Rf); 

				// Освободить память
				free_mem_rol_max_napr();

				// Завершить работу программы с признаком ошибки.	
				return -1.0;
			}
			else 
			{
				// Взять координаты центра кривизны правой фаски.
				if (kol_okr == 1)
				{
					Xfc = Xc1_1;
					Yfc = Yc1_1;
				}
				else
				{
					Xfc = Xc1_2;
					Yfc = Yc1_2;
				}
			}

			// Определить сдвиг системы координат начало которой находиться в центре кривизны бомбины, 
			// относительно системы координат в центре ролика и изменить координату центра фаски на величину сдвига. 
			Yfc += (sqrt(R*R-SL*SL/4)-Dw/2);
		}


		// Выдать в файл результатов расчета  радиус кривизны бомбины, фаски, координатоы центра правой фаски.
		fprintf(f2,"\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
		fprintf(f2,"\n Радиус кривизны бомбины = %12.3f мм.", R);
		fprintf(f2,"\n Радиус кривизны фаски   = %12.3f мм.", Rf);
		fprintf(f2,"\n Центр правой фаски (%12.3f , %12.3f) мм.", Xfc, Yfc);
		break;
	}

	case 2 :
	{
		// Ролик имеет профиль Лундберга (Логарифмический) 

		// Определить рабочую длину ролика (без учета фасок) РАБОЧАЯ ДЛИНА = ПОЛНАЯ ДЛИНА 
		RL = Lw;

		// Определить "b_Lund" как половину длины ролика.
		b_Lund  = 0.5*Lw;			

		// Определить параметры формулы описывающей логарифмический профиль
		Param_Log_1 = 2*Q_Lund*(1-EP_w*EP_w)/(pi*Lw*E_w);
		Param_Log_2 = 4*(1-EP_w*a_Lund/b_Lund)/(Lw*Lw);

		// Выдать в файл результата расчетов формулу описывающую логарифмический профиль.
		fprintf(f2,"\n																");
		fprintf(f2,"\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
		fprintf(f2,"\n  Формула описывающая профиль ролика							");
		fprintf(f2,"\n																");
		fprintf(f2,"\n   %14.7f * LN(1/(1-%14.7f*X*X)) ", Param_Log_1, Param_Log_2);
		fprintf(f2,"\n																");
		break;
	}

	case 3 :
	{
		// Ролик имеет профиль "Апроксимация профиля Лундберга двумя окружностями".

		// Определить рабочую длину ролика (без учета фасок) РАБОЧАЯ ДЛИНА = ПОЛНАЯ ДЛИНА 
		RL = Lw;

		// Определить "b_Lund" как половину длины ролика.
		b_Lund  = 0.5*Lw;			

		// Определить координату точки сопряжения дуг окружностей №1 и №2 апроксимирующих профиль Лундберга 
		S_d1_d2 = b_Lund*koeff_toch_soprag;	

		// Получить две точки на профиле Лундберга через которые будет проведена 1ая окружность.
		S0 = 0;
		P0 = Lundberg( Q_Lund, Lw, a_Lund, b_Lund, S0 );
		S1 = S_d1_d2;
		P1 = Lundberg( Q_Lund, Lw, a_Lund, b_Lund, S1 );

		// Определить радиус 1ой окружности апроксимирующих профиль Лундберга на участке 0 - S_d1_d2.
		R_Lund_1 = 0.5 * sqr(S1)/(P1);

		// Найти центры окружностей радиусом R_Lund_1 проходящих через точки (S0,P0) и (S1,P1) на кривой Лундберга.
		kol_okr = poisk_peresech_dvuh_okrug( S0, P0, R_Lund_1, S1, P1, R_Lund_1, &Xc1_1, &Yc1_1, &Xc1_2, &Yc1_2);

		if (kol_okr == 0)
		{
			// Нет окружности радиуса R_Lund_1 которые можно провести через две точки  (S0,P0) и (S1,P1) на кривой Лундберга.
			fprintf(f2,"\n  Нет окружности радиуса %14.9f  которые можно провести через две точки (%14.9f,%14.9f) и (%14.9f,%14.9f) ", R_Lund_1, S0, P0, S1, P1);
			printf("\n  Нет окружности радиуса %8.3f  которые можно провести через две точки (%14.9f,%14.9f) и (%14.9f,%14.9f) ", R_Lund_1, S0, P0, S1, P1);

			// Освободить память
			free_mem_rol_max_napr();

			// Завершить работу программы с признаком ошибки.	
			return -1.0;
		}
		else 
		{
			if (kol_okr == 1)
			{
				// Найден одна окружность радиуса R_Lund_1 которую можно провести через точки (S0,P0) и (S1,P1) на кривой Лундберга.
				// Установить координаты центра окружности апроксимирующей кривую Лундберга на участке 0 - S_d1_d2.
				Xc1 = Xc1_1;
				Yc1 = Yc1_1;
			}
			else
			{
				// Найдено две окружности радиуса R_Lund_1 которые можно провести через точки (S0,P0) и (S1,P1) на кривой Лундберга.
				// Установить координаты центра окружности апроксимирующей кривую Лундберга на участке 0 - S_d1_d2.
				// По опыту известно что это первая окружность. 
				Xc1 = Xc1_1;
				Yc1 = Yc1_1;
			}
		}

		// Выдать в отчет параметры 1ой окружности апроксимирующей профиль Лундберга на участве 0 - S_d1_d2.
		fprintf(f2,"\n\n\n Параметры 1ой окруж.апроксим.профиль Лундберга на участве (%14.9f,%14.9f)-(%14.9f,%14.9f)  \n ", S0, P0, S1, P1);
		fprintf(f2,"\n R1 = %14.9f мм.   Xc1 = %14.9f     Yc1 = %14.9f  \n ", R_Lund_1, Xc1, Yc1 );

		// Получить точку на правом конце профиля Лундберга.  
		S2 = b_Lund;
		P2 = Lundberg( Q_Lund, Lw, a_Lund, b_Lund, S2);
	
		// Определить радиус окружности используемой для апроксимации профиля Лундберга на участке S_d1_d2 - Lw/2.
		a_k = 1-sqr(Xc1-S1)/sqr(R_Lund_1)-sqr(Yc1-P1)/sqr(R_Lund_1); 
		b_k = -2/R_Lund_1*(Xc1-S1)*(S1-S2) - 2/R_Lund_1*(Yc1-P1)*(P1-P2);
		c_k = -sqr(S1-S2)-sqr(P1-P2);
		di  = sqr(b_k)-4*a_k*c_k;

		if (di < 0)
		{
			// Дискриминант квадратного уравнения отрицательный. 
			// Не удалось найти радиус окружности апроксимирующей профиль Лундберга на участке S_d1_d2 - Lw/2.
			fprintf(f2,"\n Дискриминант квадр.уравнения отрицательный, не удалось найти радиус окружности апроксимирующей профиль Лундберга на участке (%14.9f,%8.3f) - (%14.9f,%14.9f) ", S1, P1, S2, P2);
			printf("\n Дискриминант квадр.уравнения отрицательный, не удалось найти радиус окружности апроксимирующей профиль Лундберга на участке (%14.9f,%14.9f) - (%14.9f,%14.9f) ", S1, P1, S2, P2);

			// Освободить память
			free_mem_rol_max_napr();

			// Завершить работу программы с признаком ошибки.	
			return -1.0;
		}

		if (a_k == 0) R_Lund_2 = -c_k/b_k; else R_Lund_2 = (-b_k+sqrt(di))/(2*a_k);

		// Найти координаты центра второй окружности апроксимирующей профиль Лкндберга на участке  S_d1_d2 - Lw/2.
		Xc2 = S1 + R_Lund_2/R_Lund_1*(Xc1-S1);
		Yc2 = P1 + R_Lund_2/R_Lund_1*(Yc1-P1);

		// Выдать в отчет параметры 2ой окружности апроксимирующей профиль Лундберга на участве S_d1_d2 - Lw/2.
		fprintf(f2,"\n Параметры 2ой окруж.апроксим.профиль Лундберга на участве (%14.9f,%14.9f)-(%14.9f,%14.9f)  \n ", S1, P1, S2, P2);
		fprintf(f2,"\n R2 = %14.9f      Xc2 = %14.9f     Yc2 = %14.9f  \n ", R_Lund_2, Xc2, Yc2 );
		break;
	}

	case 4 :
	{
		// Ролик имеет профиль "Цилиндрический с двумя бомбинами и фаской".

		// Определить рабочую длину ролика (без учета фасок) РАБОЧАЯ ДЛИНА = ПОЛНАЯ ДЛИНА - 2 * ДЛИНА ФАСКИ
		RL = Lw - 2*dFx;

		// Определить расстояние по оси Х от центра ролика до точки сопряжения бомбины № 1 и бомбины № 2
		L1 = SL/2 + DL_b1;

		// Вычислить радиус кривизны бомбины № 1
		br = (PBO1*PBO1 + L1*L1 - SL*SL/4)/(2*PBO1);
		Rb1 = sqrt(br*br + SL*SL/4);

		// Определить длину бомбины № 2 (с одной стороны от центра ролика)
		DL_b2 = (Lw-2*dFx-2*L1)/2;

		// Вычислить радиус кривизны бомбины № 2
		Lx1 = L1 - SDW_B2;
		Lx2 = L1 + DL_b2 - SDW_B2;
		Lx3 = (Lx2*Lx2 - Lx1*Lx1 + PBO2*PBO2)/(2*PBO2);
		Rb2 = sqrt(Lx3*Lx3 + Lx1*Lx1);

		// Определить координаты точки сопряжения бомбины № 1 и бомбины № 2 (начало координат в центре ролика).
		X_b1_b2 = L1;
		Y_b1_b2 = Dw/2-PBO1;

		// Определить координаты точки соединения бомбины № 2 и фаски (начало координат в центре ролика).
		X_b2_f = L1 + DL_b2;
		Y_b2_f = Dw/2-PBO1-PBO2;

		// Определить координаты центра кривизны бомбины № 2 (начало координат в центре ролика).
		kol_okr = poisk_peresech_dvuh_okrug( X_b1_b2, Y_b1_b2, Rb2, X_b2_f, Y_b2_f, Rb2, &Xb2_c1, &Yb2_c1, &Xb2_c2, &Yb2_c2);

		if (kol_okr == 0)
		{
			// Нельзя построить бомбину № 2 для данного ролика.

			// Выдать предупреждающее сообщение	
			fprintf(f2,"\n Нельзя построить бомбину радиуса %8.5f для этого ролика",Rb2);
			printf("\n Nelsya postroit bombinu radiusa %8.5f dlya etogo rolika",Rb2);

			// Освободить память
			free_mem_rol_max_napr();

			// Завершить работу программы с признаком ошибки.
			return -1.0;
		}
		else if (kol_okr == 1)
		{
			// Взять первый вариант центра в качестве центра кривизны бомбины № 2
			Xb2_c = Xb2_c1;
			Yb2_c = Yb2_c1;
		}
		else if (kol_okr == 2)
		{
			// Взять второй второй вариант центра в качестве центра кривизны бомбины № 2
			Xb2_c = Xb2_c2;
			Yb2_c = Yb2_c2;
		}

		// Определить координаты точки сопряжения бомбины № 2 и фаски.
		Xb2f = Lw/2-dFx;
		Yb2f = Dw/2-PBO1-PBO2;

		// Определить координаты точки сопряжения фаски и торца ролика.
		Xft = Lw/2;
		Yft = Dw/2-PBO1-PBO2-dFy;

		// Определить координаты центра кривизны правой фаски ролика
		kol_okr = poisk_peresech_dvuh_okrug(Xb2f, Yb2f, Rf, Xft, Yft, Rf, &Xf_c1, &Yf_c1, &Xf_c2, &Yf_c2);

		if (kol_okr == 0)
		{
			// Нельзя построить фаску радиусом Rf для данного ролика.

			// Выдать предупреждающее сообщение	
			fprintf(f2,"\n Нельзя построить фаску радиусом %8.5f для этого ролика",Rf);
			printf("\n Nelsya postroit fasku radiusa %8.5f dlya etogo rolika",Rf);

			// Освободить память
			free_mem_rol_max_napr();

			// Завершить работу программы с признаком ошибки.
			return -1.0;
		}
		else if (kol_okr == 1)
		{
			// Взять первый центр в качестве центра кривизны фаски
			Xfc = Xf_c1; 
			Yfc = Yf_c1;	
		}
		else if (kol_okr == 2)
		{	
			// Взять второй центр в качестве центра кривизны фаски
			Xfc = Xf_c2; 
			Yfc = Yf_c2;
		}

		// Выдать в отчет результаты расчетов	
		fprintf(f2,"\n\n ");
		fprintf(f2,"\n Радиус кривизны бомбины № 1 :  Rb1 = %8.5f ", Rb1);
		fprintf(f2,"\n Радиус кривизны бомбины № 2 :  Rb2 = %8.5f ", Rb2);
		fprintf(f2,"\n Центр кривизны бомбины  № 2 :  Xb2_c = %8.5f  Yb2_c = %8.5f ", Xb2_c, Yb2_c);
		fprintf(f2,"\n Точка сопряжения бомбины № 1 и бомбины № 2 :  X_b1_b2 = %8.5f  Y_b1_b2 = %8.5f ", X_b1_b2, Y_b1_b2);
		fprintf(f2,"\n Точка сопряжения бомбины № 2 и фаски  : X_b2_f = %8.5f  Y_b2_f = %8.5f ", X_b2_f, Y_b2_f);
		fprintf(f2,"\n Точка сопряжения фаски и торца ролика : Xft = %8.5f  Yft = %8.5f ", Xft, Yft);
		fprintf(f2,"\n Центр кривизны фаски :  Xfc = %8.5f  Yfc = %8.5f ", Xfc, Yfc);
		fprintf(f2,"\n\n ");
		break;
	}
}


// Запомнить радиус дорожки качения внутреннего кольца без отклонения от идеальной формы (без сплюснутости).
RZM = Rvk;

// Определить диаметр дорожки качения внутреннего кольца
Dvk = 2 * Rvk;

// Определить длину участка на которые разбит ролик.
OM = Lw/N;

// Получить начальное приближение угла перекоса ролика, равное половине угла перекоса внутреннего кольца и
// перевести его из минут в радианы. 
B = TT/2;
B = pi/10800*B;

// Перевести угол перекоса внутреннего кольца из минут в радианы.
TT = pi/10800*TT;

// Определить начальное приближение нагрузки на нижний, самый нагруженный ролик.
PMZ = 4.6*FR/Z;	

// Определить погонную нагрузку в контакте ролика с внутренним кольцом.
qrk = PMZ/RL;

// Определить радиус ролика.
Rw = 0.5 * Dw;

// Определить диаметр дорожки качения наружного кольца в мм.
Dnk = Dvk + 2.0 * Dw + Pm; 

// Определить радиус кривизны дорожки качения наружного кольца в мм.
Rnk = Dnk * 0.5;

// Определить средний диаметр подшипника (Диаметр окружности по которой двигаются центры роликов) в мм.
DM = (Dnk + Dvk) * 0.5;

/////////////////////////////////////////////////////////////////////////////////////////////////////
///

// Определить длину пути который проходит центр ролика при перемещении из одной угловой позиции в другую.
dLcr = pi * DM / Z;

///
//////////////////////////////////////////////////////////////////////////////////////////////////////


fprintf(f2,"\n\n Dvk = %10.4f       Dw = %10.4f        Pm = %10.4f       Dnk = %10.4f       Rnk = %10.4f       DM = %10.4f  \n\n  ", Dvk, Dw, Pm, Dnk, Rnk, DM);
printf("\n\n Dvk = %10.4f       Dw = %10.4f        Pm = %10.4f       Dnk = %10.4f       Rnk = %10.4f       DM = %10.4f  \n\n  ", Dvk, Dw, Pm, Dnk, Rnk, DM);

fprintf(f2,"\n ");
fprintf(f2,"\n                                            Диаметр дорожки качения наружного кольца в мм. = %10.4f ", Dnk);
fprintf(f2,"\n                                    Радиус кривизны дорожки качения наружного кольца в мм. = %10.4f ", Rnk);
fprintf(f2,"\n Средний диаметр подшипника (диаметр окружности по которой двигаются центры роликов) в мм. = %10.4f ", DM);
fprintf(f2,"\n ");
fprintf(f2,"\n ");

if ( Priz_profil_nk == 1 )
{
	/// Профиль дорожки качения наружного кольца считан из файла PROF_NK.DAT и аппроксимирован рядом Фурье
	if (((Rnk-0.01*Rnk) <= sred_R_nk_fure) && (sred_R_nk_fure <= (Rnk+0.01*Rnk)))
	{
		/// Вычисленный радиус дорожки качения наружного кольца близок к среднего радиусу дорожки качения наружного кольца полученному как результат аппроксимации рядом Фурье данных по профилю считанных из файла PROF_NK.DAT
		fprintf(f2,"\n  Rnk = %10.4f     sred_R_nk_fure = %10.4f ",Rnk,sred_R_nk_fure);	 	
	}
	else
	{
		/// Вычисленный радиус дорожки качения наружного кольца сильно отличается от среднего радиуса дорожки качения наружного кольца полученного как результат аппроксимации рядом Фурье данных по профилю считанных из файла PROF_NK.DAT
		fprintf(f2,"\n ПРЕДУПРЕЖДЕНИЕ !!!   ВЫЧИСЛЕННЫЙ РАДИУС ДОРОЖКИ КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА   Rnk = %10.4f   СИЛЬНО ОТЛИЧАЕТСЯ ОТ СРЕДНЕГО РАДИУСА ДОРОЖКИ КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА ПОЛУЧЕННОГО КАК РЕЗУЛЬТАТ АППРОКСИМАЦИИ ДАННЫХ ИЗ ФАЙЛА  PROF_NK.DAT РЯДОМ ФУРЬЕ  sred_R_nk_fure = %10.4f ",Rnk , sred_R_nk_fure);	 	
	} 

	fprintf(f2,"\n ");
	fprintf(f2,"\n ");
}
else
{
 	/// Профиль дорожки качения наружного кольца чисто круглый.
	sred_R_nk_fure = Rnk;
}


// Определить внутренний радиус полого вала в мм
Rv_v = 0.5 * DZ;

// Определить наружный радиус полого вала в мм
Rv_n = 0.5 * D1H;	

// Определить внутренний радиус внутреннего кольца = наружному радиуса полого вала в мм
Rvk_v = Rv_n;

// Определить наружный радиус наружного кольца = наружному диаметру подшипника деленному на 2 = диаметру посадочного отверстия корпуса деленному на 2  в мм.
Rnk_n = 0.5 * DT;	

// Определить внутренний радиус корпуса = наружному радиусу наружного кольца = наружному диаметру подшипника деленному на 2   в мм.
Rk_v =  0.5 * DT;	

// Определить наружный радиус корпуса в мм.
Rk_n = 0.5 * DDZ;

// Определить плотность материала ролика в кг/мм3
RO1_w =	RO_w/1000000;	

// Определить плотность материала внутреннего кольца в кг/мм3
RO1_vk = RO_vk/1000000;	

// Определить плотность материала наружного кольца в кг/мм3
RO1_nk = RO_nk/1000000;		

// Определить плотность материала сепаратора в кг/мм3
RO1_sep = RO_sep/1000000;

// Определить плотность материала вала в кг/мм3
RO1_v = RO_v/1000000;	

// Определить плотность материала корпуса в кг/мм3
RO1_k = RO_k/1000000;		


// Атмосферное давление в кг/мм2 (используется для определения вязкости при атмосферном давлении в формуле Роландса)
Patm = 0.01;			


// Определить плотность масловоздушной смеси для роликов в кг/мм3
RO1_smes_rol = RO1_maslo * Doly;

// Определить плотность масловоздушной смеси для сепаратора в кг/мм3
RO1_smes_sep = RO1_maslo * Doly*Doly /(0.4 + 0.6 * Doly);


// Определить эффективный модуль упругости в кг/мм2 для контакта ролика с дорожкой качения внутреннего кольца
E1_rol_vk = 2/((1-EP_vk*EP_vk)/E_vk + (1-EP_w*EP_w)/E_w);

// Определить эффективный модуль упругости в кг/мм2 для контакта ролика с дорожкой качения наружного кольца
E1_rol_nk = 2/((1-EP_nk*EP_nk)/E_nk + (1-EP_w*EP_w)/E_w);


// Внутренний радиус сепаратора в мм.
Rci = 0.5*Dci; 

// Наружный радиус сепаратора в мм.
Rco = 0.5*Dco;

// Определить средний радиус сепаратора в мм.
RM_sep = 0.5*(Rci + Rco);

// Определить отношение диаметра ролика к среднему диаметру подшипника
YY = Dw/DM;

// Определить эпициклическую частоту вращения сепаратора в оборотах/минута (из скорости вращения внутреннего и наружного кольца.) 
TN_epicikl = 0.5*(B_N*(1-YY) + N_N*(1+YY));
fprintf(f2,"\n         TN_epicikl = %8.5f оборотах/минута ", TN_epicikl);

// Определить эпициклическую частоту вращения ролика в оборотах/минута 
N_w_epicikl = 0.5*(N_N-B_N)*((1-YY*YY)/YY); 
fprintf(f2,"\n         N_w_epicikl = %8.5f оборотах/минута ", N_w_epicikl);


// Определить угловую скорость вращения вала и внутреннего кольца в радиан/секунда
W_vk = 2*pi*B_N/60;

// Определить угловую скорость вращения наружного кольца и корпуса в радиан/секунда
W_nk = 2*pi*N_N/60;

// Определить эпициклическую угловую скорость сепаратора в радианах/секунда
W_sep_epicikl = 2*pi*TN_epicikl/60;

// Определить эпициклическую угловую скорость вращения ролика в радиан/секунда
W_w_epicikl = 2*pi*N_w_epicikl/60;

// Задать начальное приближение угловой скорости вращения сепаратора в радиан/секунда равное эпициклической
W_sep = W_sep_epicikl;

// Задать  начальное приближение угловой скорости вращения ролика в радиан/секунда равное эпицимклической
W_w = W_w_epicikl;			

// Определить момент инерции цилиндрического ролика в кг*мм2 ( ??? как цилиндра с ошибкой )
Jw = RO1_w * pi * sqr(Rw) * Lw * sqr(Rw)/2;


// Перебор в цикле всех участков ролика, получение профиля ролика и запись его в массив.
for (i=0; i<N; i++)
{
	// Определить плечо текущего участка ролика (расcтояние от текущего участка до середины ролика).
	xi = i*OM+OM/2-Lw/2 ;

	switch (vid_profil)
	{
		case 1:
			// Для цилиндрического ролика с бомбиной. 
			if ( ((xi>RL/2) && (xi<=Lw/2)) || ((xi>=-Lw/2) && (xi<-RL/2)) )
			{
				// Для фаски
				ci = sqrt(R*R-SL*SL/4) - sqrt(Rf*Rf-(fabs(xi)-Xfc)*(fabs(xi)-Xfc)) - Yfc;
			}
			else
			{
				if ( ((xi>SL/2) && (xi<=RL/2)) || ((xi>=-RL/2) && (xi<-SL/2)) )
				{
					// Для бомбины
					ci = sqrt(R*R-SL*SL/4)-sqrt(R*R-xi*xi);		
				}
				else
				{
					// Для цилиндра
					ci = 0;
				}
			}
			break;

		case 2:
			// Для ролика с профилем Лундберга

			// Вычислить уменьшение радиуса ролика с помощью функции профиля Лундберга.
			ci = Lundberg( Q_Lund, Lw, a_Lund, b_Lund, fabs(xi) );
			break;

		case 3:
			//  Для ролика с апроксимации профиля Лундберга двумя окружностями

			abs_xi = fabs(xi);
			if (abs_xi < S_d1_d2)
			{
				// Вычислить уменьшение радиуса ролика с помощью нижней дуги 1ой окружности.
				ci = Yc1-sqrt(sqr(R_Lund_1)-sqr(abs_xi-Xc1)); 
			}
			else
			{
				// Вычислить уменьшение радиуса ролика с помощью нижней дуги 2ой окружности.
				ci = Yc2-sqrt(sqr(R_Lund_2)-sqr(abs_xi-Xc2)); 
			}
			break;

		case 4:
			// Для ролика с профилем цилиндрическим, двумя бомбинами и фаской.
			if (((xi > RL/2) && (xi <= Lw/2)) || ((xi >= -Lw/2) && (xi < - RL/2)))
			{	
				// Для фаски
				ci = Dw/2-(sqrt(sqr(Rf)-sqr(fabs(xi)-Xfc)) + Yfc);
			}
			else if (((xi > L1) && (xi <= RL/2)) || ((xi >= -RL/2) && (xi < -L1)))
			{
				// Для бомбины № 2
				ci = Dw/2-(sqrt(sqr(Rb2)-sqr(fabs(xi)-Xb2_c)) + Yb2_c);
			}
			else if (((xi > SL/2) && (xi <= L1)) || ((xi >= -L1) && (xi < - SL/2)))
			{
				// Для бомбина № 1
				ci = sqrt(Rb1*Rb1-SL*SL/4)-sqrt(Rb1*Rb1-xi*xi);
			}
			else
			{
				// Для цилиндра
				ci = 0;
			}
			break;
	}

	// Записать в массив профиль на текущем участке
	*(profil+i) = Rw-ci;	
}


/// Определить массу сепаратора в кг
if (Dc < Dcb)
{
	 //  Диаметр поверхности центрирования сепаратора ( на дорожке качения кольца)  меньше диаметра центрирующей поверхности сепаратора ( на сепараторе).
	 //  В подшипнике центрирование сепаратора идет по внутреннему кольцу.  
	 //  Центрирующие пояски расположены на внутренней поверхности сепаратора.
	 //	
	M_sep_kg = (pi*(Rco*Rco-Rci*Rci)*Lc + pi*(Rci*Rci-Dcb*Dcb/4)*Lcb - Okno_sep_H1*Okno_sep_H2*(Rco-Rci)*Z) * RO1_sep;
}
else
{
	 //	В подшипнике центрирование сепаратора идет по наружному кольцу
	 //  Центрирующие пояски раположены на наружной поверхности сепаратора.
	 //
	M_sep_kg = (pi*(Rco*Rco-Rci*Rci)*Lc +  pi*(Dcb*Dcb/4-Rco*Rco)*Lcb - Okno_sep_H1*Okno_sep_H2*(Rco-Rci)*Z) * RO1_sep;
}


// Определить ширину перемычки сепаратора в мм.
Bcs = (pi * (Dco+Dci)/2 - Okno_sep_H2 * Z)/Z;

// Выдать в отчет ширину перемычки сепаратора в мм. 
fprintf(f2,"\n\n Ширина перемычки сепаратора  = %17.8f мм ", Bcs);	
printf("\n\n   Shirina peremychki separatora = %17.8f mm ", Bcs);	


// Определить средний зазор ролика в межколеном пространстве в мм.
Cw = Zazor_rol();

// Выдать в отчет средний зазор ролика в межколечном пространстве в мм.
fprintf(f2,"\n Средний зазор ролика в межколечном пространстве  = %17.8f мм  \n\n", Cw);	
printf("\n Srednii zazor rolika v megkolechnom prostranstve  = %17.8f mm \n\n", Cw);	


/// Задать начальное значение счетчика итераций цикла поиска угловой скорости сепаратора
nom_it_w_sep = 0;


/// Определить начальное приближение сближения нижнего самого нагруженного ролика с внутренним кольцом.
DFI = qrk* ((1-EP_w*EP_w)/(pi*E_w)+(1-EP_vk*EP_vk)/(pi*E_vk)) * (log((Rvk+Rw)/(((1-EP_w*EP_w)/(pi*E_w)+(1-EP_vk*EP_vk)/(pi*E_vk))*qrk)) + 0.814);

/// Получить начальное приближение сближения нижнего самого нагруженного ролика с наружным кольцом.
DF  = qrk* ((1-EP_w*EP_w)/(pi*E_w)+(1-EP_vk*EP_vk)/(pi*E_vk)) * (log((Rnk-Rw)/(((1-EP_w*EP_w)/(pi*E_w)+(1-EP_vk*EP_vk)/(pi*E_vk))*qrk)) + 0.814);

/// Определить сближение осей наружного и внутреннего кольца произошедшее под действием радиальной нагрузки.
DR = DFI + DF + P/2;

//DR = 0.0034;
//DR = 0.1;

/// Итерационный цикл подбора угловой скорости сепаратора, сближения колец, распределения нагрузки по роликам.
while (1)
{

	/// Выдать в отчет номер итерации
	fprintf(f2,"\n\n   -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - ");	
	fprintf(f2,"\n							ИТЕРАЦИЯ ПОИСКА УГЛОВОЙ СКОРОСТИ СЕПАРАТОРА № %3d \n\n", nom_it_w_sep);
	printf("\n\n   -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - ");	
	printf("\n							ИТЕРАЦИЯ ПОИСКА УГЛОВОЙ СКОРОСТИ СЕПАРАТОРА № %3d \n\n", nom_it_w_sep);

	if (Priz_P_rab)
	{
		/// Установлено определить радиальный зазор в подшипнике в рабочих условиях.

		///	Входные параметры : 
		///
		///	Rv_v	- Внутренний радиус полого вала							/ мм / 
		///	Rv_n	- Наружный радиус полого вала (посадочный на внутреннее кольцо)			/ мм / 
		///	EP_v 	- Коэффициент Пуассона материала вала
		///	E_v	- Модуль упругости материала вала						/ кгс/мм2 /
		///	RO1_v	- Плотность материала вала							/ кг/мм3 /
		///	At_v	- Коэффициент линейного теплового расширения вала				/ 1/Градус C /
		///	T_v	- Температура вала в рабочих условиях в градусах Цельсия			/ Градус C /
		///
		///	Rvk_v	- Внутренний радиус внутреннего кольца (посадочный на вал)			/ мм /
		///	Rvk	- Наружный радиус внутреннего кольца   (радиус дорожки качения ВК)		/ мм /
		///	EP_vk	- Коэффициент Пуассона материала внутреннего кольца
		///	E_vk	- Модуль упругости материала внутреннего кольца					/ кгс/мм2 /
		///	RO1_vk	- Плотность материала внутреннего кольца					/ кг/мм3 /
		///	At_vk	- Коэффициент линейного теплового расширения внутреннего кольца			/ 1/Градус C /
		///	T_vk	- Температура внутреннего кольца в рабочих условиях в градусах Цельсия		/ Градус C /
		///
		///	Rnk	- Внутренний радиус наружнего кольца (радиус дорожки качения НК)		/ мм /
		///	Rnk_n	- Наружный радиус наружного кольца (посадочный в корпус)			/ мм /
		///	EP_nk 	- Коэффициент Пуассона материала наружного кольца
		///	E_nk	- Модуль упругости материала наружного кольца					/ кгс/мм2 /
		///	RO1_nk	- Плотность материала наружного кольца						/ кг/мм3 /
		///	At_nk	- Коэффициент линейного теплового расширения наружного кольца			/ 1/Градус C /
		///	T_nk	- Температура наружного кольца в рабочих условиях в градусах Цельсия		/ Градус C /
		///
		///	D	- Диаметр ролика								/ мм /
		///	EP_w 	- Коэффициент Пуассона материала ролика                                         
		///	E_w	- Модуль упругости материала ролика						/ кгс/мм2 /
		///	RO1_w	- Плотность материала ролика 							/ кг/мм3 /
		///	At_r	- Коэффициент линейного теплового расширения ролика 				/ 1/Градус C /
		///	T_w	- Температура ролика в рабочих условиях в градусах Цельсия			/ Градус C /
		///
		///	Rk_v	- Внутренний радиус корпуса (посадочный на наружное кольцо)			/ мм /
		///	Rk_n	- Наружный радиус корпуса							/ мм /
		///	EP_k 	- Коэффициент Пуассона материала корпуса
		///	E_k 	- Модуль упругости материала корпуса						/ кгс/мм2 /
		///	RO1_k	- Плотность материала корпуса							/ кг/мм3 /
		///	At_k	- Коэффициент линейного теплового расширения материала корпуса			/ 1/Градус C /	
		///	T_k	- Температура корпуса в рабочих условиях в градусах Цельсия			/ Градус C /
		///
		///	XI_vk_v	- Коэффициент учитывающий разность длин сопрягаемого внутреннего кольца и вала	
		///	XI_nk_k - Коэффициент учитывающий разность длин сопрягаемого наружного кольца и корпуса	
		///
		///	G	- Ускорение свободного падения							/ мм/с2	/ 
		///	W_vk	- Угловая скорость вращения вала и внутреннего кольца				/ радиан/секунда / 
		///	W_nk	- Угловая скорость вращения наружного кольца 					/ радиан/секунда / 
		///	HB	- Натяг в месте посадки внутреннего кольца на вал при монтаже			/ мм /
		///	HK	- Натяг в месте посадки наружного кольца в корпус при монтаже			/ мм /
		///	Pm	- Номинальный радиальный зазор в подшипнике 					/ мм /
		///	Tm	- Температура монтажа в градусах Цельсия					/ Градус C /
		///
		/// 	Возвращаемое значение :	Радиальный зазор в подшипнике в рабочих условиях		/ мм /.
		///	

		P =	Rab_rad_zazor( 	Rv_v,    Rv_n,		EP_v,  E_v,  RO1_v,	At_v,  T_v,					 
					Rvk_v,   Rvk,		EP_vk, E_vk, RO1_vk,	At_vk, T_vk,
					Rnk,     Rnk_n,		EP_nk, E_nk, RO1_nk,	At_nk, T_nk,
					Dw, 			EP_w,  E_w,  RO1_w,	At_r,  T_w,
					Rk_v,    Rk_n,		EP_k,  E_k,  RO1_k,	At_k,  T_k,	
					XI_vk_v, XI_nk_k,	G,     W_vk, W_nk,	HB,    HK,    Pm,	Tm );
	}
	else
	{
		/// Установлено положить рабочий радиальный зазор равным заданному в исходных данных радиальному зазору.
		P = Pm;
	}

	/// Выдать в отчет величину номинального и рабочего радиального зазора
	printf("\n\n Pnom = %10.6f     P = %10.6f     \n",Pm , P);
	fprintf(f2,"\n\n Pnom = %10.6f     P = %10.6f     \n",Pm , P);

	/// Задание допустимой относительной погрешности в зависимости от радиальной нагрузки.
	if (FR > 1000) 
	{
		FPZ=0.02;
	}
	else 
	{
		if ((FR > 500) && (FR <= 1000)) 
		{
			FPZ=0.1;
		}
		else
		{		
			FPZ=0.2;
		}
	}

	/// Решение уравнения равновесия внутреннего кольца, уточнение DR - сближение осей внутреннего и наружного коьца
	while (1)
	{
		// Задать величину малого преращения по переменной "DR"
		h = 0.01*DR;
		if (h==0.0) h=0.000001;

		/// Вызов функции определения невязки уравнения равновесия внутреннего кольца.
		///
		///	Входные параметры :     DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		///						 W_sep - Угловая скорость вращения сепаратора в радиманах/секунда	
		///	Выходные параметры :   bmo - Суммарный момент действующий на внутреннее кольцо
		///
		FRAZ = pprz(DR, &bmo, W_sep);
		printf("\n  DR = %10.8f   FRAZ = %10.8f ", DR, FRAZ);	

		// Если невязка уравнения равновесия внут.кольца меньше допустимой погрешности тогда решение найдено. Выход из цикла поиска решения.
		if (fabs(FRAZ/FR*100)<=FPZ) break;


		// Запомнить невязку уравнения равновесия внутреннего кольца и величину сближения колец в точке 0.
		FRAZ_0 = FRAZ;
		DR_0   = DR;
	
		// Сделать малое преращение DR.
		DR = DR_0 + h;

		/// Вызов функции определения невязки уравнения равновесия внутреннего кольца.
		///
		///	Входные параметры :	   DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		///				W_sep - Угловая скорость вращения сепаратора в радиманах/секунда	
		///	Выходные параметры :   	  bmo - Суммарный момент действующий на внутреннее колтцо
		///
		FRAZ = pprz(DR, &bmo, W_sep);
		printf("\n  DR = %10.8f   FRAZ = %10.8f ", DR, FRAZ);	

		// Если невязка уравнения равновесия внут.кольца меньше допустимой погрешности тогда решение найдено. Выход из цикла поиска решения.
		if (fabs(FRAZ/FR*100)<=FPZ) break;

		// Запомнить невязку уравнения равновесия внутреннего кольца и величину сближения колец в точке 1.
		FRAZ_1 = FRAZ;
		DR_1   = DR;

		// Сделать второе малое преращение DR.
		DR = DR_0 + 2*h;

		/// Вызов функции определения невязки уравнения равновесия внутреннего кольца.
		///
		///	Входные параметры :	    DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		///				 W_sep - Угловая скорость вращения сепаратора в радиманах/секунда	
		///	Выходные параметры :   	   bmo - Суммарный момент действующий на внутреннее колтцо
		///
		FRAZ = pprz(DR, &bmo, W_sep);
		printf("\n  DR = %10.8f   FRAZ = %10.8f ", DR, FRAZ);	

		// Если невязка уравнения равновесия внут.кольца меньше допустимой погрешности тогда решение найдено. Выход из цикла поиска решения.
		if (fabs(FRAZ/FR*100)<=FPZ) break;

		// Запомнить невязку уравнения равновесия внутреннего кольца и величину сближения колец в точке 2.
		FRAZ_2 = FRAZ;
		DR_2   = DR;

		// Сделать малое обратное преращение DR.
		DR = DR_0 - h;


		/// Вызов функции определения невязки уравнения равновесия внутреннего кольца.
		///
		///	Входные параметры :		 DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		///				      W_sep - Угловая скорость вращения сепаратора в радиманах/секунда	
		///	Выходные параметры :   		bmo - Суммарный момент действующий на внутреннее кольцо
		///
		FRAZ = pprz(DR, &bmo, W_sep);
		printf("\n  DR = %10.8f   FRAZ = %10.8f ", DR, FRAZ);	

		// Если невязка уравнения равновесия внут.кольца меньше допустимой погрешности тогда решение найдено. Выход из цикла поиска решения.
		if (fabs(FRAZ/FR*100)<=FPZ) break;

		// Запомнить невязку уравнения равновесия внутреннего кольца и величину сближения колец в точке -1.
		FRAZ_m1 = FRAZ;
		DR_m1   = DR;

		// Сделать второе малое обратное преращение DR.
		DR = DR_0 - 2*h;


		/// Вызов функции определения невязки уравнения равновесия внутреннего кольца.
		///
		///	Входные параметры :		   DR - Сближение осей внутреннего и наружного колец произошедшее из за действия радиальной нагрузки.
		///					W_sep - Угловая скорость вращения сепаратора в радиманах/секунда	
		///	Выходные параметры :              bmo - Суммарный момент действующий на внутреннее кольцо
		///
		FRAZ = pprz(DR, &bmo, W_sep);
		printf("\n  DR = %10.8f   FRAZ = %10.8f ", DR, FRAZ);	

		// Если невязка уравнения равновесия внут.кольца меньше допустимой погрешности тогда решение найдено. Выход из цикла поиска решения.
		if (fabs(FRAZ/FR*100)<=FPZ) break;

		// Запомнить невязку уравнения равновесия внутреннего кольца и величину сближения колец в точке -2.
		FRAZ_m2 = FRAZ;
		DR_m2   = DR;


		if ((FRAZ_2 == FRAZ_1) && (FRAZ_1 == FRAZ_m1) && (FRAZ_m1 == FRAZ_m2))
		{
			// Невозможно найти производную невязки уравнения равновесия внутреннего кольца  по переменной "DR" 
			// Взять другое значение DR
			DR = DR_0 * 2.0;
		}
		else
		{
			// Найти производную невязки уравнения равновесия внутреннего кольца по переменной "DR" по 4х точечной формуле.
			dFRAZ_dDR = (-FRAZ_2 + 8*FRAZ_1 - 8*FRAZ_m1 + FRAZ_m2)/(12*h);

			// Шагание по методу Ньютона и нахождение следующего приближения "DR".
			DR =  DR_0 - koeff_shag_2 * FRAZ_0/dFRAZ_dDR;
		}

	}

	/// Определение долговечности по контактному напряжению для 1 мерного распределения напряжений 
	/// в контакте роликов с дорожками качения наружного и внутреннего колец.
	L_pod = DOLG1();

	/// Определить долговечность подшипника в часах по контактному напряжению
	L_pod_h = 1000000 * L_pod /(B_N - N_N)/60;  
	
	/// Определение долговечности по контактному напряжению для 1 мерного распределения напряжений 
	/// в контакте роликов с дорожками качения наружного и внутреннего колец по методике С.В.Батенкова
	L_BAT_pod = DOLG1_BAT();		

	/// Определить долговечность подшипника в часах по контактному напряжению по методике  С.В. Батенкова
	L_BAT_pod_h = 1000000 * L_BAT_pod /(B_N - N_N)/60;

	/// Определение долговечности подшипника по контактному напряжению по методике Бейзельмана
	L_BEISELMAN_pod = DOLG1_BEISELMAN();
	
	/// Определить долговечность подшипника в часах по контактному напряжению по методике  Бейзельмана
	L_BEISELMAN_pod_h = 1000000 * L_BEISELMAN_pod / (B_N - N_N)/60;

	/// Найдено решение уравнения равновесия внутреннего кольца. Выдать результаты расчета.
	fprintf(f2,"\n								");
	fprintf(f2,"\n								");
	fprintf(f2,"\n	                                                       ТАБЛИЦА %d.	",nom_tab);
	nom_tab++;
	fprintf(f2,"\n               P E З У Л Ь T A T Ы   C И Л O B O Г O				");
	fprintf(f2,"\n         P A C Ч E T A   P O Л И K O П O Д Ш И П H И K A :			");
	fprintf(f2,"\n								");
	fprintf(f2,"\n Радиальная нагрузка           FR = %10.1f кгс  ",FR);
	fprintf(f2,"\n Рабочий радиальный зазор       P = %10.8f мм   ",P);
	fprintf(f2,"\n Сближение колец               DR = %10.8f мм   ",DR);
	fprintf(f2,"\n Момент обусловл.несоосностью	BMO = %12.5f кг*мм ",bmo);
	fprintf(f2,"\n								");
	fprintf(f2,"\n Долговечность подшипника по контактным напряжениям L_pod_h = %20.10f час. ",L_pod_h);
	fprintf(f2,"\n Долговечность подшипника по контактным напряжениям вычисленная по методике С.В.Батенкова L_BAT_pod_h = %20.10f час. ",L_BAT_pod_h);
	fprintf(f2,"\n Долговечность подшипника по контактным напряжениям вычисленная по методике Бейзельмана   L_BEISELMAN_pod_h = %20.10f час. ",L_BEISELMAN_pod_h);
	fprintf(f2,"\n");


	/// Перебор в цикле всех роликов и определение самого нагруженного ролика в контакте с дорожкой качения внутреннего кольца
	nom_rolik_QJ_max = 0;
	QJ_max = *(QJ+0);

	for (k=0; k<Z; k++)
	{
		if (*(QJ+k) > QJ_max)
		{
			nom_rolik_QJ_max = k;
                        QJ_max = *(QJ+k);
		}
	}
	
	fprintf(f2,"\n\n Самым нагруженным роликом является ролик № %3d.    Усилие в контакте ролика с дорожкой качения ВК = %12.8f  \n\n", nom_rolik_QJ_max+1, QJ_max);


	// Перебор в цикле всех роликов и определение максимальной ширины полосы контакта 
	// каждого ролика с внутренним и наружным кольцом.
	for (k=0; k<Z; k++)
	{
		// Определить максимальную ширину полосы контакта ролика № k с внутренним кольцом
		max_shirina_v = *(Bv+k*N+0);
		for (i=1; i<N; i++)	if (*(Bv+k*N+i) > max_shirina_v) max_shirina_v = *(Bv+k*N+i);
		*(BVmax+k) = max_shirina_v;

		// Определить максимальную ширину полосы контакта ролика № k с наружным кольцом
		max_shirina_n = *(Bn+k*N+0);
		for (i=1; i<N; i++)	if (*(Bn+k*N+i) > max_shirina_n) max_shirina_n = *(Bn+k*N+i);
		*(BNmax+k) = max_shirina_n;
	}

	// Определить максимальную ширину полосы контакта для ролика № 0
    	if (*(BNmax+0) > *(BVmax+0)) 
	{
		max_pol_shirina = *(BNmax+0)/2;
	}
	else
	{
		max_pol_shirina = *(BVmax+0)/2;
	}

	// Определить количество участков по ширине зоны контакта.
	kol_uch_polushirina=int(max_pol_shirina/OM)+1;
	kol_uch_polushirina+=3;								//  Дополнительное увеличение количества участков по ширине полосы.
	kol_uch_shirina = kol_uch_polushirina*2+1;

	// Выделение области памяти для массива описывающего деформацию в контакте ролика и внутреннего кольца.
	DB2 = (double *) malloc(Z*N*kol_uch_shirina*sizeof(double));
	if (DB2 == NULL)
	{
		// Неудача при выделении памяти для хранения массива деформаций в контакте ролика и внутреннего кольца.
		// Освободить память
		free_mem_rol_max_napr();

		// Выдать сообщение об ошибке.
		printf("\n Неудача при выделении памяти для хранения массива деформаций в контакте ролика и внутреннего кольца");
		fprintf(f2,"\n Неудача при выделении памяти для хранения массива деформаций в контакте ролика и внутреннего кольца");

		// Выход из программы с признаком неудачи.
		return -1.0;
	}

	/// Выделение области памяти для массива напряжений контакте ролика и внутреннего кольца.
	SIGI2 = (double *) malloc(Z*N*kol_uch_shirina*sizeof(double));
	if (SIGI2 == NULL)
	{
		// Неудача при выделении памяти для хранения массива напряжений в контакте ролика и внутреннего кольца.
		// Освободить память
		free_mem_rol_max_napr();

		// Выдать сообщение об ошибке.
		printf("\n Неудача при выделении памяти для хранения массива напряжений в контакте ролика и внутреннего кольца");
		fprintf(f2,"\n Неудача при выделении памяти для хранения массива напряжений в контакте ролика и внутреннего кольца");

		// Выход из программы с признаком неудачи.
		return -1.0;
	}

	// Выделение области памяти для массива описывающего деформацию в контакте ролика и наружного кольца.
	DH2 = (double *) malloc(Z*N*kol_uch_shirina*sizeof(double));
	if (DH2 == NULL)
	{
		// Неудача при выделении памяти для хранения массива деформаций в контакте ролика и наружного кольца.
		// Освободить память
		free_mem_rol_max_napr();

		// Выдать сообщение об ошибке.
		printf("\n Неудача при выделении памяти для хранения массива деформаций в контакте ролика и наружного кольца");
		fprintf(f2,"\n Неудача при выделении памяти для хранения массива деформаций в контакте ролика и наружного кольца");

		// Выход из программы с признаком неудачи.
		return -1.0;
	}


	/// Выделение области памяти для массива напряжений контакте ролика и наружного кольца.
	SIGO2 = (double *) malloc(Z*N*kol_uch_shirina*sizeof(double));
	if (SIGO2 == NULL)
	{
		// Неудача при выделении памяти для хранения массива напряжений в контакте ролика и наружного кольца.
		// Освободить память
		free_mem_rol_max_napr();

		// Выдать сообщение об ошибке.
		printf("\n Неудача при выделении памяти для хранения массива напряжений в контакте ролика и наружного кольца");
		fprintf(f2,"\n Неудача при выделении памяти для хранения массива напряжений в контакте ролика и наружного кольца");

		// Выход из программы с признаком неудачи.
		return -1.0;
	}

	/// Определить номер центральной полосы области контакта.
	nom_centr_polosy_zona_kontakt = kol_uch_polushirina;

	/// Обнуление массивов деформаций и напряжений в контакте всех роликов с внутренним и наружным кольцом.
	for (k=0; k<Z; k++)  
		for (i=0; i<N; i++)  
    			for (j=0; j<kol_uch_shirina; j++) 
			{
				*(DB2+N*kol_uch_shirina*k+kol_uch_shirina*i+j)=0;
				*(DH2+N*kol_uch_shirina*k+kol_uch_shirina*i+j)=0;
				*(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+j)=0;
				*(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+j)=0;
			}

	/// Перебор в цикле всех роликов и построение двухмерной деформации в контакте всех роликов с наружным и внутренним кольцом.
	for (k=0; k<Z; k++)
	{
		// Обнулить усилие в контакте ролика с дорожкой качения внутреннего кольца
		Sum_Q1 = 0;    

		// Для ролика № k заполнить двухмерные массивы деформаций и напряжений в контакте ролика с дорожкой качения внутреннего кольца.
		for (i=0; i<N; i++)
		{
			// Определить полуширину в сечении № i области контакта ролика и внутреннего кольца.
			polushirina_tek_uch = *(Bv+k*N+i)/2;

			// Считать деформацию центре сечения № i области контакта ролика и внутреннего кольца.
			def_i_o = *(DB+k*N+i);
			if (def_i_o < 0) def_i_o=0;

			if (def_i_o > 0.0)
			{	
				// Есть деформация в центре сечения № i

				// Записать деформацию на участке в центре сечения № i контакта ролика с внутренним кольцом.
				*(DB2+N*kol_uch_shirina*k+kol_uch_shirina*i+nom_centr_polosy_zona_kontakt)=def_i_o;

				// Определить погонную нагрузку в кг/мм на участке
				Qpog = step(def_i_o,1.11)/( step(ak,1.11)*step(RL,0.11));

				// Определить нормальное напряжение в кг/мм2 в центре сечения № i в контакте ролика с внутренним кольцом.
				if (polushirina_tek_uch > 0)
				{
					sigma_i_o = 2*Qpog/(pi*polushirina_tek_uch);
				}
				else
				{
					sigma_i_o = 0;
				}

				// Записать напряжение на участке в центре сечения № i в контакте ролика с внутренним кольцом
				*(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+nom_centr_polosy_zona_kontakt) = sigma_i_o;

				// Нарастить суммарное усилие в контакте ролика с дорожкой качения внутреннего кольца
				Sum_Q1 += (sigma_i_o*OM*OM);


				// Заполнить все участки сечения № i контакта ролика с внутренним кольцом.
				for(j=1; j<kol_uch_polushirina; j++)
				{
					// Используя формулу эллипса с осями "polushirina_tek_uch" и "def_i_o" определить
					// деформацию на участках отстоящих на j и -j от центра сечения № i
					// и записать ее в двумерный массив деформаций.
					def_i_j = sqr(def_i_o)-sqr(def_i_o)/sqr(polushirina_tek_uch)*sqr(j*OM);
					if (def_i_j < 0) def_i_j=0;
					def_i_j = sqrt(def_i_j);

					if (def_i_j > 0.0)
					{
						// Есть деформация на участках № i,j и i,-j записать ее в массив деформаций 
						// в контакте ролика с внутренним кольцом. 
						*(DB2+N*kol_uch_shirina*k+kol_uch_shirina*i+nom_centr_polosy_zona_kontakt+j)=def_i_j;
						*(DB2+N*kol_uch_shirina*k+kol_uch_shirina*i+nom_centr_polosy_zona_kontakt-j)=def_i_j;
					}

					// Используя формулу эллипса с осями "polushirina_tek_uch" и "SIGMA_i_o" определить 
					// напряжение на участках отстоящих на j и -j от центра сечения N i
					// и записать ее в двумерный массив напряжений.
					sigma_i_j = sqr(sigma_i_o)-sqr(sigma_i_o)/sqr(polushirina_tek_uch)*sqr(j*OM);					
					if (sigma_i_j < 0) sigma_i_j=0;
					sigma_i_j = sqrt(sigma_i_j);

					if (sigma_i_j > 0.0)
					{
						// Есть напряжение на участках № i,j и i,-j записать ее в массив напряжений
						// в контакте ролика с внутренним кольцом. 
						*(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+nom_centr_polosy_zona_kontakt+j) = sigma_i_j;
						*(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+nom_centr_polosy_zona_kontakt-j) = sigma_i_j;

						// Нарастить суммарное усилие в контакте ролика с дорожкой качения внутреннего кольца
						Sum_Q1 += (2*sigma_i_j*OM*OM);
					}
				}
			}
		}

		if (Sum_Q1 > 0.0) 
		{
			// Определить коэффициент умножения для двухмерного массива напряжений в контакте ролика с дорожкой качения внутреннего кольца
			k_q = *(QJ+k)/Sum_Q1;

			// Умножить двухмерный массив напряжений в контакте ролика с дорожкой качения внутреннего кольца на найденный коэффициент.
			for (i=0; i<N; i++) for (j=0; j<kol_uch_shirina; j++) *(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+j) *= k_q;
		}

		// Обнулить усилие в контакте ролика с дорожкой качения наружного кольца
		Sum_Q1 = 0;    

		// Для ролика № k заполнить двухмерные массивы деформаций и напряжений в контакте ролика с дорожкой качения наружного кольца.
		for (i=0; i<N; i++)
		{
			// Определить полуширину в сечении № i области контакта ролика и наружного кольца.
			polushirina_tek_uch = *(Bn+k*N+i)/2;

			// Считать деформацию центре сечения № i области контакта ролика и наружного кольца.
			def_i_o = *(DH+k*N+i);
			if (def_i_o < 0) def_i_o=0;

			if (def_i_o > 0.0)
			{
				// Есть деформация в центре сечения № i

				// Записать деформацию на участке в центре сечения № i контакта ролика с наружным кольцом.
				*(DH2+N*kol_uch_shirina*k+kol_uch_shirina*i+nom_centr_polosy_zona_kontakt)=def_i_o;

				// Определить погонную нагрузку в кг/мм на участке
				Qpog = step(def_i_o,1.11)/(step(ak,1.11)*step(RL,0.11));

				// Определить нормальное напряжение в кг/мм2 в центре сечения № i в контакте ролика с наружным кольцом.
				if (polushirina_tek_uch > 0)
				{
					sigma_i_o = 2*Qpog/(pi*polushirina_tek_uch);
				}
				else
				{
					sigma_i_o = 0;
				}

				// Записать напряжение на участке в центре сечения № i в контакте ролика с внутренним кольцом
				*(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+nom_centr_polosy_zona_kontakt) = sigma_i_o;

				// Нарастить суммарное усилие в контакте ролика с дорожкой качения наружного кольца
				Sum_Q1 += (sigma_i_o*OM*OM);

				// Заполнить все участки сечения № i контакта ролика с наружным кольцом.  
				for(j=1; j<kol_uch_polushirina; j++)
				{
					// Используя формулу эллипса с осями "polushirina_tek_uch" и "def_i_o" определить
					// деформацию на участках отстоящих на j и -j от центра сечения № i
					// и записать ее в двумерный массив деформаций.
					def_i_j = sqr(def_i_o)-sqr(def_i_o)/sqr(polushirina_tek_uch)*sqr(j*OM);
					if (def_i_j < 0) def_i_j=0;
					def_i_j = sqrt(def_i_j);

					if (def_i_j > 0.0)
					{
						// Есть деформация на участках № i,j и i,-j записать ее в массив деформаций 
						// в контакте ролика с наружным кольцом. 
						*(DH2+N*kol_uch_shirina*k+kol_uch_shirina*i+nom_centr_polosy_zona_kontakt+j)=def_i_j;
						*(DH2+N*kol_uch_shirina*k+kol_uch_shirina*i+nom_centr_polosy_zona_kontakt-j)=def_i_j;
					}

					// Используя формулу эллипса с осями "polushirina_tek_uch" и "SIGMA_i_o" определить 
					// напряжение на участках отстоящих на j и -j от центра сечения N i
					// и записать ее в двумерный массив напряжений.
					sigma_i_j = sqr(sigma_i_o)-sqr(sigma_i_o)/sqr(polushirina_tek_uch)*sqr(j*OM);					
					if (sigma_i_j < 0) sigma_i_j=0;
					sigma_i_j = sqrt(sigma_i_j);

					if (sigma_i_j > 0.0)
					{
						// Есть напряжение на участках № i,j и i,-j записать ее в массив напряжений
						// в контакте ролика с внутренним кольцом. 
						*(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+nom_centr_polosy_zona_kontakt+j) = sigma_i_j;
						*(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+nom_centr_polosy_zona_kontakt-j) = sigma_i_j;

						// Нарастить суммарное усилие в контакте ролика с дорожкой качения наружного кольца
						Sum_Q1 += (2*sigma_i_j*OM*OM);
					}
				}
			}
		}

		if (Sum_Q1 > 0.0) 
		{
			// Определить коэффициент умножения для двухмерного массива напряжений в контакте ролика с дорожкой качения наружного кольца
			k_q = *(QHU+k)/Sum_Q1;

			// Умножить двухмерный массив напряжений в контакте ролика с дорожкой качения внутреннего кольца на найденный коэффициент.
			for (i=0; i<N; i++) for (j=0; j<kol_uch_shirina; j++) *(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+j) *= k_q;
		}
	}


	if (Priz_napr_kray_effect)
	{
		// Установлен признак определения напряжений в контакте ролика с дорожками качения 
		// внутреннего и наружного кольца с учетом краевых эффектов.

		// Определить напряжение в контакте ролитка с дорожками качения наружного и внутреннего кольца с учетом краевых эффектов

		// Зона контакта в виде сетки.

		// Выделить область памяти для хранения массива признаков использования участков полосы контакта.
		priz_uch = (int *) malloc(N*kol_uch_shirina*sizeof(int));
		if (priz_uch == NULL)
		{
			// Неудача при выделении памяти для хранения массива признаков использования участков полосы контакта.
			// Освободить память
			free_mem_rol_max_napr();

			// Выдать сообщение об ошибке.
			printf("\n Неудача при выделении памяти для хранения массива использования участков области контакта");
			fprintf(f2,"\n Неудача при выделении памяти для хранения массива использования участков области контакта");

			// Выход из программы с признаком неудачи.
			return -1.0;
		}


		// Выделить область памяти для хранения массива коэффициентов слияния используемых для перехода от 
		// равномерного разбиения полосы контакта на участки к неравномерному.
		k_sl = (int *) malloc(N*sizeof(int));	
		if (k_sl == NULL)
		{
			// Неудача при выделении памяти для хранения массива коэффициентов слияния.
			// Освободить память
			free_mem_rol_max_napr();

			// Выдать сообщение об ошибке.
			printf("\n Неудача при выделении памяти для хранения массива коэффициентов слияния ");
			fprintf(f2,"\n Неудача при выделении памяти для хранения массива коэффициентов слияния ");

			// Выход из программы с признаком неудачи.
			return -1.0;
		}


		// Выделить область памяти для хранения вспомогательного массива коэффициентов слияния используемых
		// для перехода от равномерного разбиения полосы контакта на участки к неравномерному.
		k_sl1 = (int *) malloc(N*sizeof(int));	
		if (k_sl1 == NULL)
		{
			// Неудача при выделении памяти для хранения вспомогательного массива коэффициентов слияния.
			// Освободить память
			free_mem_rol_max_napr();

			// Выдать сообщение об ошибке.
			printf("\n Неудача при выделении памяти для хранения массива вспомогательного массива слияний");
			fprintf(f2,"\n Неудача при выделении памяти для хранения массива вспомогательного массива слияний");

			// Выход из программы с признаком неудачи.
			return -1.0;
		}


		// Выделение области памяти для хранения массива в котором записано количество неравномерных участков на полосах вдоль длины контакта ролика с кольцом.
		kol_neravn_uch_polosa = (int *) malloc(kol_uch_shirina*sizeof(int));	
		if (kol_neravn_uch_polosa == NULL)
		{
			// Неудача при выделении памяти для хранения массива в котором записано количество неравномерных участков на полосах вдоль длины 
			// контакта ролика с кольцом. Освободить ранее выделенные блоки оперативной памяти.
			// Освободить память
			free_mem_rol_max_napr();

			// Освободить ранее выделенные блоки оперативной памяти.	
			free(priz_uch);
			free(k_sl);
			free(k_sl1);

			// Выдать сообщение об ошибке.
			printf("\n Неудача при выделении памяти для хранения массива в котором записано количество неравномерных участков на полосах");
			fprintf(f2,"\n Неудача при выделении памяти для хранения массива в котором записано количество неравномерных участков на полосах");

			// Выход из программы с признаком неудачи.
			return -1.0;
		}

		// Выделение области памяти для хранения массива в котором записанЫ правые границы неравномерных участков.
		prav_gr_neravn_uch = (double *) malloc(kol_uch_shirina*N*sizeof(double));
		if (prav_gr_neravn_uch == NULL) 
		{
			// Неудача при выделении памяти для хранения массива в котором записаны правые границы неравномерных участков.
			// Освободить память
			free_mem_rol_max_napr();

			// Выдать сообщение об ошибке.
			printf("\n Неудача при выделении памяти для хранения массива в котором записаны правые границы неравномерных участков  ");
			fprintf(f2,"\n Неудача при выделении памяти для хранения массива в котором записаны правые границы неравномерных участков  ");

			// Выход из программы с признаком неудачи.
			return -1.0;
		}


		// Выделение области памяти для хранения массива в котором записаны связи между равномерными и неравномерными участками 
		// на которые разбита область контакта ролика с кольцом.
		swaz_neravn_ravn = (int *) malloc(kol_uch_shirina*N*sizeof(int));
		if (swaz_neravn_ravn == NULL) 
		{
			// Неудача при выделении памяти для хранения массива в котором записаны связи между равномерными и неравномерными участками 
			// на которые разбита область контакта ролика с кольцом. 
			// Освободить память
			free_mem_rol_max_napr();

			// Выдать сообщение об ошибке.
			printf("\n Неудача при выделении памяти для хранения массива в котором записаны связи между равномерными и неравномерными участками ");
			fprintf(f2,"\n Неудача при выделении памяти для хранения массива в котором записаны связи между равномерными и неравномерными участками ");

			// Выход из программы с признаком неудачи.
			return -1.0;
		} 

		// Выделение области памяти для хранения массива в котором записаны деформации на неравномерных участках. 
		// (Заранее неизвестно количество неравномерных участков по длине полосы, но точно известно что оно не больше N)
		DEF_neravn = (double *) malloc(kol_uch_shirina*N*sizeof(double));
		if (DEF_neravn == NULL)
		{
			// Неудача при выделении памяти для хранения массива в котором записаны деформации на неравномерных участках.
			// Освободить память
			free_mem_rol_max_napr();

			// Выдать сообщение об ошибке.
			printf("\n Неудача при выделении памяти для хранения массива в котором записаны деформации на неравномерных участках");
			fprintf(f2,"\n Неудача при выделении памяти для хранения массива в котором записаны деформации на неравномерных участках");

			// Выход из программы с признаком неудачи.
			return -1.0;
		}


		// Выделить область памяти для хранения массива признаков использования неравномерных участков.
		priz_uch_neravn = (int *) malloc(N*kol_uch_shirina*sizeof(int));
		if (priz_uch_neravn == NULL)
		{
			// Неудача при выделении памяти для хранения массива признаков использования неравномерных участков полосы контакта.
			// Освободить память
			free_mem_rol_max_napr();

			// Выдать сообщение об ошибке.
			printf("\n Неудача при выделении памяти для хранения массива в котором записаны признаки использования неравномерных участков");
			fprintf(f2,"\n Неудача при выделении памяти для хранения массива в котором записаны признаки использования неравномерных участков");

			// Выход из программы с признаком неудачи.
			return -1.0;
		}


		// Выделение области памяти для хранения массива в котором записаны напряжения на неравномерных участках. 
		// (Заранее неизвестно количество неравномерных участков по длине полосы, но точно известно что оно не больше N)
		NAPR_neravn = (double *) malloc(kol_uch_shirina*N*sizeof(double));
		if (NAPR_neravn == NULL)
		{
			// Неудача при выделении памяти для хранения массива в котором записаны напряжения на неравномерных участках.
			// Освободить память
			free_mem_rol_max_napr();

			// Выдать сообщение об ошибке.
			printf("\n Неудача при выделении памяти для хранения массива в котором записаны напряжения на неравномерных участках");
			fprintf(f2,"\n Неудача при выделении памяти для хранения массива в котором записаны напряжения на неравномерных участках");

			// Выход из программы с признаком неудачи.
			return -1.0;
		}


		// Взять максимальную ширину полосы контакта самого нагруженного ролика № 0 с дорожкой качения внутреннего кольца				
		max_shir_polos_kont_rol_vnut_kolcom = *(BVmax+0);

		// Определить количество нагруженных участков в контакте самого нагруженного ролика № 0 с внутренним кольцом				
		k_nagr_u = 0;
		for (i=0; i<N; i++) if (*(Bv+0*N+i) > 0) k_nagr_u++;

		// Выдать в отчет максимальную ширину полоски контакта ролика с внутренним кольцом и количество нагруженных участков.
		fprintf(f2,"\n\n  Максимальная ширина контакта ролика с внутренним кольцом = %8.5f мм. \n  Количество нагруженных участков = %d ", max_shir_polos_kont_rol_vnut_kolcom, k_nagr_u);


		// Взять максимальную ширину порлосы контакта самого нагруженного ролика № 0 с дорожкой качения наружного кольца
		max_shir_polos_kont_rol_narug_kolcom = *(BNmax+0);

		// Определить длину и максимальную ширину полосы контакта самого нагруженного ролика № 1 с наружным кольцом				
		k_nagr_u = 0;
		for (i=0; i<N; i++)	if (*(Bn+0*N+i) > 0) k_nagr_u++;

		// Выдать в отчет максимальную ширину полоски контакта ролика с наружным кольцом и количество нагруженных участков.
		fprintf(f2,"\n  Максимальная ширина контакта ролика с наружным кольцом = %8.5f мм. \n  Количество нагруженных участков = %d ", max_shir_polos_kont_rol_narug_kolcom, k_nagr_u);


		// Построение 2х мерного массива напряжений в контаекте роликов с наружным и внутренним кольцом.

		// Определить начальное значение расстояния участка самаого от себя. Это расстояние будет в последствии уточняться 
		// в итерационном цикле из условия равенства полученной для текущего значения расстояния участка самого от себя 
		// суммарной нагрузщки в контакте, нагрузке Qv.
		RAST0 = rastoyan0(OM, OM, 1000, 1000);
		RAST0 /= 10;


		/// Перебор в цикле одного ролика и определить напряжения на участках контакта ролика с наружным и внутренним кольцом.
		for (k=nom_rolik_QJ_max; k==nom_rolik_QJ_max; k++)
		{
			// Для ролика № k

			if (*(QJ+k) > 0)
			{
				// Есть контакт k того ролика с внутренним кольцом.
				//printf("\n   Est kontakt rolika s vnutrennim kolcom, poisk raspredeleniya naprjag v kontakte s vnutrennim kolcom  \n");

				// Задать допустимую погрешность отклонения усилия в контакте от усилия в контакте рассчитанного подпрограммой "napr_usil_kontakt2()".
				if (*(QJ+k)>1000) eps1=0.005;		
				else	
					if (*(QJ+k)>500) eps1=0.008;		
					else
						if (*(QJ+k)>100) eps1=0.01;		
						else			
							if (*(QJ+k)>50) eps1=0.02;							
							else
								if (*(QJ+k)>10) eps1=0.05;							
								else
									if (*(QJ+k)>5) eps1=0.1;							
									else
										if (*(QJ+k)>2) eps1=0.5;							
										else
											eps1=1.0;

				// Итерационный цикл определения напряжений на участках контакта ролика с внутренним кольцом из условия 
				// равенства полученной суммарной нагрузки, нагрузке Qv.
				while (1)
				{
					// Запомнить значение коэффициента влияния самого на себя полученное на предыдущей итерации..
					RAST01 = RAST0;

					//	Вызов подпрограммы определения напряжений на участках контакта ролика с внутренним кольцом (по сетке)
					// 
					//	Входные параметры: * DB2 - Указатель на массив деформаций на участках контакта роликов с внутренним кольцом.
					//			       k - Номер ролика ( используется для указания строки в массивах DB и SIGI)		
					//			    * Bv - Ширина на участках контакта ролика с внутренним кольцом					
					//			  RAST01 - Коэффициент влияния участка самого на себя.
					//			     E_w - Модуль упругости материала ролика
					//			    EP_w - Коэффициент Пуассона материала ролика.
					//			    E_vk - Модуль упругости материала внутреннего кольца
					//			   EP_vk - Коэффициент Пуассона материала внутреннего кольца
					// 
					//	Выходные параметры :  * SIGI2 - Указатель на массив средних напряжений на участках контакта роликов с внутренним кольцом.
					// 
					//   Возвращаемое значение :   Суммарное усилие в контакте полученное для найденного распределения напряжений в контакте.
					// 
					Q1 = napr_usil_kontakt2( DB2, k, Bv, RAST01, SIGI2, E_w, EP_w, E_vk, EP_vk);

					// Определить относительное отклонение суммарного усилия в контакте полученного для найденного 
					// распределения напряжений от усилия в контакте ролика с внутренним кольцом. 
					err_Q1 = Q1 - *(QJ+k);	
					otn_err = fabs(err_Q1/ *(QJ+k));

					// Выдать в отчет абсолютное и относительное отклонение
					printf("\n\n Otklonenie summarnogo usiliya v kontakte poluchennogo dlya naidennogo \n raspredeleniya napryagenii ot izvestnogo usiliya v kontakte  rolika s \n vnutrennim kolcom : Otn.oshibka = %7.5f  Abs.oshibka = %10.5f \n\n ", otn_err, err_Q1);			
					fprintf(f2,"\n\n Отклонение суммарного усилия в контакте полученного для найденного \n распределения напряжения от заранее известного усилия в контакте ролика \n с внутренним кольцом :  Относительная ошибка = %7.5f    Абсолютная ошибка =  %10.5f \n\n", otn_err, err_Q1);			

					if (otn_err < eps1) 
					{
						// Найденное в подпрограмме "napr_usil_kontakt2()" усилие в контакте мало отличается от усилия 
						// в контакте ролика с внутренним кольцом рассчитанного выше.
		
						// Запомнить значение коэффициента влияния самого на себя.
						RAST0 = RAST01;
		
						// Полагаем что распределение напряжения по участкам найдено и выходим из итерационного цикла.
						break;
					}
		
					// Сделать малое преращение коэффициенту влияния самого на себя.
					RAST02 = RAST01*1.001;


					//	Вызов подпрограммы определения напряжений на участках контакта ролика с внутренним кольцом (по сетке)
					// 
					//		 Входные параметры :	* DB2 - Указатель на массив деформаций на участках контакта роликов с внутренним кольцом.
					//					    k - Номер ролика ( используется для указания строки в массивах DB и SIGI)		
					//					 * Bv - Ширина на участках контакта ролика с внутренним кольцом					
					// 				       RAST02 - Коэффициент влияния участка самого на себя.
					//			     	  	  E_w - Модуль упругости материала ролика
					//			    		 EP_w - Коэффициент Пуассона материала ролика.
					//			    		 E_vk - Модуль упругости материала внутреннего кольца
					//			   		EP_vk - Коэффициент Пуассона материала внутреннего кольца
					// 
					//		Выходные параметры :  * SIGI2 - Указатель на массив средних напряжений на участках контакта роликов с внутренним кольцом.
					// 
					//   Возвращаемое значение :   Суммарное усилие в контакте полученное для найденного распределения напряжений в контакте.
					// 
					Q2 = napr_usil_kontakt2( DB2, k, Bv, RAST02, SIGI2, E_w, EP_w, E_vk, EP_vk);

					// Определить относительное отклонение суммарного усилия в контакте полученного для найденного 
					// распределения напряжений от усилия в контакте ролика с внутренним кольцом 
					err_Q2 = Q2 - *(QJ+k);
					otn_err = fabs(err_Q2/ *(QJ+k));

					// Выдать в отчет абсолютное и относительное отклонение
					printf("\n\n Otklonenie summarnogo usiliya v kontakte poluchennogo dlya naidennogo \n raspredeleniya napryagenii ot izvestnogo usiliya v kontakte rolika s  \n vnutrennim kolcom : Otn.oshibka = %7.5f   Abs.oshibka = %10.5f \n\n ", otn_err, err_Q2);			
					fprintf(f2,"\n\n Отклонение суммарного усилия в контакте полученного для найденного \n распределения напряжения от заранее известного усилия в контакте ролика \n с внутренним кольцом :  Относительная ошибка = %7.5f    Абсолютная ошибка =  %10.5f \n\n", otn_err, err_Q2);			

					if (otn_err < eps1) 
					{
						// Найденное в подпрограмме "napr_usil_kontakt2()" усилие в контакте мало отличается от усилия 
						// в контакте ролика с внутренним кольцом рассчитанного выше.
		
						// Запомнить значение коэффициента влияния самого на себя.
						RAST0 = RAST02;
		
						// Полагаем что распределение напряжения по участкам найдено и выходим из итерационного цикла.
						break;
					}

					// Шаг по методу Ньютона и нахождения следующего приближения коэффициента влияния участка самого на себя.
					RAST0 = RAST0 - koeff_shag_3 * err_Q1/((err_Q2-err_Q1)/(RAST02-RAST01));
				}
			}
			else
			{
				// Нет контакта ролика № j с внутренним кольцом. 
		
				// Установить нулевый напряжения по полосе контакта ролика с внутренним кольцом.
				for (i=0; i<N; i++)  for (j=0; j<kol_uch_shirina; j++) *(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+j)=0;
			}


			if (*(QHU+k) > 0)
			{
				// Есть контакт ролика № k с наружным кольцом.

				// Задать допустимую погрешность отклонения усилия в контакте от усилия в контакте рассчитанного подпрограммой "napr_usil_kontakt2()".
				if (*(QHU+k)>1000) eps1=0.005;		
				else	
					if (*(QHU+k)>500) eps1=0.008;		
					else
						if (*(QHU+k)>100) eps1=0.01;		
						else			
							if (*(QHU+k)>50) eps1=0.02;							
							else
								if (*(QHU+k)>10) eps1=0.05;							
								else
									if (*(QHU+k)>5) eps1=0.1;							
									else
										if (*(QHU+k)>2) eps1=0.5;							
										else
											eps1=1.0;							


				// Итерационный цикл определения напряжений на участках контакта ролика с наружным кольцом из условия равенства 
				// полученной суммарной нагрузки нагрузке Qn.

				while (1)
				{
					// Запомнить значение коэффициента влияния самого на себя полученное на предыдущей итерации..
					RAST01 = RAST0;

					//	Вызов подпрограммы определения напряжений на участках контакта ролика с наружным кольцом (по сетке).
					// 
					//		 Входные параметры :* DH2 - Указатель на массив деформаций на участках контакта роликов с наружным кольцом.
					//								k - Номер ролика 
					//							 * Bn - Ширина на участках контакта ролика с наружным кольцом					
					//						   RAST01 - Коэффициент влияния участка самого на себя.
					//			     			  E_w - Модуль упругости материала ролика
					//			    			 EP_w - Коэффициент Пуассона материала ролика.
					//			    			 E_nk - Модуль упругости материала наружного кольца
					//			   				EP_nk - Коэффициент Пуассона материала наружного кольца
					// 
					//		Выходные параметры :  * SIGO2 - Указатель на массив средних напряжений на участках контакта роликов с наружным кольцом.
					// 
					//   Возвращаемое значение :   Суммарное усилие в контакте полученное для найденного распределения напряжений в контакте.
					// 
					Q1 = napr_usil_kontakt2( DH2, k, Bn, RAST01, SIGO2, E_w, EP_w, E_nk, EP_nk);

					// Определить относительное отклонение суммарного усилия в контакте полученного для найденного 
					// распределения напряжений от усилия в контакте ролика с наружным кольцом 
					err_Q1 = Q1 - *(QHU+k);
					otn_err = fabs(err_Q1/ *(QHU+k));

					// Выдать в отчет абсолютное и относительное отклонение
					printf("\n\n Otklonenie summarnogo usiliya v kontakte  poluchennogo dlya naidennogo \n raspredeleniya napryagenii ot izvestnogo usiliya v kontakte rolika s \n narugnym kolcom : Otn.oshibka = %7.5f   Abs.oshibka = %10.5f \n\n ", otn_err, err_Q1);			
					fprintf(f2,"\n\n Отклонение суммарного усилия в контакте полученного для найденного \n распределения напряжения от заранее известного усилия в контакте ролика \n с наружным кольцом :  Относительная ошибка = %7.5f    Абсолютная ошибка =  %10.5f \n\n", otn_err, err_Q1);			

					if (otn_err < eps1) 
					{
						// Найденное в подпрограмме "napr_usil_kontakt2()" усилие в контакте мало отличается от усилия 
						// в контакте ролика с наружным кольцом рассчитанного выше.
		
						// Запомнить значение коэффициента влияния самого на себя.
						RAST0 = RAST01;
		
						// Полагаем что распределение напряжения по участкам найдено и выходим из итерационного цикла.
						break;
					}

					// Сделать малое преращение коэффициенту влияния самого на себя.
					RAST02 = RAST01*1.001;

					//	Вызов подпрограммы определения напряжений на участках контакта ролика с наружным кольцом (по сетке)
					// 
					//		 Входные параметры :   * DH2 - Указатель на массив деформаций на участках контакта роликов с наружным кольцом.
					//					   k - Номер ролика 
					//					* Bn - Ширина на участках контакта ролика с наружным кольцом					
					// 				      RAST02 - Коэффициент влияния участка самого на себя.
					//			     		 E_w - Модуль упругости материала ролика
					//			    		EP_w - Коэффициент Пуассона материала ролика.
					//			    		E_nk - Модуль упругости материала наружного кольца
					//			   	       EP_nk - Коэффициент Пуассона материала наружного кольца
					// 
					//		Выходные параметры :  * SIGO2 - Указатель на массив средних напряжений на участках контакта роликов с наружным кольцом.
					// 
					//   Возвращаемое значение :   Суммарное усилие в контакте полученное для найденного распределения напряжений в контакте.
					// 
					Q2 = napr_usil_kontakt2( DH2, k, Bn, RAST02, SIGO2, E_w, EP_w, E_nk, EP_nk );

					// Определить относительное отклонение суммарного усилия в контакте полученного для найденного 
					// распределения напряжений от усилия в контакте ролика с наружным кольцом 
					err_Q2 = Q2 - *(QHU+k);
					otn_err = fabs(err_Q2/ *(QHU+k));

					// Выдать в отчет абсолютное и относительное отклонение
					printf("\n\n Otklonenie summarnogo usiliya v kontakte poluchennogo dlya naidennogo \n raspredeleniya napryagenii ot izvestnogo usiliya v kontakte rolika s \n narugnym kolcom : Otn.oshibka = %7.5f  Abs.oshibka =  %10.5f \n\n ", otn_err, err_Q2);			
					fprintf(f2,"\n\n Отклонение суммарного усилия в контакте полученного для найденного \n распределения напряжения от заранее известного усилия в контакте ролика \n с наружным кольцом :  Относительная ошибка = %7.5f    Абсолютная ошибка =  %10.5f \n\n", otn_err, err_Q2);			

					if (otn_err < eps1) 
					{
						// Найденное в подпрограмме "napr_usil_kontakt2()" усилие в контакте мало отличается от усилия 
						// в контакте ролика с наружным кольцом рассчитанного выше.
	
						// Запомнить значение коэффициента влияния самого на себя.
						RAST0 = RAST02;
		
						// Полагаем что распределение напряжения по участкам найдено и выходим из итерационного цикла.
						break;
					}

					// Шаг по методу Ньютона и нахождения следующего приближения коэффициента влияния участка самого на себя.
					RAST0 = RAST0 - koeff_shag_3 * err_Q1 /((err_Q2-err_Q1)/(RAST02-RAST01));
				}
			}
			else
			{
				// Нет контакта ролика № j с наружным кольцом. 
				printf("\n   Net kontakta rolika s narug kolcom \n");

				// Установить нулевый напряжения по полосе контакта ролика с внутренним кольцом.
				for (i=0; i<N; i++)  for (j=0; j<kol_uch_shirina; j++) *(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+j)=0;
			} 
		}


		////////////////////////////////////////////////////////////////////////
		///
		/*
		// Определение долговечности по контактному напряжению для 2х мерного распределения напряжений 
		// в контакте роликов с дорожками качения наружного и внутреннего колец.
		L_pod = DOLG2();

		// Определить долговечность подшипника в часах по контактному напряжению
		L_pod_h = 1000000 * L_pod /(B_N - N_N)/60;  
		*/
		///
		//////////////////////////////////////////////////////////////////////


		// Найти максимальное напряжение в контакте ролика с наружным и внутренним кольцом, 
		// для каждого ролика и записать в массивы "SIGO_max" и "SIGI_max".
		for (k=0; k<Z; k++)
		{
			// Найти максимальное напряжение в контакте k тного ролика с наружным и внутренним кольцом.

			// Задать начальное значение максимального напряжения в контакте k тного ролика с наружным  и внутренним кольцом.
			SIGO_max1 = 0;
			SIGI_max1 = 0;

			// Перебор в цикле всех участков в контакте j тного ролика с наружным и внутренним кольцом.
			for (i=0; i<N; i++)
				for (j=0; j<kol_uch_shirina; j++)
				{
					if (*(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+j) > SIGO_max1) SIGO_max1 = *(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+j);
					if (*(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+j) > SIGI_max1) SIGI_max1 = *(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+j);
				}

			// Запомнить найденное максимальное напряжение в контакте ролика с наружным и внутренним кольцом.
			*(SIGO_max+k) = SIGO_max1;
			*(SIGI_max+k) = SIGI_max1;
		}

		// Выдать в отчет шапку таблицы
		fprintf(f2,"\n                                                                                             ");
		fprintf(f2,"\n                                                                         ТАБЛИЦА %d           ",nom_tab);
		nom_tab++;
		fprintf(f2,"\n ------------------------------------------------------------------------------------------- ");
		fprintf(f2,"\n |      |         НАГРУЗКА НА РОЛИК      |   МАКС.НАПРЯЖЕНИЕ   |ЭКСЦЕНТРИСИТЕТ|УГОЛ НАКЛОНА| ");
		fprintf(f2,"\n |НОМЕР |             / КГС /            |     / КГС/ММ2 /     |   НАГРУЗКИ   |ОСИ РОЛИКА  | ");
		fprintf(f2,"\n |РОЛИКА|--------------------------------|---------------------|     /ММ/     |  /МИН/     | ");
		fprintf(f2,"\n |      |    FC    |    QI    |    QO    |  СигмаI  |   СигмаO |      E       |    B       | ");
		fprintf(f2,"\n |------|----------|----------|----------|----------|----------|--------------|------------| ");
		fprintf(f2,"\n |  1   |     2    |    3     |     4    |    5     |     6    |      7       |      8     | ");
		fprintf(f2,"\n ------------------------------------------------------------------------------------------- ");

		// Выдать в отчет сведения по всем роликам.
		for (k=0; k<Z; k++)
		{
			fprintf(f2,"\n |  %3d |%10.3f|%10.3f|%10.3f|%10.3f|%10.3f|  %10.3f  | %10.3f |",k+1,*(FCOP+k),*(QJ+k),*(QHU+k),*(SIGI_max+k),*(SIGO_max+k),*(DEC+k),*(F2X+k) );
		}
		fprintf(f2,"\n ------------------------------------------------------------------------------------------- ");

		// Запомнить максимальное напряжение в контакте самого нагруженного ролика (Ролика № 0) с внутренним кольцом 
		// для того чтобы потом возвратить его как результат работы функции "rol_max_napr()".
		Y_cel_func = *(SIGI_max);

		// Задать номер самого нагруженного ролика
		k=0;

		// Выдать в отчет шапку таблицы отчета по деформациям в контакте ролика с внутренним кольцом
		fprintf(f2,"\n                  										");
		fprintf(f2,"\n                  										");
		fprintf(f2,"\n                                                                         ТАБЛИЦА %d   ",nom_tab);
		nom_tab++;
		fprintf(f2,"\n                  										");
		fprintf(f2,"\n                             РАСПРЕДЕЛЕНИЕ КОНТАКТНЫХ ДЕФОРМАЦИЙ					");
		fprintf(f2,"\n                      В КОНТАКТЕ САМОГО НАГРУЖЕННОГО РОЛИКА № %3d С ВНУТРЕННИМ КОЛЬЦОМ  ",nom_rolik_QJ_max+1 );

		for (i=0; i<N; i++)
		{
			fprintf(f2,"\n");
			for (j=0; j<kol_uch_shirina; j++)  
			{	
				fprintf(f2," %8.5f  \t ",*(DB2+N*kol_uch_shirina*k+kol_uch_shirina*i+j));
			}
		}

		fprintf(f2,"\n \n \n													");
		fprintf(f2,"\n ------------------------------------------------------------------------------------------		");

		// Выдать в отчет шапку таблицы отчета по напряжениям в контакте ролика с внутренним кольцом
		fprintf(f2,"\n                  											");
		fprintf(f2,"\n                  											");
		fprintf(f2,"\n                                                                         ТАБЛИЦА %d    ",nom_tab);
		nom_tab++;
		fprintf(f2,"\n                  											");
		fprintf(f2,"\n                             РАСПРЕДЕЛЕНИЕ НАПРЯЖЕНИЙ							");
		fprintf(f2,"\n                      В КОНТАКТЕ РОЛИКА САМОГО НАГРУЖЕННОГО РОЛИКА № %3d С ВНУТРЕННИМ КОЛЬЦОМ  ",nom_rolik_QJ_max+1);

		for (i=0; i<N; i++)
		{
			fprintf(f2,"\n");
			for (j=0; j<kol_uch_shirina; j++)  fprintf(f2," %8.3f  \t ",*(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+j));
		}

		fprintf(f2,"\n \n \n													");
		fprintf(f2,"\n ------------------------------------------------------------------------------------------		");


		// Выдать в отчет шапку таблицы отчета по деформациям в контакте ролика с наружным кольцом
		fprintf(f2,"\n                  											");
		fprintf(f2,"\n                  											");
		fprintf(f2,"\n                                                                         ТАБЛИЦА %d   ",nom_tab);
		nom_tab++;
		fprintf(f2,"\n                  											");
		fprintf(f2,"\n                             РАСПРЕДЕЛЕНИЕ КОНТАКТНЫХ ДЕФОРМАЦИЙ						");
		fprintf(f2,"\n                      В КОНТАКТЕ САМОГО НАГРУЖЕННОГО РОЛИКА  № %3d С НАРУЖНЫМ КОЛЬЦОМ    ",nom_rolik_QJ_max+1);

		for (i=0; i<N; i++)
		{
			fprintf(f2,"\n");
			for (j=0; j<kol_uch_shirina; j++)  
			{	
				fprintf(f2," %8.5f  \t ",*(DH2+N*kol_uch_shirina*k+kol_uch_shirina*i+j));
			}
		}

		fprintf(f2,"\n \n \n												");
		fprintf(f2,"\n ------------------------------------------------------------------------------------------	");

		// Выдать в отчет шапку таблицы отчета по напряжениям в контакте ролика с наружным кольцом
		fprintf(f2,"\n                  										");
		fprintf(f2,"\n                  										");
		fprintf(f2,"\n                                                                         ТАБЛИЦА %d    ",nom_tab);
		nom_tab++;
		fprintf(f2,"\n                  										");
		fprintf(f2,"\n                             РАСПРЕДЕЛЕНИЕ НАПРЯЖЕНИЙ						");
		fprintf(f2,"\n                      В КОНТАКТЕ САМОГО НАГРУЖЕННОГО РОЛИКА  № %3d С НАРУЖНЫМ КОЛЬЦОМ    		",nom_rolik_QJ_max+1);

		for (i=0; i<N; i++)
		{
			fprintf(f2,"\n");
			for (j=0; j<kol_uch_shirina; j++)  fprintf(f2," %8.3f  \t ",*(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+j));
		}

		fprintf(f2,"\n \n \n												");
		fprintf(f2,"\n ------------------------------------------------------------------------------------------	");

		free(NAPR_neravn);		// Освободить область памяти выделенную для хранения массива напряжений на неравномерных участках.
		free(priz_uch_neravn);		// Освободить область памяти выделенную для хранения массива признаков использования неравномерных участков.
		free(DEF_neravn);		// Освободить область памяти выделенную для хранения массива деформации на неравномерных участках.
		free(swaz_neravn_ravn);		// Освободить область памяти выделенную для хранения массива связи между равномерными и неравномерными участками 
		free(prav_gr_neravn_uch);	// Освободить область памяти выделенную для хранения массива правых границ неравномерных участков.
		free(kol_neravn_uch_polosa);	// Освободить область памяти выделенную для хранения массива в котором записано количество неравномерных участков на полосах вдоль длины контакта ролика с кольцом.
		free(k_sl1);			// Освободить область памяти выделенную для вспомогательного массива коэффициентов слияния.
		free(k_sl);			// Освободить область памяти выделенную для массива коэффициентов слияния.
		free(priz_uch);			// Освободить область памяти выделенную для двухмерного массива признака использования участков

		// Выдать в отчет профиль ролика.
		fprintf(f2,"\n 	Профиль ролика \n");
		fprintf(f2,"\n N \t Х \t CI \t D/2-CI \n");

		// Выдать в отчет профиль ролика.
		for (i=0; i<N; i++)
		{
			// Определить плечо текущего участка ролика (растояние от текущего участка до середины ролика).
			xi = i*OM+OM/2-Lw/2;

			fprintf(f2,"\n  %d \t %10.7f \t %10.7f \t %10.7f  ", i, xi, Rw-*(profil+i), *(profil+i));
		}

		// Выдвть в отчет ширину полосы на участках в контакте самого нагруженного ролика № 1 с внутренним кольцом				
		fprintf(f2,"\n																										");
		fprintf(f2,"\n  Ширина полосы  на участках в контакте самого нагруженного ролика № 1 с внутренним кольцом	");
		for (i=0; i<N; i++)	fprintf(f2,"\n %9.6f ",*(Bv+0*N+i));
		fprintf(f2,"\n																										");

		// Выдвть в отчет ширину полосы на участках в контакте самого нагруженного ролика № 1 с наружным кольцом				
		fprintf(f2,"\n																										");
		fprintf(f2,"\n  Ширина полосы  на участках в контакте самого нагруженного ролика № 1 с наружным кольцом		");
		for (i=0; i<N; i++)	fprintf(f2,"\n %9.6f ",*(Bn+0*N+i));
		fprintf(f2,"\n																										");

		// Перевести угол перекоса внутреннего кольца из радиан в минуты.
		TT = 10800/pi*TT;

		// Выдать на экран результат вычисления целевой функции
		printf("\n F_cel = %15.8f ",Y_cel_func);

		// Записать в файл протокола результат вычисления целевой функции.
		fprintf(f3,"\n F_cel = %15.8f ",Y_cel_func);

	}
	else
	{
		// Сброшен признак определения напряжений в контакте ролика с дорожками качения 
		// внутреннего и наружного кольца с учетом краевых эффектов.

		////////////////////////////////////////////////////////////////////////
		///
/*
		// Определение долговечности по контактному напряжению для 2х мерного распределения напряжений 
		// в контакте роликов с дорожками качения наружного и внутреннего колец.
		L_pod = DOLG2();

		// Определить долговечность подшипника в часах по контактному напряжению
		L_pod_h = 1000000 * L_pod /(B_N - N_N)/60;  
*/
		///
		//////////////////////////////////////////////////////////////////////

		// Определить напряжение в контакте ролика с дорожками качения наружного и внутреннего кольца с без учета краевых эффектов

		// Найти максимальное напряжение в контакте ролика с наружным и внутренним кольцом, 
		// для каждого ролика и записать в массивы "SIGO_max" и "SIGI_max".
		for (k=0; k<Z; k++)
		{
			// Найти максимальное напряжение в контакте k тного ролика с наружным и внутренним кольцом.

			// Задать начальное значение максимального напряжения в контакте k тного ролика с наружным и внутренним кольцом.
			SIGO_max1 = 0;
			SIGI_max1 = 0;

			// Перебор в цикле всех участков в контакте j тного ролика с наружным и внутренним кольцом.
			for (i=0; i<N; i++)
				for (j=0; j<kol_uch_shirina; j++)
				{
					if (*(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+j) > SIGO_max1) SIGO_max1 = *(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+j);
					if (*(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+j) > SIGI_max1) SIGI_max1 = *(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+j);
				}

			// Запомнить найденное максимальное напряжение в контакте ролика с наружным и внутренним кольцом.
			*(SIGO_max+k) = SIGO_max1;
			*(SIGI_max+k) = SIGI_max1;
		}

		// Выдать в отчет шапку таблицы
		fprintf(f2,"\n                                                                                             ");
		fprintf(f2,"\n                                                                         ТАБЛИЦА %d           ",nom_tab);
		nom_tab++;
		fprintf(f2,"\n ------------------------------------------------------------------------------------------- ");
		fprintf(f2,"\n |      |         НАГРУЗКА НА РОЛИК      |   МАКС.НАПРЯЖЕНИЕ   |ЭКСЦЕНТРИСИТЕТ|УГОЛ НАКЛОНА| ");
		fprintf(f2,"\n |НОМЕР |             / КГС /            |     / КГС/ММ2 /     |   НАГРУЗКИ   |ОСИ РОЛИКА  | ");
		fprintf(f2,"\n |РОЛИКА|--------------------------------|---------------------|     /ММ/     |  /МИН/     | ");
		fprintf(f2,"\n |      |    FC    |    QI    |    QO    |  СигмаI  |   СигмаO |      E       |    B       | ");
		fprintf(f2,"\n |------|----------|----------|----------|----------|----------|--------------|------------| ");
		fprintf(f2,"\n |  1   |     2    |    3     |     4    |    5     |     6    |      7       |      8     | ");
		fprintf(f2,"\n ------------------------------------------------------------------------------------------- ");

		// Выдать в отчет сведения по всем роликам.
		for (k=0; k<Z; k++)
		{
			fprintf(f2,"\n |  %3d |%10.3f|%10.3f|%10.3f|%10.3f|%10.3f|  %10.3f  | %10.3f |",k+1,*(FCOP+k),*(QJ+k),*(QHU+k),*(SIGI_max+k),*(SIGO_max+k),*(DEC+k),*(F2X+k) );
		}
		fprintf(f2,"\n ------------------------------------------------------------------------------------------- ");

		// Перебор в цикле одного ролика ( самого нагруженного )
		//
		for (k=nom_rolik_QJ_max; k==nom_rolik_QJ_max; k++)
		{
			fprintf(f2,"\n                  															   ");
			fprintf(f2,"\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");
			fprintf(f2,"\n                  															   ");

			// Выдать в отчет массив деформаций в контиакте текущего ролика с дорожками качения внутреннего кольца
			fprintf(f2,"\n                  															   ");
			fprintf(f2,"\n                  															   ");
			fprintf(f2,"\n РАСПРЕДЕЛЕНИЕ КОНТАКТНЫХ ДЕФОРМАЦИЙ В КОНТАКТЕ РОЛИКА %d  С ВНУТРЕННИМ КОЛЬЦОМ  ", k+1);
			fprintf(f2,"\n                  															   ");

			for (i=0; i<N; i++)
			{
				fprintf(f2,"\n");
				for (j=0; j<kol_uch_shirina; j++)  
				{	
					fprintf(f2," %8.5f  \t ",*(DB2+N*kol_uch_shirina*k+kol_uch_shirina*i+j));
				}
			}

			// Выдать в отчет массив напряжений в контиакте текущего ролика с дорожками качения внутреннего кольца
			fprintf(f2,"\n                  															   ");
			fprintf(f2,"\n                  															   ");
			fprintf(f2,"\n РАСПРЕДЕЛЕНИЕ КОНТАКТНЫХ НАПРЯЖЕНИЙ В КОНТАКТЕ РОЛИКА %d  С ВНУТРЕННИМ КОЛЬЦОМ  ", k+1);
			fprintf(f2,"\n                  															   ");

			for (i=0; i<N; i++)
			{
				fprintf(f2,"\n");
				for (j=0; j<kol_uch_shirina; j++)  
				{	
					fprintf(f2," %8.5f  \t ", *(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+j));
				}
			}

			// Выдать в отчет массив деформаций в контиакте текущего ролика с дорожками качения наружного кольца
			fprintf(f2,"\n                  															   ");
			fprintf(f2,"\n                  															   ");
			fprintf(f2,"\n РАСПРЕДЕЛЕНИЕ КОНТАКТНЫХ ДЕФОРМАЦИЙ В КОНТАКТЕ РОЛИКА %d  С НАРУЖНЫМ КОЛЬЦОМ  ", k+1);
			fprintf(f2,"\n                  															   ");

			for (i=0; i<N; i++)
			{
				fprintf(f2,"\n");
				for (j=0; j<kol_uch_shirina; j++)  
				{		
					fprintf(f2," %8.5f  \t ",*(DH2+N*kol_uch_shirina*k+kol_uch_shirina*i+j));
				}
			}

			// Выдать в отчет массив напряжений в контиакте текущего ролика с дорожками качения наружного кольца
			fprintf(f2,"\n                  															   ");
			fprintf(f2,"\n                  															   ");
			fprintf(f2,"\n РАСПРЕДЕЛЕНИЕ КОНТАКТНЫХ НАПРЯЖЕНИЙ В КОНТАКТЕ РОЛИКА %d  С НАРУЖНЫМ КОЛЬЦОМ  ", k+1);
			fprintf(f2,"\n                  															   ");

			for (i=0; i<N; i++)
			{
				fprintf(f2,"\n");
				for (j=0; j<kol_uch_shirina; j++)  
				{	
					fprintf(f2," %8.5f  \t ", *(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+j));
				}
			}
		}
	}



	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	///

	/// Определение суммарной потенциальной энергии в контакте всех роликов с дорожками качения наружного и внутреннего колец в кг * мм.
	/// Перебор в цикле всех роликов.
	for (k=0; k<Z; k++)  
	{
		// Определить суммарную потенциальную энергию в контакте ролика № k с дорожкой качения наружного кольца  в кг * мм
		Energ_kont_rol_nk = 0.0;
		for (i=0; i<N; i++) for (j=0; j<kol_uch_shirina; j++) Energ_kont_rol_nk += fabs(*(DH2+N*kol_uch_shirina*k+kol_uch_shirina*i+j)) * fabs(*(SIGO2+N*kol_uch_shirina*k+kol_uch_shirina*i+j)) * OM * OM;

		// Определить суммарную потенциальную энергию в контакте ролика № k с дорожкой качения внутреннего кольца  в кг * мм		
		Energ_kont_rol_vk = 0.0;
		for (i=0; i<N; i++) for (j=0; j<kol_uch_shirina; j++) Energ_kont_rol_vk += fabs(*(DB2+N*kol_uch_shirina*k+kol_uch_shirina*i+j)) * fabs(*(SIGI2+N*kol_uch_shirina*k+kol_uch_shirina*i+j)) * OM * OM;

		// Запомнить итоговую потенициальную энергию ролика  № k  в кг * мм
		*(Energ_def_rol + k) = Energ_kont_rol_nk + Energ_kont_rol_vk;		

		fprintf(f2,"\n ");
		fprintf(f2,"\n  Потенциальная энергия в контакте ролика № %3d с наружным кольцом   в кг * мм = %8.5f ",k, Energ_kont_rol_nk);		
		fprintf(f2,"\n  Потенциальная энергия в контакте ролика № %3d с внутренним кольцом в кг * мм = %8.5f ",k, Energ_kont_rol_vk);		
		fprintf(f2,"\n  Итоговая потенциальная энергия ролика   № %3d                      в кг * мм = %8.5f ",k, *(Energ_def_rol + k));
	}

	/// Построение массива дополнительных усилий в кг. действующих на перемычку сепаратора из-за втаскивания ролика в клин, и выхода из клина.
	/// Перебор в цикле всех роликов.
	for (k=0; k<Z; k++)  
	{
		if (k < Z-1)
		{
			*(Dop_usil_sep + k) = ( *(Energ_def_rol+k+1) - *(Energ_def_rol+k)) / dLcr;
		}
		else
		{
			*(Dop_usil_sep + k) = ( *(Energ_def_rol+0)   - *(Energ_def_rol+k)) / dLcr;
		}
	}

	/// Выдать в отчёт массив дополнительных усилий действующих на перемычку сепаратора из-за втаскивания ролика в клин, и выхода из клина.

	/// Перебор в цикле всех роликов.
	for (k=0; k<Z; k++)  
	{
		fprintf(f2,"\n  Дополнительное усилие на перемычку сепаратора из за втаскивания ролика № %3d в клин в кг = %8.5f ",k ,*(Dop_usil_sep + k));				
	}
	
	///
	/////////////////////////////////////////////////////////////////////////////////////////////////////////








	// Запомнить текущее значение угловой скорости сепаратора
	W_sep_1 = W_sep;

	// Уточнение угловой скорости сепаратора в радианах в секунду с учетом смазки. 
	W_sep = W_separator( DR, T_w, T_vk, T_nk, W_sep, &Sum_N_hdr_w, &N_hdr_sep, &N_hdr_pod);

	free(SIGO2);	// Освободить область памяти выделенную для массива напряжений в контакте ролика и наружного кольца.
	free(DH2);	// Освободить область памяти выделенную для массива деформации в контакте ролика и наружного кольца.
	free(SIGI2);	// Освободить область памяти выделенную для массива напряжений контакте ролика и внутреннего кольца.
	free(DB2);	// Освободить область памяти выделенную для массива деформации в контакте ролика и внутреннего кольца.


	// Относительное отклонение угловой скорости сепаратора полученной на текущей итерации от угловой скорости сепаратора полученной на предыдущей итерации. 
	otn_otkl_w_sep = fabs((W_sep_1-W_sep)/W_sep_1);

	// Выдать угловую скорость сепаратора полученную на предыдущей и текущей итерации.
	printf("\n\n  Pred W_sep = %8.5f         Tek W_sep = %8.5f      Otnos otkl = %8.5f \n\n", W_sep_1, W_sep, otn_otkl_w_sep );
	fprintf(f2,"\n\n  Pred W_sep = %8.5f         Tek W_sep = %8.5f      Otnos otkl = %8.5f \n\n", W_sep_1, W_sep, otn_otkl_w_sep );

	// Отклонение нового значения угловой скорости сепаратора от прежней менее 6%.
	// Выход из итерационного цикла поиска угловой скорости сепаратора.
	if ( otn_otkl_w_sep < 0.03) break;   

	// Увеличить на 1 счетчик итераций цикла поиска угловой скорости сепаратора
	nom_it_w_sep++;
}


// Выдать в отчёт таблицу "Параметры в контактах максимально нагруженного ролика с дорожкой качения внутреннего кольца (вдоль большей оси эллипса контакта)"
fprintf(f2,"\n																	                                                ");
fprintf(f2,"\n	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");
fprintf(f2,"\n																	   						");
fprintf(f2,"\n	 		ПАРАМЕТРЫ В КОНТАКТАХ МАКСИМАЛЬНО НАГРУЖЕННОГО РОЛИКА № %3d С ДОРОЖКОЙ КАЧЕНИЯ ВНУТРЕННЕГО КОЛЬЦА (вдоль большей оси эллипса контакта)  			", nom_rolik_QJ_max+1);
fprintf(f2,"\n																	   						");
fprintf(f2,"\n -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ");
fprintf(f2,"\n |        | Относительная  |  Нормальная  | Контактная  |  Максимальное  |  Скорость  |   Скорость   | Центральная  |  Дин.вязкость |  Касательное | Коэффициент |  Коэффициент | ");
fprintf(f2,"\n |  № п/п | координата по  |   нагрузка,  | деформация, |   напряжение,  |  качения,  |  скольжения, |   толщина    |    смазки в   |  напряжение  |   трения    |    трения    | ");
fprintf(f2,"\n |        | длине ролика   |              |             |                |            |              | УГД-плёнки,  |    контакте,  |    сдвига,   |  скольжения |   качения    | ");
fprintf(f2,"\n |        |                |     кгс      |     мкм     |     кгс/см2    |    см/с    |     см/с     |    мкм       |   кг*с/см2    |    кгс/см2   |             |              | ");
fprintf(f2,"\n |--------|----------------|--------------|-------------|----------------|------------|--------------|--------------|---------------|--------------|-------------|--------------| ");

for (i=0; i<N; i++)
{
        // Определить коэффициент трения скольжения
	if (*(P_centr_0_I+i) != 0.0)
	{
		k_tren_skol = *(t_centr_0_I+i) / *(P_centr_0_I+i);
	}
	else
	{
		k_tren_skol = 0.0;
	}	

	// Выдать в отчёт очередную строку таблицы
	fprintf(f2,"\n |   %3d  |     %6.3f     |    %7.3f   | %11.4f |   %12.3f |%11.3f |  %11.3f |    %8.6f  |   %11.7f |     %8.4f |      %6.4f |--------------| ", i, (double) i/N-0.5, *(Q_centr_0_I+i), *(Def_0_I+i)*1000, *(P_centr_0_I+i)*100, *(U_kach_centr_0_I+i)/10, *(V_skol_poverh_centr_0_I+i)/10, *(h_centr_0_I+i)*1000, *(Nr_centr_0_I+i)*100, *(t_centr_0_I+i)*100, k_tren_skol );
}


fprintf(f2,"\n -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ");
fprintf(f2,"\n																	                                                ");
fprintf(f2,"\n																	                                                ");
fprintf(f2,"\n	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");
fprintf(f2,"\n																	   						");
fprintf(f2,"\n	 		ПАРАМЕТРЫ В КОНТАКТАХ МАКСИМАЛЬНО НАГРУЖЕННОГО РОЛИКА № %3d  С ДОРОЖКОЙ КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА (вдоль большей оси эллипса контакта)  				", nom_rolik_QJ_max+1);
fprintf(f2,"\n																	   						");
fprintf(f2,"\n -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ");
fprintf(f2,"\n |        | Относительная  |  Нормальная  | Контактная  |  Максимальное  |  Скорость  |   Скорость   | Центральная  |  Дин.вязкость |  Касательное | Коэффициент |  Коэффициент | ");
fprintf(f2,"\n |  № п/п | координата по  |   нагрузка,  | деформация, |   напряжение,  |  качения,  |  скольжения, |   толщина    |    смазки в   |  напряжение  |   трения    |    трения    | ");
fprintf(f2,"\n |        | длине ролика   |              |             |                |            |              | УГД-плёнки,  |    контакте,  |    сдвига,   |  скольжения |   качения    | ");
fprintf(f2,"\n |        |                |     кгс      |     мкм     |     кгс/см2    |    см/с    |     см/с     |    мкм       |   кг*с/см2    |    кгс/см2   |             |              | ");
fprintf(f2,"\n |--------|----------------|--------------|-------------|----------------|------------|--------------|--------------|---------------|--------------|-------------|--------------| ");

for (i=0; i<N; i++)
{
        // Определить коэффициент трения скольжения
	if (*(P_centr_0_O+i) != 0.0)
	{
		k_tren_skol = *(t_centr_0_O+i) / *(P_centr_0_O+i);
	}
	else
	{
		k_tren_skol = 0.0;
	}	

	// Выдать в отчёт очередную строку таблицы
	fprintf(f2,"\n |   %3d  |     %6.3f     |    %7.3f   | %11.4f |   %12.3f |%11.3f |  %11.3f |    %8.6f  |   %11.7f |     %8.4f |      %6.4f |--------------| ", i, (double) i/N-0.5, *(Q_centr_0_O+i), *(Def_0_O+i)*1000, *(P_centr_0_O+i)*100, *(U_kach_centr_0_O+i)/10, *(V_skol_poverh_centr_0_O+i)/10, *(h_centr_0_O+i)*1000, *(Nr_centr_0_O+i)*100, *(t_centr_0_O+i)*100, k_tren_skol );
}

fprintf(f2,"\n -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ");
fprintf(f2,"\n																	                                                ");
fprintf(f2,"\n																	                                                ");

// Определить процент проскальзывания сепаратора
Proskals_sep_proc = (W_sep_epicikl - W_sep)/W_sep_epicikl*100;

// Выдать эпициклическую и реальную скорости вращения сепаратора, процент проскальзывания, 
// затраты мощности на преодоление гидромеханического сопротивления всех роликов,
// затраты мощности на преодоление гидромеханического сопротивления сепаратора,
// затраты мощности общие.
fprintf(f2,"\n     ");
fprintf(f2,"\n     ");
fprintf(f2,"\n -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -      ");
fprintf(f2,"\n     ");
fprintf(f2,"\n                                                 Эпициклическая скорость вращения сепаратора = %10.4f радиан/сек  " , W_sep_epicikl);
fprintf(f2,"\n                                               Реальная угловая скорость вращения сепаратора = %10.4f радиан/сек  " , W_sep);
fprintf(f2,"\n Отн.отклонение реальной угл.скорости вращения сепаратора от эпициклической (проскальзывание)= %10.4f процентов  ", Proskals_sep_proc);
fprintf(f2,"\n     ");
fprintf(f2,"\n     Затраты мощности на преодоление гидродинамического сопротивления всех роликов = %10.4f вт. " , Sum_N_hdr_w);
fprintf(f2,"\n     Затраты мощности на преодоление гидродинамического сопротивления сепаратора   = %10.4f вт. " , N_hdr_sep);
fprintf(f2,"\n Затраты мощности на преодоление гидродинамического сопротивления всего подшипника = %10.4f вт. " , N_hdr_pod);
fprintf(f2,"\n     ");
fprintf(f2,"\n Долговечность подшипника по контактным напряжениям  L_pod_h = %12.5f час. ",L_pod_h);
fprintf(f2,"\n Долговечность подшипника по контактным напряжениям вычисленная по методике С.В.Батенкова L_BAT_pod_h = %20.10f час. ",L_BAT_pod_h);
fprintf(f2,"\n Долговечность подшипника по контактным напряжениям вычисленная по методике Бейзельмана   L_BEISELMAN_pod_h = %20.10f час. ",L_BEISELMAN_pod_h);
fprintf(f2,"\n Радиус кривизны бомбины = %12.3f мм.", R);
fprintf(f2,"\n");

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
free(Energ_def_rol);	// Освободить область памяти выделенную для хранения массива энергий деформаций роликов.
free(Dop_usil_sep);	// Освободить область памяти выделенную для хранения массива дополнительных усилий на перемычку сепаратора возникающих при виаскивании ролика в клин
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

free(k_lagr_pezo);	// Освободить область памяти выделенную для хранения массива коэффициентов полинома Лагранжа задающего пъезокоэффициент вязкости смазки
free(k_lagr_vyaz);	// Освободить область памяти выделенную для хранения массива коэффициентов полинома Лагранжа задающего вязкость смазки
free(Temp_smazka);	// Освободить область памяти выделенную для хранения массива температур при которых измерялись вязкость смазки и пъезокоэффициент вязкости смазки
free(Pezo_smazka);	// Освободить область памяти выделенную для хранения массива пъезокоэффициента вязкости смазки при различных температурах
free(Vyaz_smazka);	// Освободить область памяти выделенную для хранения массива вязкости смазки

free(Def_0_O);					// Освободить область памяти выделенную для хранения массива деформаций на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца
free(Nr_centr_0_O);				// Освободить область памяти выделенную для хранения массива динамической вязкости на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца
free(h_centr_0_O);				// Освободить область памяти выделенную для хранения массива толщин смазочной плёнки на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца
free(t_centr_0_O);				// Освободить область памяти выделенную для хранения массива касательных напряжений на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца
free(U_kach_centr_0_O);				// Освободить область памяти выделенную для хранения массива скоростей качения на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца  
free(V_skol_poverh_centr_0_O);			// Освободить область памяти выделенную для хранения массива скоростей скольжения поверхностей на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца
free(P_centr_0_O);				// Освободить область памяти выделенную для хранения массива нормальных напряжений на участках центарльной полосы контакта 0 го ролика с дорожкой качения наружного кольца
free(Q_centr_0_O);				// Освободить область памяти выделенную для хранения массива нормальных усилий на участках центральной полосы контакта 0 го ролика с дорожкой качения наружного кольца

free(Def_0_I);					// Освободить область памяти выделенную для хранения массива деформаций на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца
free(Nr_centr_0_I);				// Освободить область памяти выделенную для хранения массива динамической вязкости на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца	
free(h_centr_0_I);				// Освободить область памяти выделенную для хранения массива толщин смазочной плёнки на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца
free(t_centr_0_I);				// Освободить область памяти выделенную для хранения массива касательных напряжений на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца
free(U_kach_centr_0_I);				// Освободить область памяти выделенную для хранения массива скоростей качения на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца  
free(V_skol_poverh_centr_0_I);			// Освободить область памяти выделенную для хранения массива скоростей скольжения поверхностей на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца
free(P_centr_0_I);				// Освободить область памяти выделенную для хранения массива нормальных напряжений на участках центарльной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца	
free(Q_centr_0_I);				// Освободить область памяти выделенную для хранения массива нормальных усилий на участках центральной полосы контакта 0 го ролика с дорожкой качения внутреннего кольца

free(BNmax);		// Освободить область памяти выделенную для хранения одномерного массива максимальных ширин полос контакта ролков с дорожками качения наружного кольца
free(BVmax);		// Освободить область памяти выделенную для хранения одномерного массива максимальных ширин полос контакта ролков с дорожками качения внутреннего кольца
free(F_rol_sep);	// Освободить область памяти выделенную для хранения одномерного массива сил действующих на перемычку сепаратора со стороны роликов
free(F_tr_rol_sep);	// Освободить область памяти выделенную для хранения одномерного массива сил трения в контактах роликов с перемычками сепаратора
free(profil);		// Освободить область памяти выделенную для хранения массива в который записывается профиль ролика
free(SIGO_max);		// Освободить область памяти выделенную для хранения массива максимальных напряжений в контакте всех роликов с наружным кольцом
free(SIGI_max);		// Освободить область памяти выделенную для хранения массива максимальных напряжений в контакте всех роликов с внутренним кольцом
free(FCOP);		// Освободить область памяти выделенную для хранения массива значений центробежныой сиды действующей на ролики.
free(SIGO);		// Освободить область памяти выделенную для хранения массива средних напряжений на участках контакта всех роликов с наружным кольцом.
free(SIGI);		// Освободить область памяти выделенную для хранения массива средних напряжений на участках контакта всех роликов с внутренним кольцом.
free(DH);		// Освободить область памяти выделенную для хранения массива деформаций на участках контакта роликов с наружным кольцом.
free(Bn);		// Освободить область памяти выделенную для хранения массива ширин вдоль полоски контакта ролика с наружным кольцом.
free(Bv);		// Освободить область памяти выделенную для хранения массива ширин вдоль полоски контакта ролика с внутренним кольцом.
free(DB);		// Освободить область памяти выделенную для хранения массива деформаций на участках контакта роликов с внутренним кольцом.
free(F2V);		// Освободить блок памяти выделенный для массива невязок уравнений равновесия моментов действующих на ролик.
free(F1V);		// Освободить блок памяти выделенный для массива невязок уравнений равновесия сил действующих на ролик.
free(F2X);		// Освободить блок памяти выделенный для массива углов перекоса роликов.
free(F1X);		// Освободить блок памяти выделенный для массива сближений ролика с наружным кольцом.
free(DEC);		// Освободить блок памяти выделенный для массива эксцентриситетов нагрузки приложенных к роликам.
free(QHU);		// Освободить блок памяти выделенный для массива усилий в контакте роликов с наружным кольцом.
free(QJ);		// Освободить блок памяти выделенный для массива усилий в контакте роликов с внутренним кольцом.


// Выход из главной функции с возвратом максимального напряжения в контакте ролика № 0 (самого нагруженного) с внутренним кольцом.
return Y_cel_func;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////	ПОДПРОГРАММА ОСВОБОЖДЕНИЯ ОБЛАСТИ ПАМЯТИ ВЫДЕЛЕННОЙ РАНЕЕ ДЛЯ ХРАНЕНИЯ СПИСКА ЗНАЧЕНИЙ ЦЕЛЕВОЙ ФУНКЦИИ	///////
///
///	Входной параметры : u_nach - Указатель на начало списка
///


void free_spisok( struct rezult_Ycel * u_nach )
{

struct rezult_Ycel * u_tek;	// Указатель на текущий элемент списка	
struct rezult_Ycel * u_pred;	// Указатель на предыдущий элемент списка
double * u_x;			// Указатель на область памяти в которой расположен массив аргументов целевой функции


// Взять указатель на начало списка, и запомнить адрес откуда его взяли
u_tek = u_nach;

// Перебор в цикле всех элементов списка
while (u_tek != NULL)
{
	// Получить ссылку на массив аргументов целевой функции
	u_x = u_tek->xx; 

	// Освободить область памяти в которой находиться массив аргументов целевой функции
	free(u_x);

	// Переход к следующему элементу списка
	u_pred = u_tek;
	u_tek  = u_tek->next; 

	// Освободить область памяти в которой записан предыдущий элемент списка
	free(u_pred);
}

// Выход из подпрограммы
return;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////		ПОДПРОГРАММА ВЫЧИСЛЕНИЯ ЦЕЛЕВОЙ ФУНКЦИИ			///////////////////////////////////
//
// Вычислить значение целевой функции в новой текущей точке с учетом ограничений.
//
//	Входные параметры 		:    xxk - Массив координат текущей точки в которой надо получить значение целевой функции
//	Возвращаемое значение	:  Y_cel - Значение целевой функции 
//

double f_cel( double * xxk)

{

int i;		// Счетчик
int priz;	// Признак принадлежности текущей точки разрешенной области
double Y_cel;	// Значение целевой функции	


// Проверка лежит ли текущая точка в границах области изменения параметров целевой функции 

// Установить признак пренадлежности текущей точки области разрешенных значений.
priz = 1;

for (i=0; i<Kol_Param; i++)
{
	if (!( (*(xx_min+i) <= *(xxk+i)) && (*(xxk+i) <= *(xx_max+i)) ))
	{
		// Значение координаты № i лежит вне зоны разрешенных значений 
		// Сброс признака принадлежности текущей точки области разрешенных значений.
		priz = 0;
	}
}

if (priz)
{
	// Текущая точка лежит внутри области разрешенных значений целевой функции
	// Вычислить значение целевой функции.
	Y_cel = rol_max_napr(xxk);
}
else
{
	// Текущая точка лежит вне области разрешенных значений целевой функции
	// Присвоить целевой функции заведомо неприемлимое большое значение чтобы сделать эту точку не выгодной.
	Y_cel = 99999999999999999.99;
}


// Выход из функции с возвратом найденного значения целевой функции.
return Y_cel;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////   ПОДПРОГРАММА ПОЛУЧЕНИЯ ЗНАЧЕНИЯ ЦЕЛЕВОЙ ФУНКЦИИ ( ВЫЧИСЛЕНИЕ ИЛИ ПОЛУЧЕНИЯ ИЗ СПИСКА РАНЕЕ ВЫЧИСЛЕННЫХ)	///////////////
//
//
// Получить значение целевой функции в новой текущей точке с учетом ограничений, для этого сначала поискать в ее в списке,
// если найдется тогда считать ее оттуда, если не получиться тогда вычислить значение целевой функции, поместить в список, 
// и выдать вычисленное значение целевой функции.
//
//		Входные параметры :			  xxk - Массив координат текущей точки в которой надо получить значение целевой функции
//
//	    Возвращаемое значение :  	Y_cel - Значение целевой функции 
//

double f_cel1( double * xxk)
{

struct rezult_Ycel * u_tek;		// Указатель на текущий элемент списка
struct rezult_Ycel * * adr_u_tek;	// Указатель на адрес начала списка.
double * u_xx;				// Указатель на массиы аргументов целевой функции
int priz_ravno;				// Признак равенства массива координат текущей точки и массива координат текущего элмента списка.
int i;					// Счетчик цикла
double value;				// Найденное значение целевой функции.
int priz_ud;				// Признак нахождения значения целевой функции для координат текущей точки в списке.
struct rezult_Ycel * u_new_elem;	// Указатель на новый элемент списка значений целевой функции


// Нарастить счетчик попыток вычислить целевую функцию
kol_popyt_wych_Y_cel++;				 

// Сброс признака нахождения значения целевой функции для координат текущей точки в списке.
priz_ud = 0;

// Взять указатель на начало списка, и запомнить адрес откуда его взяли
u_tek = u_nach;
adr_u_tek = &u_nach;

// Перебор в цикле элементов списка
while (u_tek != NULL)
{
	// Указатель "u_tek" указывает на существующий элемент списка.

	// Получить ссылку на массив аргументов целевой функции
	u_xx = u_tek->xx; 

	// Поочередно сравнить аргументы для текущего элемента списка значений целевой функции 
	// с массивом координат текущей точки присланным через входные параметры.
	priz_ravno = 1;

	for (i=0; i<Kol_Param; i++)
	{
		if (*(u_xx+i) != *(xxk+i))
		{	
			priz_ravno = 0;				
			break;
		}
	}

	if (priz_ravno)
	{
		// Найден элемент списка у которого аргументы целевой функции равны массиву координат текущей точки.	

		// Считать значение целевой функции из текущего элемента.
		value = u_tek->Ycel;

		// Установить признак нахождения значения целевой функции для координат текущей точки в списке.
		priz_ud = 1;

		// Досрочный выход из цикла.
		break;
	}

	// Взять адрес следующего элемента списка, и запомнить адрес откуда он был взят.
	adr_u_tek = &(u_tek->next);
	u_tek = u_tek->next;
}

	
if (!priz_ud)
{
	// В списке не найден элемент у которого список аргументов равен аргументам текущей точки.

	// Вычислить значение целевой функции для текущей точки. 
	// Создать новый элемент списка, записать в него координаты текущей точки и вычисленное значение целевой функции. 

	// Выделить область памяти для хранения нового элемента списка.
	u_new_elem = (struct rezult_Ycel *) malloc(sizeof(struct rezult_Ycel));

	// Записать указатель на новый элемент в поле "next" последнего пройденного элемента списка  или если элементов 
	// в списке нет и этот элемент первый в списке  тогда в указатель на начало списка.
	*(adr_u_tek) = u_new_elem;

	// Выделить область памяти для хранения аргументов целевой функции
	u_xx = (double *) malloc(sizeof(double)*Kol_Param);

	// В поле "xx" нового элемента списка запомнить указатель на область памяти выделенную для хранения массива аргументов
	u_new_elem->xx = u_xx;

	// Записать текущий массив аргументов в область памяти выделенную для хранения массива аргументов целеавой функции.
	for (i=0; i<Kol_Param; i++) *(u_xx+i) = *(xxk+i);

	//  Вычислить значение целевой функции для текущего массива аргументов. 
	//
	//	Входные параметры  :  	xxk - Массив координат текущей точки в которой надо получить значение целевой функции
	//
	value = f_cel(xxk);

	// Записать вычисленное значение целевой функции в поле "Ycel" нового элемента списка. 
	u_new_elem->Ycel = value;

	// Записать NULL в поле "next" (ссылка на следующий элемент) нового элемента списка.
	u_new_elem->next = NULL;
}

return value;

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////	ПОДПРОГРАММА ИССЛЕДОВАНИЯ ОКРЕСТНОСТИ БАЗОВОЙ ТОЧКИ И ОПРЕДЕЛЕНИЯ КООРДИНАТЫ И НАПРАВЛЕНИЯ ДВИЖЕНИЯ 	///////////////////
//
//
//     Выходные параметры :		uk_n_coord	- Указатель на номер координаты по которой надо шагать (0 - N-1)	
//								uk_napr		- Указаталь на направление шагания (0 - Уменьшение , 1 - Увеличение)
//

void wybor_coord_napr( int * uk_n_coord, int * uk_napr)
{

int i;			// Счетчик
int n_coord;	// Номер координаты
int napr;		// Номер направления

// Установить координаты текущей точки равными координате базовой точке.
for (i=0; i<Kol_Param; i++) *(xx+i)=*(xx_b+i);

// Перебор в цикле всех координат
for (n_coord=0; n_coord<Kol_Param; n_coord++)
{
	if (priz_var_param[n_coord])
	{
		// Текущая координата является варьируемой.

		// Уменьшить текущую координату на величину шага относительно базового уровня.
		napr = 0;
		*(xx+n_coord) = *(xx_b+n_coord) - *(hh+n_coord);

		// Найти значение целевой функции в новой текущей точке.
		//
		//	Входные параметры  :  	xx - Массив координат текущей точки в которой надо получить значение целевой функции
		//	Выходные параметры : Y_cel - Значение целевой функции 
		//
		Y_cel = f_cel1(xx);

		// Если значение целевой функции в новой текущей точке меньше чем в базовой тогда выход из подпрограммы.
		if (Y_cel < Yb_cel) break;

		// Уменьшить текущую координату на величину шага относительно базового уровня.
		napr = 1;
		*(xx+n_coord) = *(xx_b+n_coord) + *(hh+n_coord);

		// Найти значение целевой функции в новой текущей точке.
		//
		//	Входные параметры  :	   xx - Массив координат текущей точки в которой надо получить значение целевой функции
		//	Выходные параметры :	Y_cel - Значение целевой функции 
		//
		Y_cel = f_cel1(xx);

		// Если значение целевой функции в новой текущей точке меньше чем в базовой тогда выход из подпрограммы.
		if (Y_cel < Yb_cel) break;

		// Установить прежнее значение текущей координаты.
		*(xx+n_coord) = *(xx_b+n_coord);
	}
}

* uk_n_coord = n_coord;
* uk_napr = napr;


return;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////		ГЛАВНАЯ  ФУНКЦИЯ			///////////////////////////////
///
///	ЧТЕНИЕ ИСХОДНЫХ ДАННЫХ. РЕШЕНИЕ ОПТИМИЗАЦИОННОЙ ЗАДАЧИ МЕТОДОМ ХУКА-ДЖИВСА. ПОИСК ТАКИХ ЗНАЧЕНИЙ ВАРИРУЕМЫХ 
///  ПАРАМЕТРОВ ГЕОМЕТРИИ РОЛИКА, ПОДШИПНИКА, УСЛОВИЙ РАБОТЫ ПОДШИПНИКА ЧТОБЫ МИНИМИЗИРОВАТЬ НАПРЯЖЕНИЕ В КОНТАКТЕ 
///	САМОГО НАГРУЖЕННОГО РОЛИКА С ВНУТРЕННИМ КОЛЬЦОМ. ВЫВОД РЕЗУЛЬТАТОВ РАСЧЕТА.

int main()
{

char * stroka;		/// Указатель на область памяти в которую записывается строка.
char * Name_Stroka;	/// Указатель на область памяти в которую записывается строка хранящая наименование подшипника.
FILE * f1;		/// Дескриптор файла из которого считываются исходные данные.
int i;			/// Счетчик цикла
int k;			/// Счетчик цикла
int n_coord;		/// Номер координаты по которой надо шагать
int napr;		/// Направление шагания по координате
int dl_stroka;		/// Длина строки "stroka".
double * float_value;	/// Указатель на массив вещественных значений прочитанных из строки.
int kol_float_value;	/// Количество вещественных значений прочитанных из строки.
char c1;		/// Считанный символ
int nom_str;		/// Счетчик строк считываемых из файла исходных данных
int nom_str_val;	/// Счетчик строк считываемых из файла исходных данных и содержащих вещественные значения
int kol_str_val;	/// Количество считанных строк из файла исходных данных содержащих вещественные значения
int nom_var_param;	/// Номер последнего варьируемого параметра	
char symb1;		/// Символьная переменная для выдачи на экран служебных признаков	

char 	char_sign_1, char_sign_2;	/// Символьное представление знака вещественного числа
double 	tek_ugol_gradus;		/// Текущий угол в градусах


// Выделить область памяти объемом 100 байт для чтения разделительной строки.
stroka = (char *) malloc(100 * sizeof(char));
if (stroka == NULL)
{
	// Неудача при выделении памяти объемом 100 байт для хранения разделительной строки. 		
	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти объемом 100 байт для хранения разделительной строки. ");

	// Выход из программы с признаком неудачи.
	return -1;
}

// Заполнить строку символом признака конца строки.
memset(stroka,'\0',100);

// Выделить область памяти объемом 100 байт для хранения строки содержащей наименование подшипника.
Name_Stroka = (char *) malloc(100 * sizeof(char));
if (Name_Stroka == NULL)
{
	// Неудача при выделении памяти объемом 100 байт для хранения строки содержащей наименование подшипника. 		
	// Освободить ранее выделенные блоки оперативной памяти.
	free(stroka);
	
	// Выдать сообщение об ошибке.
	printf("\n Неудача при выделении памяти объемом 100 байт для хранения строки содержащей наименование подшипника. ");

	// Выход из программы с признаком неудачи.
	return -1;
}

// Заполнить строку наименования подшипника символом признака конца строки.
memset(Name_Stroka,'\0',100);

// Открыть файл для чтения исходных данных.
if ( (f1=fopen("ROL_OPT.DAT","r")) == NULL )
{
	// Неудача при открытии файла для чтения исходных данных. 
	// Освободить выделенные ранее блоки памяти.
	free(stroka);
	free(Name_Stroka);

	// Выдать сообщение об ошибке.
	printf("\n  Ошибка при открытии файла для чтения исходных данных ");

	// Завершить работу программы с признаком ошибки.	
	return -1;
}

// Выделить область памяти для хранения массива "xx_min[]" (Нижние границы параметров)
xx_min = (double *) malloc( Kol_Param * sizeof(double));
if (xx_min == NULL)
{
	// Неудача при выделении области памяти для хранения массива "xx_min".
	// Освободить ранее выделенные блоки памяти.
	free(stroka);
	free(Name_Stroka);
	fclose(f1);

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении памяти для хранения массива  xx_min[] ");

	// Завершить программу с признаком ошибки
	return -1;
}

// Выделить область памяти для хранения массива "xx_max[]" (Верхние границы параметров)
xx_max = (double *) malloc( Kol_Param * sizeof(double));
if (xx_max == NULL)
{
	// Неудача при выделении области памяти для хранения массива "xx_max".
	// Освободить ранее выделенные блоки памяти.
	free(stroka);
	free(Name_Stroka);
	fclose(f1);
	free(xx_min);

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении памяти для хранения массива  xx_max[] ");

	// Завершить программу с признаком ошибки
	return -1;
}


// Выделить область памяти для хранения массива "xx[]" (Текущие значения параметров).
xx = (double *) malloc( Kol_Param * sizeof(double));
if (xx == NULL)
{
	// Неудача при выделении области памяти для хранения массива "xx".
	// Освободить ранее выделенные блоки памяти.
	free(stroka);
	free(Name_Stroka);
	fclose(f1);
	free(xx_min);
	free(xx_max);

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении памяти для хранения массива  xx[] ");

	// Завершить программу с признаком ошибки
	return -1;
}


// Выделить область памяти для хранения массива "xx_b[]" (Базовые значения параметров).
xx_b = (double *) malloc( Kol_Param * sizeof(double));
if (xx_b == NULL)
{
	// Неудача при выделении области памяти для хранения массива "xx_b".
	// Освободить ранее выделенные блоки памяти.
	free(stroka);
	free(Name_Stroka);
	fclose(f1);
	free(xx_min);
	free(xx_max);
	free(xx);

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении памяти для хранения массива  xx_b[] ");

	// Завершить программу с признаком ошибки
	return -1;
}


// Выделить область памяти для хранения массива "hh[]" (Величина шага вдоль координат)
hh = (double *) malloc( Kol_Param * sizeof(double));
if (hh == NULL)
{
	// Неудача при выделении области памяти для хранения массива "hh".
	// Освободить ранее выделенные блоки памяти.
	free(stroka);
	free(Name_Stroka);
	fclose(f1);
	free(xx_min);
	free(xx_max);
	free(xx);
	free(xx_b);

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении памяти для хранения массива  hh[] ");

	// Завершить программу с признаком ошибки
	return -1;
}


// Выделить область памяти для хранения массива "priz_var_param[]" (Признак варируемого параметра).
priz_var_param = (int *) malloc(Kol_Param * sizeof(int));
if (priz_var_param == NULL)
{
	// Неудача при выделении области памяти для хранения массива "priz_var_param".
	// Освободить ранее выделенные блоки памяти.
	free(stroka);
	free(Name_Stroka);
	fclose(f1);
	free(xx_min);
	free(xx_max);
	free(xx);
	free(xx_b);
	free(hh);

	// Выдать сообщение об ошибке
	printf("\n Неудача при выделении памяти для хранения массива  priz_var_param[] ");

	// Завершить программу с признаком ошибки
	return -1;
}

// Обнулить счетчик варьируемых параметров.
Kol_Var_Param = 0;

// Переход на начало файла исходных данных
fseek(f1,0L,SEEK_SET);

// Обнулить счетчик строк считываемых из файла исходных данных
nom_str = 0;

// Обнулить счетчик строк считываемых из файла исходных данных и содержащих вещественные значения.
nom_str_val = 0;

// Чтение исходных данных о размерах и условиях работы подшипника.
while (!feof(f1))
{
	// Переписать в переменную "stroka" очередную строку файла исходных данных
	c1=0;
	i=0;
	while((!feof(f1)) && (c1!=10))
	{
		c1 = getc(f1);
		*(stroka+i) = c1;
		i++;
	}
	*(stroka+i) = '\0';
	
	// Запомнить длину строки
	dl_stroka = i;	

	if (nom_str == 3)
	{
		// Из строки № 3 файла исходных данных считать наименование.
		i=0;
		while((i<57) && (*(stroka+i)!='\0'))
		{
			if (i >= 22) *(Name_Stroka+i-22) = *(stroka+i);
			i++;
		}
	}

	if (nom_str > 3)
	{
		// Начиная с 4 строки файла исходных данных выделять из строки вещественные значения. 

		// Получить массив вещественных чисел из очередной строки файла исходных данных.
		kol_float_value = string_float(stroka, dl_stroka, &float_value);

		if (kol_float_value > 0)
		{
			// Из текущей строки файла исходных данных получены вещественные значения.
		
			// Первое из вещественных значений записать в "xx_min".
			xx_min[nom_str_val] = *(float_value+0);

			if (kol_float_value > 1) 
			{
				// Из текущей строки файла исходных данных получено более одного вещественного значения
				// Второе из вещественных значений записать в "xx_max". Остальные если они есть игнорировать. 
				xx_max[nom_str_val] = *(float_value+1);
				priz_var_param[nom_str_val] = 1;
				nom_var_param = nom_str_val;
				
				// Нарастить счетчик варьируемых параметров
				Kol_Var_Param++;
			}
			else
			{
				// Из текущей строки файла исходных данных получено ровно одно вещественное значение
				// Установить "xx_max" = "xx_min".
				xx_max[nom_str_val] = xx_min[nom_str_val];
				priz_var_param[nom_str_val] = 0;
			}

			// Увеличить на 1 счетчик строк считанных из файла исходных данных и содержащих вещественные значения.
			nom_str_val++;		
		}

		// Освободить область памяти выделенную для хранения массива вещественных чисел.
		free(float_value);
	}

	// Увеличить на 1 счетчик считанных строк из файла исходных данных
	nom_str++;
}

// Запомнить считанное количество строк из файла исходных данных содержащих вещественные значения.
kol_str_val = nom_str_val;

// Закрыть файл из которого прочитаны исходные данные.
fclose(f1);


/// Обнулить количество точек описывающих профиль наружного кольца
kol_toch_profil_nk=0;

/// Обнулить cредний радиус наружного кольца определённый как сумма ряда Фурье описывающего профиль
sred_R_nk_fure = 0.0;         

if ((int) xx_min[96] == 1)
{
	/// Установлен признак чтения профиля дорожки качения наружного кольца из файла PROF_NK.DAT

	/// Открыть файл PROF_NK.DAT для чтения
	if ((f1=fopen("PROF_NK.DAT","r")) == NULL)
	{
		/// Неудача при открытии файла для чтения исходных данных. 
		/// Освободить выделенные ранее блоки памяти.
		free(stroka);
		free(Name_Stroka);
		free(xx_min);
		free(xx_max);
		free(xx);
		free(xx_b);
		free(hh);
		free(priz_var_param);

		/// Выдать сообщение об ошибке.
		printf("\n  !!! Error  file  PROF_NK.DAT not found");

		/// Выход из программы с признаком неудачи.
		return -1;
	}

	/// Прочитать из файла PROF_NK.DAT профиль дорожки качения наружного кольца

	/// Определить количество точек описывающих профиль.
	kol_toch_profil_nk=0;

	/// Переход на начало файла исходных данных, движение по файлу с подсчётом количества точек описывающих профиль
	fseek(f1,0L,SEEK_SET);							
	while (!feof(f1))
	{
		/// Переписать в переменную "stroka" очередную строку файла исходных данных
		c1=0;
		i=0;
		while((!feof(f1)) && (c1!=10))
		{
			c1 = getc(f1);
			*(stroka+i) = c1;
			i++;
		}
		*(stroka+i) = '\0';

		dl_stroka = i;								// Запомнить длину строки считаной из файла исходных данных
		kol_float_value = string_float(stroka, dl_stroka, &float_value);	// Получить массив вещественных чисел из очередной строки файла исходных данных.

		if (kol_float_value > 0)
		{
			// Из текущей строки файла исходных данных получены вещественные значения.
			// Нарастить счетчик считанных вещественных значений
			kol_toch_profil_nk++;
		}

		free(float_value);							// Освободить область памяти выделенную для хранения массива вещественных чисел.
	}

	if ((kol_toch_profil_nk == 2)     || (kol_toch_profil_nk == 4)      || (kol_toch_profil_nk == 8)       || (kol_toch_profil_nk == 16)      || (kol_toch_profil_nk == 32)      || 
	    (kol_toch_profil_nk == 64)    || (kol_toch_profil_nk == 128)    || (kol_toch_profil_nk == 256)     || (kol_toch_profil_nk == 512)     || (kol_toch_profil_nk == 1024)    || 
	    (kol_toch_profil_nk == 2048)  || (kol_toch_profil_nk == 4096)   || (kol_toch_profil_nk == 8192)    || (kol_toch_profil_nk == 16384)   || (kol_toch_profil_nk == 32768)   || 
	    (kol_toch_profil_nk == 65536) || (kol_toch_profil_nk == 131072) || (kol_toch_profil_nk == 262144)  || (kol_toch_profil_nk == 524288)  || (kol_toch_profil_nk == 1048576))
	{
		/// Количество точек описывающих профиль дорожки качения наружного кольца равно степени двойки от 2^1  до  2^20

		/// Выделить память под массив описывающий профиль 
		profil_nk = (double *) malloc(kol_toch_profil_nk*sizeof(double));
		if (profil_nk == NULL)
		{
			/// Неудача при выделении памяти для хранения массива описывающего профиль дорожки качения кольца

			/// Выдать сообщение об ошибке.
			printf("\n  !!! Oshibka pri videlenii bloka pamyati dlya profilya narugnogo kolca");

			/// Освободить выделенные ранее блоки памяти.
			free(stroka);
			free(Name_Stroka);
			free(xx_min);
			free(xx_max);
			free(xx);
			free(xx_b);
			free(hh);
			free(priz_var_param);
		
			/// Закрыть файл исходных данных
			fclose(f1);

			/// Выход из программы с признаком неудачи.
			return -1;
		}

		/// Выделить область памяти для хранения массива "aa[]" который используется для получения коэффициентов Фурье
		aa = (double *) malloc(kol_toch_profil_nk*2*sizeof(double));
		if (aa == NULL)
		{
			/// Неудача при выделении памяти для хранения массива коэффициентов Фурье

			/// Выдать сообщение об ошибке.
			printf("\n  !!! Oshibka pri videlenii bloka pamyati dlya massiva aa[] ");

			/// Освободить выделенные ранее блоки памяти.
                        free(profil_nk);
			free(stroka);
			free(Name_Stroka);
			free(xx_min);
			free(xx_max);
			free(xx);
			free(xx_b);
			free(hh);
			free(priz_var_param);
		
			/// Закрыть файл исходных данных
			fclose(f1);

			/// Выход из программы с признаком неудачи.
			return -1;
		}

		/// Выделить область памяти для хранения массива "sum_fure_profil_nk[]" суммы ряда Фурье описывающего профиль дорожки качения кольца наружного кольца
        	sum_fure_profil_nk = (double *) malloc(kol_toch_profil_nk*sizeof(double));

		if (sum_fure_profil_nk == NULL)
		{
			/// Неудача при выделении области памяти для хранения массива "sum_fure_profil_nk[]" суммы ряда Фурье описывающего профиль дорожки качения кольца наружного кольца

			/// Выдать сообщение об ошибке.
			printf("\n  !!! Oshibka pri videlenii bloka pamyati dlya massiva sum_fure_profil_nk[] ");

			/// Освободить выделенные ранее блоки памяти.
			free(aa);
                        free(profil_nk);
			free(stroka);
			free(Name_Stroka);
			free(xx_min);
			free(xx_max);
			free(xx);
			free(xx_b);
			free(hh);
			free(priz_var_param);
		
			/// Закрыть файл исходных данных
			fclose(f1);

			/// Выход из программы с признаком неудачи.
			return -1;
		}


		/// Выполнить чтение из файла PROF_NK.DAT профиля дорожки качения наружного кольца.
		k=0;
		fseek(f1,0L,SEEK_SET);								/// Переход на начало файла исходных данных
		while (!feof(f1))
		{
			// Переписать в переменную "stroka" очередную строку файла исходных данных
			c1=0;
			i=0;
			while((!feof(f1)) && (c1!=10))
			{
				c1 = getc(f1);
				*(stroka+i) = c1;
				i++;
			}
			*(stroka+i) = '\0';
			dl_stroka = i;								/// Запомнить длину строки считаной из файла исходных данных
			kol_float_value = string_float(stroka, dl_stroka, &float_value);	/// Получить массив вещественных чисел из очередной строки файла исходных данных.

			if (kol_float_value > 0)
			{
				// Из текущей строки файла исходных данных получены вещественные значения.
				*(profil_nk+k) = *(float_value+0);				/// Запомнить полученное вещественное значение в массиве описывающем профиль дорожки качения наружного кольца
				k++;
			}

			free(float_value);							/// Освободить область памяти выделенную для хранения массива вещественных чисел.
		}

		/// Копирование массива profil_nk[] в массив aa[]
		for (k=0; k<kol_toch_profil_nk; k++)
		{
			*(aa+k*2)   = *(profil_nk+k);
			*(aa+k*2+1) = 0.0;
		}

		/// Выполнение БПФ
		bpf(aa, kol_toch_profil_nk);

		/// Записать в массив "sum_fure_profil_nk[]" сумму ряда Фурье для всех точек профиля
		for (k=0; k<kol_toch_profil_nk; k++)
		{
			*(sum_fure_profil_nk+k) = fure( aa, kol_toch_profil_nk, (double) k);
		}

	}  
	else
	{
		/// Ошибочное количество точек описывающих профиль дорожки качения наружного кольца. 

		/// Освободить выделенные ранее блоки памяти.
		free(stroka);
		free(Name_Stroka);
		free(xx_min);
		free(xx_max);
		free(xx);
		free(xx_b);
		free(hh);
		free(priz_var_param);
		
		/// Закрыть файл исходных данных
		fclose(f1);

		/// Выдать сообщение об ошибке.
		printf("\n  !!! Oshibotschnoe kolichestvo tochek opisyvayutschih profil");

		/// Выход из программы с признаком неудачи.
		return -1;
	}

	/// Закрыть файл из которого прочитаны исходные данные.
	fclose(f1);
}


/// Освободить блок памяти выделенный для хранения строки.
free(stroka);	

if (kol_str_val != Kol_Param)
{
	// Выдать предупреждающее сообщение в случае если количество считанных параметров не равно требуемому количеству параметров 
	// заданному глобальной константой "Kol_Param".	
	printf("\n Wnimanie !!!   Kolich shitannyh parametrov %d , dolgno byt %d ",kol_str_val, Kol_Param);
}

// Создать файл для записи результатов расчета.
if ( (f2=fopen("REZ.DAT","w")) == NULL )
{
	// Неудача при создании файла для записи результатов расчета. 
	// Освободить ранее выделенные блоки оперативной памяти.
	if (sum_fure_profil_nk != NULL) free(sum_fure_profil_nk);	/// Освободить область памяти выделенную для массива хранящего сумму ряда Фурье описывающего  профиль дорожки качения наружного кольца
	if (aa != NULL) free(aa);					/// Освободить область памяти выделенную для массива коэффициентов ряда Фурье
	if (profil_nk != NULL) free(profil_nk);				/// Освободить область памяти выделенную хранения массива описывающего профиль дорожки качения наружного кольца
	free(Name_Stroka);	
	free(xx_min);	
	free(xx_max);
	free(xx);
	free(xx_b);
	free(hh);

	// Выдать сообщение об ошибке.
	printf("\n  Ошибка при создании файла для записи результатов расчета ");

	// Завершить работу программы с признаком ошибки.	
	return -1;
}

// Создать файл для записи протокола работы № 1.
if ( (f3=fopen("PROTOKOL_1.DAT","w")) == NULL )
{
	// Неудача при создании файла для записи результатов расчета. 
	// Освободить ранее выделенные блоки оперативной памяти.
	if (sum_fure_profil_nk != NULL) free(sum_fure_profil_nk);	/// Освободить область памяти выделенную для массива хранящего сумму ряда Фурье описывающего  профиль дорожки качения наружного кольца
	if (aa != NULL) free(aa);					/// Освободить область памяти выделенную для массвива коэффициентов ряда Фурье
	if (profil_nk != NULL) free(profil_nk);				/// Освободить область памяти выделенную хранения массива описывающего профильдорожки качения наружного кольца
	free(Name_Stroka);	
	free(xx_min);	
	free(xx_max);
	free(xx);
	free(xx_b);
	free(hh);

	// Закрыть файл в который записаны результаты расчетов. 
	fclose(f2);

	// Выдать сообщение об ошибке.
	printf("\n  Ошибка при создании файла для записи протокола расчета ");

	// Завершить работу программы с признаком ошибки.	
	return -1;
}

// Выдать в файл результатов расчета считанные исходные данные о геометрии и условиях работы подшипника.
fprintf(f2,"\n	                                                        ТАБЛИЦА %d   ", nom_tab);
fprintf(f2,"\n                                                                               " );
fprintf(f2,"\n      ИСХОДНЫЕ ДАННЫЕ ДЛЯ РАСЧЕТА ДИНАМИКИ И ОПТИМИЗАЦИИ КОНСТРУКЦИИ    ");
fprintf(f2,"\n             РОЛИКОПОДШИПНИКА С ЦИЛИНДРИЧЕСКИМИ РОЛИКАМИ                ");
fprintf(f2,"\n                                                                        ");
fprintf(f2,"\n  РОЛИКОВЫЙ ПОДШИПНИК : "); 

// Выдать наименование подшипника.
i=0;
while ((i<57) && (*(Name_Stroka+i)!='\0'))
{
	fprintf(f2,"%c", *(Name_Stroka+i));
	i++;
}

fprintf(f2,"\n");
fprintf(f2,"\n    Внутренний диаметр .........................................../мм/  %9.3f  ",xx_min[0]);  if (priz_var_param[0])  fprintf(f2,"    %9.3f : ",xx_max[0]);
fprintf(f2,"\n    Наружный диаметр ............................................./мм/  %9.3f  ",xx_min[1]);  if (priz_var_param[1])  fprintf(f2,"    %9.3f : ",xx_max[1]);
fprintf(f2,"\n    Номинальный радиальный зазор ................................./мм/  %9.3f  ",xx_min[2]);  if (priz_var_param[2])  fprintf(f2,"    %9.3f : ",xx_max[2]);	
fprintf(f2,"\n    Выполнять расчет радиального зазора в рабочих условиях (1-да,0-нет) %3d    ",(int) xx_min[3]);  if (priz_var_param[3])  fprintf(f2,"    %3d : ",(int) xx_max[3]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  POЛИKИ                                                                       ");
fprintf(f2,"\n    Количество ....................................................     %3d  ",(int) xx_min[4]);  if (priz_var_param[4])  fprintf(f2,"    %3d : ",(int) xx_max[4]);	
fprintf(f2,"\n    Диаметр ....................................................../мм/  %9.3f  ",xx_min[5]);  if (priz_var_param[5])  fprintf(f2,"    %9.3f : ",xx_max[5]);	
fprintf(f2,"\n    Полная длина ................................................./мм/  %9.3f  ",xx_min[6]);  if (priz_var_param[6])  fprintf(f2,"    %9.3f : ",xx_max[6]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  ВИД ПРОФИЛЯ РОЛИКА..................................................  %3d  ",(int) xx_min[7]);  if (priz_var_param[7])  fprintf(f2,"    %3d : ",(int) xx_max[7]);	
fprintf(f2,"\n    ( 1- Цилиндрический с бомбиной и фаской,                                   ");
fprintf(f2,"\n      2- Лундберга                                                             ");
fprintf(f2,"\n      3- Апроксимация профиля Лундберга двумя окружностями                     ");
fprintf(f2,"\n      4- Цилиндрический с двумя бомбинами и фаской )                           ");
fprintf(f2,"\n                                                                               ");

switch ( (int) xx_min[7] )
{
	case 1:
	{ 	// Ролик с профилем цилиндрическим с бомбиной и фаской.
		//	
		fprintf(f2,"\n  ДЛЯ ЦИЛИНДРИЧЕСКОГО С БОМБИНОЙ И ФАСКОЙ               ( 1 )                  ");
		fprintf(f2,"\n    Длина цилиндрической части ролика............................./мм/  %9.3f  ",xx_min[8]);  if (priz_var_param[8])  fprintf(f2,"    %9.3f : ",xx_max[8]);	

		fprintf(f2,"\n    Свес бомбины ................................................./мм/  %9.4f  ",xx_min[9]);  if (priz_var_param[9])  fprintf(f2,"    %9.4f : ",xx_max[9]);	

		fprintf(f2,"\n    Длина фаски ................................................../мм/  %9.3f  ",xx_min[10]); if (priz_var_param[10]) fprintf(f2,"    %9.3f : ",xx_max[10]);	
		fprintf(f2,"\n    Высота фаски ................................................./мм/  %9.3f  ",xx_min[11]); if (priz_var_param[11]) fprintf(f2,"    %9.3f : ",xx_max[11]);	
		fprintf(f2,"\n    Способ получения радиуса фаски (0-расчет,1-задание в исх.дан.)      %3d  ", (int) xx_min[12]); if (priz_var_param[12]) fprintf(f2,"    %3d : ",(int) xx_max[12]);	
		fprintf(f2,"\n    Радиус фаски ................................................./мм/  %9.3f  ",xx_min[13]); if (priz_var_param[13]) fprintf(f2,"    %9.3f : ",xx_max[13]);	
		fprintf(f2,"\n                                                                               ");
		break;
	}

	case 2:
	{ 	// Ролик с профилем Лундберга 
		//	
		fprintf(f2,"\n  ДЛЯ ПРОФИЛЯ ЛУНДБЕРГА                                 ( 2 )                  ");
		fprintf(f2,"\n    Параметр профиля усилие в контакте ........................../кгс/  %9.3f  ",xx_min[14]); if (priz_var_param[14]) fprintf(f2,"    %9.3f : ",xx_max[14]);
		fprintf(f2,"\n    Параметр профиля полуширина полосы контакта ................../мм/  %9.3f  ",xx_min[15]); if (priz_var_param[15]) fprintf(f2,"    %9.3f : ",xx_max[15]);
		fprintf(f2,"\n                                                                               ");
		break;
	}

	case 3:
	{  	// Ролик с профилем апроксимация профиля Лундберга двумя окружностями
		//
		fprintf(f2,"\n  ДЛЯ АПРОКСИМАЦИИ ПРОФИЛЯ ЛУНДБЕРГА ДВУМЯ ОКРУЖНОСТЯМИ ( 3 )                  ");
		fprintf(f2,"\n    Параметр профиля усилие в контакте ........................../кгс/  %9.3f  ",xx_min[16]); if (priz_var_param[16]) fprintf(f2,"    %9.3f : ",xx_max[16]);
		fprintf(f2,"\n    Параметр профиля полуширина полосы контакта ................../мм/  %9.3f  ",xx_min[17]); if (priz_var_param[17]) fprintf(f2,"    %9.3f : ",xx_max[17]);
		fprintf(f2,"\n    Коэфф.задающий точку сопряжения дуг 2х окружн.апрокс.профиль .....  %9.3f  ",xx_min[18]); if (priz_var_param[18]) fprintf(f2,"    %9.3f : ",xx_max[18]);
		fprintf(f2,"\n                                                                               ");
		break;
	}

	case 4:
	{  	// Ролик с профилем цилиндрическим с двумя бомбинами и фаской
		//
		fprintf(f2,"\n  ДЛЯ ЦИЛИНДРИЧЕСКОГО С ДВУМЯ БОМБИНАМИ И ФАСКОЙ        ( 4 )                  ");     
		fprintf(f2,"\n    Длина цилиндрической части ролика ............................/мм/  %9.3f  ",xx_min[19]); if (priz_var_param[19]) fprintf(f2,"    %9.3f : ",xx_max[19]);	
		fprintf(f2,"\n    Длина бомбины № 1 ............................................/мм/  %9.3f  ",xx_min[20]); if (priz_var_param[20]) fprintf(f2,"    %9.3f : ",xx_max[20]);	
		fprintf(f2,"\n    Свес бомбины № 1 (относительно цилиндрической части) ........./мм/  %9.3f  ",xx_min[21]); if (priz_var_param[21]) fprintf(f2,"    %9.3f : ",xx_max[21]);
		fprintf(f2,"\n    Сдвиг центра кривизны бомб.№2 относ.верт.средней линии ролика /мм/  %9.3f  ",xx_min[22]); if (priz_var_param[22]) fprintf(f2,"    %9.3f : ",xx_max[22]);
		fprintf(f2,"\n    Свес бомбины № 2 (относительно бомбины № 1) ................../мм/  %9.3f  ",xx_min[23]); if (priz_var_param[23]) fprintf(f2,"    %9.3f : ",xx_max[23]);
		fprintf(f2,"\n    Длина фаски ................................................../мм/  %9.3f  ",xx_min[24]); if (priz_var_param[24]) fprintf(f2,"    %9.3f : ",xx_max[24]);	
		fprintf(f2,"\n    Высота фаски ................................................./мм/  %9.3f  ",xx_min[25]); if (priz_var_param[25]) fprintf(f2,"    %9.3f : ",xx_max[25]);	
		fprintf(f2,"\n    Радиус фаски ................................................./мм/  %9.3f  ",xx_min[26]); if (priz_var_param[26]) fprintf(f2,"    %9.3f : ",xx_max[26]);	
		fprintf(f2,"\n                                                                               ");
		break;
	}
}	

fprintf(f2,"\n  ДОРОЖКА КАЧЕНИЯ ВНУТРЕННЕГО КОЛЬЦА                                           ");
fprintf(f2,"\n    Радиус без учета отклонения от идеальной формы  ............../мм/  %9.3f  ",xx_min[27]); if (priz_var_param[27]) fprintf(f2,"    %9.3f : ",xx_max[27]);	
fprintf(f2,"\n    Большая полуось эллипса профиля дорожки качения внутр.кольца ./мм/  %9.3f  ",xx_min[28]); if (priz_var_param[28]) fprintf(f2,"    %9.3f : ",xx_max[28]);	
fprintf(f2,"\n    Малая полуось эллипса профиля дорожки качения внутр.кольца .../мм/  %9.3f  ",xx_min[29]); if (priz_var_param[29]) fprintf(f2,"    %9.3f : ",xx_max[29]);	
fprintf(f2,"\n    Угол между малой п-осью эллипса дорожки ВК и рад.нагрузкой ../мин/  %9.3f  ",xx_min[30]); if (priz_var_param[30]) fprintf(f2,"    %9.3f : ",xx_max[30]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  СЕПАРАТОР                                                                    ");
fprintf(f2,"\n    Диаметр наружной цилиндрической поверхности ................./мм/  %9.3f  ",xx_min[31]); if (priz_var_param[31]) fprintf(f2,"    %9.3f : ",xx_max[31]);	
fprintf(f2,"\n    Диаметр внутренней цилиндрической поверхности .............../мм/  %9.3f  ",xx_min[32]); if (priz_var_param[32]) fprintf(f2,"    %9.3f : ",xx_max[32]);	
fprintf(f2,"\n    Ширина ....................................................../мм/  %9.3f  ",xx_min[33]); if (priz_var_param[33]) fprintf(f2,"    %9.3f : ",xx_max[33]);	
fprintf(f2,"\n    Диаметр центрирующих поясков ................................/мм/  %9.3f  ",xx_min[34]); if (priz_var_param[34]) fprintf(f2,"    %9.3f : ",xx_max[34]);	
fprintf(f2,"\n    Ширина обоих центрирующих поясков .........................../мм/  %9.3f  ",xx_min[35]); if (priz_var_param[35]) fprintf(f2,"    %9.3f : ",xx_max[35]);	
fprintf(f2,"\n    Длина окна ................................................../мм/  %9.3f  ",xx_min[36]); if (priz_var_param[36]) fprintf(f2,"    %9.3f : ",xx_max[36]);	
fprintf(f2,"\n    Ширина окна ................................................./мм/  %9.3f  ",xx_min[37]); if (priz_var_param[37]) fprintf(f2,"    %9.3f : ",xx_max[37]);	
fprintf(f2,"\n    Диаметр поверх.кольца(нар,внут) которая центрирует сепаратор./мм/  %9.3f  ",xx_min[38]); if (priz_var_param[38]) fprintf(f2,"    %9.3f : ",xx_max[38]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  БОРТИК                                                                    ");
fprintf(f2,"\n    Диаметр ...................................................../мм/  %9.3f  ",xx_min[39]); if (priz_var_param[39]) fprintf(f2,"    %9.3f : ",xx_max[39]);	
fprintf(f2,"\n                                                                            ");
fprintf(f2,"\n  ВАЛ                                                                          ");
fprintf(f2,"\n    Внутренний диаметр .......................................... /мм/  %9.3f  ",xx_min[40]); if (priz_var_param[40]) fprintf(f2,"    %9.3f : ",xx_max[40]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  КОРПУС                                                                       ");
fprintf(f2,"\n    Наружный диаметр ............................................ /мм/  %9.3f  ",xx_min[41]); if (priz_var_param[41]) fprintf(f2,"    %9.3f : ",xx_max[41]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  ХАРАКТЕРИСТИКИ МАТЕРИАЛОВ                                                    ");
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n    Плотность                                                                  ");
fprintf(f2,"\n        Ролик ........................................... /грамм/cм3/   %9.3f  ",xx_min[42]); if (priz_var_param[42]) fprintf(f2,"    %9.3f : ",xx_max[42]);	
fprintf(f2,"\n        Внутреннее кольцо ............................... /грамм/cм3/   %9.3f  ",xx_min[43]); if (priz_var_param[43]) fprintf(f2,"    %9.3f : ",xx_max[43]);	
fprintf(f2,"\n        Наружное кольцо ................................. /грамм/cм3/   %9.3f  ",xx_min[44]); if (priz_var_param[44]) fprintf(f2,"    %9.3f : ",xx_max[44]);	
fprintf(f2,"\n        Сепаратор ....................................... /грамм/cм3/   %9.3f  ",xx_min[45]); if (priz_var_param[45]) fprintf(f2,"    %9.3f : ",xx_max[45]);	
fprintf(f2,"\n        Вал ............................................. /грамм/cм3/   %9.3f  ",xx_min[46]); if (priz_var_param[46]) fprintf(f2,"    %9.3f : ",xx_max[46]);	
fprintf(f2,"\n        Корпус .......................................... /грамм/cм3/   %9.3f  ",xx_min[47]); if (priz_var_param[47]) fprintf(f2,"    %9.3f : ",xx_max[47]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n    Модуль упругости                                                           ");
fprintf(f2,"\n        Ролик .............................................. /кг/мм2/   %9.0f  ",xx_min[48]); if (priz_var_param[48]) fprintf(f2,"    %9.0f : ",xx_max[48]);	
fprintf(f2,"\n        Внутреннее кольцо .................................. /кг/мм2/   %9.0f  ",xx_min[49]); if (priz_var_param[49]) fprintf(f2,"    %9.0f : ",xx_max[49]);	
fprintf(f2,"\n        Наружное кольцо .................................... /кг/мм2/   %9.0f  ",xx_min[50]); if (priz_var_param[50]) fprintf(f2,"    %9.0f : ",xx_max[50]);	
fprintf(f2,"\n        Сепаратор........................................... /кг/мм2/   %9.0f  ",xx_min[51]); if (priz_var_param[51]) fprintf(f2,"    %9.0f : ",xx_max[51]);	
fprintf(f2,"\n        Вал ................................................ /кг/мм2/   %9.0f  ",xx_min[52]); if (priz_var_param[52]) fprintf(f2,"    %9.0f : ",xx_max[52]);	
fprintf(f2,"\n        Корпус ............................................. /кг/мм2/   %9.0f  ",xx_min[53]); if (priz_var_param[53]) fprintf(f2,"    %9.0f : ",xx_max[53]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n    Коэффициенты Пуассона                                                      ");
fprintf(f2,"\n        Ролик .......................................................   %9.3f  ",xx_min[54]); if (priz_var_param[54]) fprintf(f2,"    %9.3f : ",xx_max[54]);	
fprintf(f2,"\n        Внутреннее кольцо ...........................................   %9.3f  ",xx_min[55]); if (priz_var_param[55]) fprintf(f2,"    %9.3f : ",xx_max[55]);	
fprintf(f2,"\n        Наружное кольцо .............................................   %9.3f  ",xx_min[56]); if (priz_var_param[56]) fprintf(f2,"    %9.3f : ",xx_max[56]);	
fprintf(f2,"\n        Сепаратор....................................................   %9.3f  ",xx_min[57]); if (priz_var_param[57]) fprintf(f2,"    %9.3f : ",xx_max[57]);	
fprintf(f2,"\n        Вал .........................................................   %9.3f  ",xx_min[58]); if (priz_var_param[58]) fprintf(f2,"    %9.3f : ",xx_max[58]);	
fprintf(f2,"\n        Корпус ......................................................   %9.3f  ",xx_min[59]); if (priz_var_param[59]) fprintf(f2,"    %9.3f : ",xx_max[59]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n    Коэффициент теплового расширения                                           ");
fprintf(f2,"\n        Ролик ........................................... /Градус -1/   %9.7f  ",xx_min[60]); if (priz_var_param[60]) fprintf(f2,"    %9.7f : ",xx_max[60]);	
fprintf(f2,"\n        Внутреннее кольцо ................................/Градус -1/   %9.7f  ",xx_min[61]); if (priz_var_param[61]) fprintf(f2,"    %9.7f : ",xx_max[61]);	
fprintf(f2,"\n        Наружное кольцо ................................../Градус -1/   %9.7f  ",xx_min[62]); if (priz_var_param[62]) fprintf(f2,"    %9.7f : ",xx_max[62]);	
fprintf(f2,"\n        Сепаратор........................................./Градус -1/   %9.7f  ",xx_min[63]); if (priz_var_param[63]) fprintf(f2,"    %9.7f : ",xx_max[63]);	
fprintf(f2,"\n        Вал ............................................../Градус -1/   %9.7f  ",xx_min[64]); if (priz_var_param[64]) fprintf(f2,"    %9.7f : ",xx_max[64]);	
fprintf(f2,"\n        Корпус .........................................../Градус -1/   %9.7f  ",xx_min[65]); if (priz_var_param[65]) fprintf(f2,"    %9.7f : ",xx_max[65]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  НАТЯГИ В СОЕДИНЕНИЯХ ПРИ МОНТАЖЕ                                             ");
fprintf(f2,"\n    Вал-подшипник .............................................../мм/  %9.3f   ",xx_min[66]); if (priz_var_param[66]) fprintf(f2,"    %9.3f : ",xx_max[66]);	
fprintf(f2,"\n    Подшипник-корпус............................................./мм/  %9.3f   ",xx_min[67]); if (priz_var_param[67]) fprintf(f2,"    %9.3f : ",xx_max[67]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  ЧИСТОТА ОБРАБОТКИ ПОВЕРХНОСТИ                                                ");
fprintf(f2,"\n    Вала ......................................................../мм/  %9.5f   ",xx_min[68]); if (priz_var_param[68]) fprintf(f2,"    %9.5f : ",xx_max[68]);	
fprintf(f2,"\n    Корпуса ...................................................../мм/  %9.5f   ",xx_min[69]); if (priz_var_param[69]) fprintf(f2,"    %9.5f : ",xx_max[69]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  РАБОЧИЕ УСЛОВИЯ                                                              ");
fprintf(f2,"\n    Частота вращения внутреннего кольца и вала ............. /об/мин/  %9.0f   ",xx_min[70]); if (priz_var_param[70]) fprintf(f2,"    %9.0f : ",xx_max[70]);	
fprintf(f2,"\n    Частота вращения наружного кольца и корпуса ............ /об/мин/  %9.0f   ",xx_min[71]); if (priz_var_param[71]) fprintf(f2,"    %9.0f : ",xx_max[71]);	
fprintf(f2,"\n    Pадиальная нагрузка ....................................... /кгс/  %9.1f   ",xx_min[72]); if (priz_var_param[72]) fprintf(f2,"    %9.1f : ",xx_max[72]);	
fprintf(f2,"\n    Осевая нагрузка ........................................... /кгс/  %9.1f   ",xx_min[73]); if (priz_var_param[73]) fprintf(f2,"    %9.1f : ",xx_max[73]);	
fprintf(f2,"\n    Угол перекоса дорожки качения внутреннего кольца .......... /MИH/  %9.1f   ",xx_min[74]); if (priz_var_param[74]) fprintf(f2,"    %9.1f : ",xx_max[74]);	
fprintf(f2,"\n    Доля масла в масловоздушной смеси ..............................   %9.3f   ",xx_min[75]); if (priz_var_param[75]) fprintf(f2,"    %9.3f : ",xx_max[75]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  РАБОЧАЯ ТЕМПЕРАТУРА                                                          ");
fprintf(f2,"\n      Ролик ........................................ /Градус Цельсия/   %9.1f  ",xx_min[76]); if (priz_var_param[76]) fprintf(f2,"    %9.1f : ",xx_max[76]);	
fprintf(f2,"\n      Внутреннее кольцо ............................ /Градус Цельсия/   %9.1f  ",xx_min[77]); if (priz_var_param[77]) fprintf(f2,"    %9.1f : ",xx_max[77]);	
fprintf(f2,"\n      Наружное кольцо .............................. /Градус Цельсия/   %9.1f  ",xx_min[78]); if (priz_var_param[78]) fprintf(f2,"    %9.1f : ",xx_max[78]);	
fprintf(f2,"\n      Вал .......................................... /Градус Цельсия/   %9.1f  ",xx_min[79]); if (priz_var_param[79]) fprintf(f2,"    %9.1f : ",xx_max[79]);	
fprintf(f2,"\n      Корпус ....................................... /Градус Цельсия/   %9.1f  ",xx_min[80]); if (priz_var_param[80]) fprintf(f2,"    %9.1f : ",xx_max[80]);	
fprintf(f2,"\n      Масла на входе ............................... /Градус Цельсия/   %9.1f  ",xx_min[81]); if (priz_var_param[81]) fprintf(f2,"    %9.1f : ",xx_max[81]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  ТЕМПЕРАТУРА МОНТАЖА ПОДШИПНИКА.................... /Градус Цельсия/   %9.1f  ",xx_min[82]); if (priz_var_param[82]) fprintf(f2,"    %9.1f : ",xx_max[82]);	
fprintf(f2,"\n                                                                               ");

switch ((int) xx_min[83])
{
	case 1:
		// Для смазки № 1. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 1   МС-20                                                             ");
		break;
	case 2:
		// Для смазки № 2. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 2   75% МС-20 + 25% трансформаторного                                 ");
		break;	
	case 3:
		// Для смазки № 3. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 3   50% МС-20 + 50% трансформаторного                                 ");
		break;
	case 4:
		// Для смазки № 4. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 4   25% МС-20 + 75% трансформаторного                                 ");
		break;
	case 5:
		// Для смазки № 5. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 5   Веретенное 2                                                      ");
		break;
	case 6:
		// Для смазки № 6. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 6   МК-8                                                              ");
		break;
	case 7:
		// Для смазки № 7. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 7   Трансформаторное                                                  ");
		break;
	case 8:
		// Для смазки № 8. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 8   МН 7-5                                                            ");
		break;
	case 9:
		// Для смазки № 9. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 9   ВНИИНП-7                                                          ");
		break;
	case 10:
		// Для смазки № 10. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 10  Б-38                                                              ");
		break;
	case 11:
		// Для смазки № 11. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 11  ЛНМ3-36/1-K                                                       ");
		break;
	case 12:
		// Для смазки № 12. Выдать наименование смазки.
		fprintf(f2,"\n  СМАЗКА № 12  50-1-4Ф                                                           ");
		break;
	case 13:
		// Для смазки № 13 (произвольная задаваемая с помощью формулы Роландса).	
		fprintf(f2,"\n  РЕОЛОГИЧЕСКИЕ ХАРАКТЕРИСТИКИ СМАЗКИ N 13  ( Вязкость по Роландсу )             ");
		fprintf(f2,"\n      Динам.вязкость масла при давлении=0 и темп=T0 ......./кг*с/мм2/  %10.9f  ",xx_min[85]); if (priz_var_param[85]) fprintf(f2,"    %10.9f : ",xx_max[85]);	
		fprintf(f2,"\n      Плотность масла при температуре=T0 ..................../кг/мм3/  %10.9f  ",xx_min[86]); if (priz_var_param[86]) fprintf(f2,"    %10.9f : ",xx_max[86]);	
		fprintf(f2,"\n      Температура T0 при которой задана дин.вязкость /Градус Кельвина/ %9.2f   ",xx_min[87]); if (priz_var_param[87]) fprintf(f2,"    %9.2f : ", xx_max[87]);	
		fprintf(f2,"\n      Пъезовязкостный параметр ( Z1 ) ................................ %9.3f   ",xx_min[88]); if (priz_var_param[88]) fprintf(f2,"    %9.3f : ", xx_max[88]);	
		fprintf(f2,"\n      Модуль сдвига смазки ( G сдвиг ) ............................... %9.3f   ",xx_min[89]); if (priz_var_param[89]) fprintf(f2,"    %9.3f : ", xx_max[89]);	
		fprintf(f2,"\n      Термовязкостный параметр ( SS0 )  .............................. %9.3f   ",xx_min[90]); if (priz_var_param[90]) fprintf(f2,"    %9.3f : ", xx_max[90]);	
		fprintf(f2,"\n      Пъезокоэффициент вязкости смазки  .............................. %9.3f   ",xx_min[91]); if (priz_var_param[91]) fprintf(f2,"    %9.3f : ", xx_max[91]);	
		break;
	default:
		// Для других видов смазки. Выдать наименование смазки.
		fprintf(f2,"\n  ОШИБКА !!! УКАЗАН НЕИЗВЕСТНЫЙ ВИД СМАЗКИ !!!                              ");
		break;
}

fprintf(f2,"\n                                                                               ");

switch ((int) xx_min[84])
{
	case 1:
		// Для случая апроксимации таблицы вязкости полиномом Лагранжа.
		fprintf(f2,"\n  Таблица вязкости апроксимируется полиномом ЛАГРАНЖА");
		break;
	case 2:
		// Для случая апроксимации таблицы вязкости формулой Баруса.
		fprintf(f2,"\n  Таблица вязкости апроксимируется формулой БАРУСА");
		break;
	case 3:
		// Для случая апроксимации таблицы вязкости формулой Роландса.
		fprintf(f2,"\n  Таблица вязкости апроксимируется формулой РОЛАНДСА");
		break;
	default:
		// Для других видов апроксимации.
		fprintf(f2,"\n  ОШИБКА !!! УКАЗАН НЕИЗВЕСТНЫЙ СПОСОБ АПРОКСИМАЦИИ !!! ");	
		break;
}

fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  КОЭФФИЦИЕНТ ДЛЯ РАСЧЁТА ДОЛГОВЕЧНОСТИ............. /Градус Цельсия/  %9.3f   ",xx_min[92]); if (priz_var_param[92]) fprintf(f2,"    %9.3f : ", xx_max[92]);	
fprintf(f2,"\n                                                                               ");
fprintf(f2,"\n  НАСТРОЙКИ ПРОГРАММЫ                                                          ");
fprintf(f2,"\n    Kол-во участков на которые разбивается полная длина ролика ......   %3d  ",(int) xx_min[93]); if (priz_var_param[93]) fprintf(f2,"    %3d : ",(int) xx_max[93]);	

if ( (int) xx_min[94] == 1)  
	fprintf(f2,"\n    НЕРАВНОМЕРНАЯ СЕТКА ДЛЯ УВЕЛИЧЕНИЯ СКОРОСТИ ВЫЧИСЛЕНИЙ         ");
else
	fprintf(f2,"\n    РАВНОМЕРНАЯ СЕТКА                                              ");

if ( (int) xx_min[95] == 1 )
	fprintf(f2,"\n    ВЫПОЛНЯЕТСЯ РАСЧЕТ КОНЦЕНТРАТОРОВ НАПРЯЖЕНИЙ НА КРАЯХ РОЛИКА        ");
else
	fprintf(f2,"\n    БЕЗ РАСЧЕТА КОНЦЕНТРАТОВ НАПРЯЖЕНИЙ НА КРАЯХ РОЛИКА                 ");

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///

if ( (int) xx_min[96] == 1 )
	fprintf(f2,"\n    БЕРЁМ ПРОФИЛЬ ДОРОЖКИ КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА ИЗ ФАЙЛА PROF_NK.DAT  %3d ТОЧЕК ", kol_toch_profil_nk);
else
	fprintf(f2,"\n    КРУГЛАЯ ДОРОЖКА КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА ");
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

fprintf(f2,"\n    Коэффициенты умножения шага при решении методом Ньютона :                   ");
fprintf(f2,"\n    Уравнений равновесия ролика .....................................    %9.1f  ",xx_min[97]); if (priz_var_param[97]) fprintf(f2,"    %9.1f : ",xx_max[97]);	
fprintf(f2,"\n    Уравнений равновесия внутреннего кольца .........................    %9.1f  ",xx_min[98]); if (priz_var_param[98]) fprintf(f2,"    %9.1f : ",xx_max[98]);	
fprintf(f2,"\n    Поиск распределения напряжений в контакте ролика с кольцом ......    %9.1f  ",xx_min[99]); if (priz_var_param[99]) fprintf(f2,"    %9.1f : ",xx_max[99]);	


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///

if ( (int) xx_min[96] == 1 )
{
	/// Выдать профиль дорожки качения наружного кольца
	fprintf(f2,"\n                                                    ");
	fprintf(f2,"\n     ПРОФИЛЬ ДОРОЖКИ КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА       ");
	fprintf(f2,"\n                                                    ");
	fprintf(f2,"\n -------------------------------------------------- ");
	fprintf(f2,"\n | № отсчета  | Угол в градусах   |  Радиус в мм  | ");
	fprintf(f2,"\n -------------------------------------------------- ");

	for (k=0; k < kol_toch_profil_nk; k++)
	{
		tek_ugol_gradus = 360.0 * (double) k / (double) kol_toch_profil_nk;
		fprintf(f2,"\n |    %4d    |  %10.3f       | %13.8f |", k, tek_ugol_gradus, *(profil_nk+k));
	}

	fprintf(f2,"\n -------------------------------------------------- ");
	fprintf(f2,"\n                                                    ");
	fprintf(f2,"\n                                                    ");

	/// Выдать результаты БПФ
	fprintf(f2,"\n ---------------------------------------------------------------------------------------------------- ");
	fprintf(f2,"\n                                                                     ");
	fprintf(f2,"\n   РЯД ФУРЬЕ ОПИСЫВАЮЩИЙ ПРОФИЛЬ ДОРОЖКИ КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА    ");
	fprintf(f2,"\n                                                                     ");
	fprintf(f2,"\n Результат( k ) =  %15.8f ", aa[0]/2.0 );

	for (k=1; k<kol_toch_profil_nk/2; k++)
	{
		if (aa[k*2] >= 0) 
		{
			char_sign_1 = '+';
		}
		else
		{
			char_sign_1 = '-';
		}

		if (aa[k*2+1] >= 0) 
		{
			char_sign_2 = '+';
		}
		else
		{
			char_sign_2 = '-';
		}
	
		fprintf(f2,"\n                    %c%13.8f * cos( 2*pi/%3d * k *%3d ) %c%13.8f * sin( 2*pi/%3d * k *%3d ) ", char_sign_1, fabs(aa[k*2]), kol_toch_profil_nk, k,   char_sign_2, fabs(aa[k*2+1]), kol_toch_profil_nk, k);
	}

	// Выдать профиль дорожки качения наружного кольца и сумму ряда Фурье описывающего этот профиль. Определить радиус дорожки качения наружного кольца.
	sred_R_nk_fure = 0.0;
	fprintf(f2,"\n												");
	fprintf(f2,"\n   СРАВНЕНИЕ ИСХОДНОГО ПРОФИЛЯ ДОРОЖКИ КАЧЕНИЯ И ЕГО АПРОКСИМАЦИИ РЯДОМ ФУРЬЕ  		");
	fprintf(f2,"\n												");
	fprintf(f2,"\n ------------------------------------------------------------------ ");
	fprintf(f2,"\n |            |                   |Радиус профиля | Апроксимация  | ");
	fprintf(f2,"\n | № отсчета  | Угол в градусах   |дорожки качения|   профиля     | ");
	fprintf(f2,"\n |            |                   |     в мм      | рядом Фурье   | ");
	fprintf(f2,"\n |            |                   |               |               | ");
	fprintf(f2,"\n ------------------------------------------------------------------ ");

	for (k=0; k<kol_toch_profil_nk; k++)
	{
		tek_ugol_gradus = 360.0  * (double) k / (double) kol_toch_profil_nk;									// Определить текущий угол в градусах
                sred_R_nk_fure += *(sum_fure_profil_nk+k);              											// Нарастить сумму радиусов дорожки качения наружного кольца
		fprintf(f2,"\n |    %4d    |  %10.5f       | %13.8f | %13.8f | ", k, tek_ugol_gradus, *(profil_nk+k), *(sum_fure_profil_nk+k) );	// Выдать угол в градусах, радиус дорожки качения, сумму ряда Фурье
	}

	fprintf(f2,"\n -----------------------------------------------------------------------------------------");
	fprintf(f2,"\n                                                                                      	");
	fprintf(f2,"\n                                                                                      	");
	sred_R_nk_fure = sred_R_nk_fure/kol_toch_profil_nk;		// Определить сумму радиусов дорожки качения наружного кольца
}

///
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Выдать на экран считанные исходные данные о геометрии и условиях работы подшипника.
printf("\n	                                                        ТАБЛИЦА %d   ", nom_tab);
printf("\n                                                                                    ");
nom_tab++;
printf("\n      ИСХОДНЫЕ ДАННЫЕ ДЛЯ РАСЧЕТА ДИНАМИКИ И ОПТИМИЗАЦИИ КОНСТРУКЦИИ    ");
printf("\n             РОЛИКОПОДШИПНИКА С ЦИЛИНДРИЧЕСКИМИ РОЛИКАМИ                ");
printf("\n                                                                        ");
printf("\n  РОЛИКОВЫЙ ПОДШИПНИК : "); 

// Выдать наименование подшипника.
i=0;
while ((i<57) && (*(Name_Stroka+i)!='\0'))
{
	printf("%c", *(Name_Stroka+i));
	i++;
}

printf("\n");
printf("\n    Внутренний диаметр .........................................../мм/  %9.3f  ",xx_min[0]);  if (priz_var_param[0])  printf("    %9.3f : ",xx_max[0]);
printf("\n    Наружный диаметр ............................................./мм/  %9.3f  ",xx_min[1]);  if (priz_var_param[1])  printf("    %9.3f : ",xx_max[1]);
printf("\n    Номинальный радиальный зазор ................................./мм/  %9.3f  ",xx_min[2]);  if (priz_var_param[2])  printf("    %9.3f : ",xx_max[2]);	
printf("\n    Выполнять расчет радиального зазора в рабочих условиях (1-да,0-нет) %3d  ",(int) xx_min[3]);  if (priz_var_param[3])  printf("    %3d : ",(int) xx_max[3]);	
printf("\n                                                                               ");
printf("\n  POЛИKИ                                                                       ");
printf("\n    Количество ....................................................     %3d  ",(int) xx_min[4]);  if (priz_var_param[4])  printf("    %3d : ",(int) xx_max[4]);	
printf("\n    Диаметр ....................................................../мм/  %9.3f  ",xx_min[5]);  if (priz_var_param[5])  printf("    %9.3f : ",xx_max[5]);	
printf("\n    Полная длина ................................................./мм/  %9.3f  ",xx_min[6]);  if (priz_var_param[6])  printf("    %9.3f : ",xx_max[6]);	
printf("\n                                                                               ");
printf("\n  ВИД ПРОФИЛЯ РОЛИКА..................................................  %3d  ",(int) xx_min[7]);  if (priz_var_param[7])  printf("    %3d : ",(int) xx_max[7]);	
printf("\n    ( 1- Цилиндрический с бомбиной и фаской,                                   ");
printf("\n      2- Лундберга                                                             ");
printf("\n      3- Апроксимация профиля Лундберга двумя окружностями                     ");
printf("\n      4- Цилиндрический с двумя бомбинами и фаской )                           ");
printf("\n                                                                               ");

switch ( (int) xx_min[7] )
{
	case 1:
	{ 	// Ролик с профилем цилиндрическим с бомбиной и фаской.
		//	
		printf("\n  ДЛЯ ЦИЛИНДРИЧЕСКОГО С БОМБИНОЙ И ФАСКОЙ               ( 1 )                  ");
		printf("\n    Длина цилиндрической части ролика............................./мм/  %9.3f  ",xx_min[8]);  if (priz_var_param[8])  printf("    %9.3f : ",xx_max[8]);	
		printf("\n    Свес бомбины ................................................./мм/  %9.3f  ",xx_min[9]);  if (priz_var_param[9])  printf("    %9.3f : ",xx_max[9]);	
		printf("\n    Длина фаски ................................................../мм/  %9.3f  ",xx_min[10]); if (priz_var_param[10]) printf("    %9.3f : ",xx_max[10]);	
		printf("\n    Высота фаски ................................................./мм/  %9.3f  ",xx_min[11]); if (priz_var_param[11]) printf("    %9.3f : ",xx_max[11]);	
		printf("\n    Способ получения радиуса фаски (0-расчет,1-задание в исх.дан.)      %3d  ",(int) xx_min[12]); if (priz_var_param[12]) printf("    %3d : ",(int) xx_max[12]);	
		printf("\n    Радиус фаски ................................................./мм/  %9.3f  ",xx_min[13]); if (priz_var_param[13]) printf("    %9.3f : ",xx_max[13]);	
		printf("\n                                                                               ");
		break;
	}

	case 2:
	{ 	// Ролик с профилем Лундберга 
		//	
		printf("\n  ДЛЯ ПРОФИЛЯ ЛУНДБЕРГА                                 ( 2 )                  ");
		printf("\n    Параметр профиля усилие в контакте ........................../кгс/  %9.3f  ",xx_min[14]); if (priz_var_param[14]) printf("    %9.3f : ",xx_max[14]);
		printf("\n    Параметр профиля полуширина полосы контакта ................../мм/  %9.3f  ",xx_min[15]); if (priz_var_param[15]) printf("    %9.3f : ",xx_max[15]);
		printf("\n                                                                               ");
		break;
	}

	case 3:
	{  	// Ролик с профилем апроксимация профиля Лундберга двумя окружностями
		//
		printf("\n  ДЛЯ АПРОКСИМАЦИИ ПРОФИЛЯ ЛУНДБЕРГА ДВУМЯ ОКРУЖНОСТЯМИ ( 3 )                  ");
		printf("\n    Параметр профиля усилие в контакте ........................../кгс/  %9.3f  ",xx_min[16]); if (priz_var_param[16]) printf("    %9.3f : ",xx_max[16]);
		printf("\n    Параметр профиля полуширина полосы контакта ................../мм/  %9.3f  ",xx_min[17]); if (priz_var_param[17]) printf("    %9.3f : ",xx_max[17]);
		printf("\n    Коэфф.задающий точку сопряжения дуг 2х окружн.апрокс.профиль .....  %9.3f  ",xx_min[18]); if (priz_var_param[18]) printf("    %9.3f : ",xx_max[18]);
		printf("\n                                                                               ");
		break;
	}

	case 4:
	{  	// Ролик с профилем цилиндрическим с двумя бомбинами и фаской
		//
		printf("\n  ДЛЯ ЦИЛИНДРИЧЕСКОГО С ДВУМЯ БОМБИНАМИ И ФАСКОЙ        ( 4 )                  ");     
		printf("\n    Длина цилиндрической части ролика ............................/мм/  %9.3f  ",xx_min[19]); if (priz_var_param[19]) printf("    %9.3f : ",xx_max[19]);	
		printf("\n    Длина бомбины № 1 ............................................/мм/  %9.3f  ",xx_min[20]); if (priz_var_param[20]) printf("    %9.3f : ",xx_max[20]);	
		printf("\n    Свес бомбины № 1 (относительно цилиндрической части) ........./мм/  %9.3f  ",xx_min[21]); if (priz_var_param[21]) printf("    %9.3f : ",xx_max[21]);
		printf("\n    Сдвиг центра кривизны бомб.№2 относ.верт.средней линии ролика /мм/  %9.3f  ",xx_min[22]); if (priz_var_param[22]) printf("    %9.3f : ",xx_max[22]);
		printf("\n    Свес бомбины № 2 (относительно бомбины № 1) ................../мм/  %9.3f  ",xx_min[23]); if (priz_var_param[23]) printf("    %9.3f : ",xx_max[23]);
		printf("\n    Длина фаски ................................................../мм/  %9.3f  ",xx_min[24]); if (priz_var_param[24]) printf("    %9.3f : ",xx_max[24]);	
		printf("\n    Высота фаски ................................................./мм/  %9.3f  ",xx_min[25]); if (priz_var_param[25]) printf("    %9.3f : ",xx_max[25]);	
		printf("\n    Радиус фаски ................................................./мм/  %9.3f  ",xx_min[26]); if (priz_var_param[26]) printf("    %9.3f : ",xx_max[26]);	
		printf("\n                                                                               ");
		break;
	}
}	

printf("\n  ДОРОЖКА КАЧЕНИЯ ВНУТРЕННЕГО КОЛЬЦА                                           ");
printf("\n    Радиус без учета отклонения от идеальной формы  ............../мм/  %9.3f  ",xx_min[27]); if (priz_var_param[27]) printf("    %9.3f : ",xx_max[27]);	
printf("\n    Большая полуось эллипса профиля дорожки качения внутр.кольца ./мм/  %9.3f  ",xx_min[28]); if (priz_var_param[28]) printf("    %9.3f : ",xx_max[28]);	
printf("\n    Малая полуось эллипса профиля дорожки качения внутр.кольца .../мм/  %9.3f  ",xx_min[29]); if (priz_var_param[29]) printf("    %9.3f : ",xx_max[29]);	
printf("\n    Угол между малой п-осью эллипса дорожки ВК и рад.нагрузкой ../мин/  %9.3f  ",xx_min[30]); if (priz_var_param[30]) printf("    %9.3f : ",xx_max[30]);	
printf("\n                                                                               ");
printf("\n  СЕПАРАТОР                                                                    ");
printf("\n    Диаметр наружной цилиндрической поверхности ................./мм/  %9.3f  ",xx_min[31]); if (priz_var_param[31]) printf("    %9.3f : ",xx_max[31]);	
printf("\n    Диаметр внутренней цилиндрической поверхности .............../мм/  %9.3f  ",xx_min[32]); if (priz_var_param[32]) printf("    %9.3f : ",xx_max[32]);	
printf("\n    Ширина ....................................................../мм/  %9.3f  ",xx_min[33]); if (priz_var_param[33]) printf("    %9.3f : ",xx_max[33]);	
printf("\n    Диаметр центрирующих поясков ................................/мм/  %9.3f  ",xx_min[34]); if (priz_var_param[34]) printf("    %9.3f : ",xx_max[34]);	
printf("\n    Ширина обоих центрирующих поясков .........................../мм/  %9.3f  ",xx_min[35]); if (priz_var_param[35]) printf("    %9.3f : ",xx_max[35]);	
printf("\n    Длина окна ................................................../мм/  %9.3f  ",xx_min[36]); if (priz_var_param[36]) printf("    %9.3f : ",xx_max[36]);	
printf("\n    Ширина окна ................................................./мм/  %9.3f  ",xx_min[37]); if (priz_var_param[37]) printf("    %9.3f : ",xx_max[37]);	
printf("\n    Диаметр поверх.кольца(нар,внут) которая центрирует сепаратор./мм/  %9.3f  ",xx_min[38]); if (priz_var_param[38]) printf("    %9.3f : ",xx_max[38]);	
printf("\n                                                                               ");
printf("\n  БОРТИК                                                                    ");
printf("\n    Диаметр ...................................................../мм/  %9.3f  ",xx_min[39]); if (priz_var_param[39]) printf("    %9.3f : ",xx_max[39]);	
printf("\n                                                                            ");
printf("\n  ВАЛ                                                                          ");
printf("\n    Внутренний диаметр полого вала .............................. /мм/  %9.3f  ",xx_min[40]); if (priz_var_param[40]) printf("    %9.3f : ",xx_max[40]);	
printf("\n                                                                               ");
printf("\n  КОРПУС                                                                       ");
printf("\n    Наружный диаметр корпуса .................................... /мм/  %9.3f  ",xx_min[41]); if (priz_var_param[41]) printf("    %9.3f : ",xx_max[41]);	
printf("\n                                                                               ");
printf("\n  ХАРАКТЕРИСТИКИ МАТЕРИАЛОВ                                                    ");
printf("\n                                                                               ");
printf("\n    Плотность                                                                  ");
printf("\n        Ролик ........................................... /грамм/cм3/   %9.3f  ",xx_min[42]); if (priz_var_param[42]) printf("    %9.3f : ",xx_max[42]);	
printf("\n        Внутреннее кольцо ............................... /грамм/cм3/   %9.3f  ",xx_min[43]); if (priz_var_param[43]) printf("    %9.3f : ",xx_max[43]);	
printf("\n        Наружное кольцо ................................. /грамм/cм3/   %9.3f  ",xx_min[44]); if (priz_var_param[44]) printf("    %9.3f : ",xx_max[44]);	
printf("\n        Сепаратор ....................................... /грамм/cм3/   %9.3f  ",xx_min[45]); if (priz_var_param[45]) printf("    %9.3f : ",xx_max[45]);	
printf("\n        Вал ............................................. /грамм/cм3/   %9.3f  ",xx_min[46]); if (priz_var_param[46]) printf("    %9.3f : ",xx_max[46]);	
printf("\n        Корпус .......................................... /грамм/cм3/   %9.3f  ",xx_min[47]); if (priz_var_param[47]) printf("    %9.3f : ",xx_max[47]);	
printf("\n                                                                               ");
printf("\n    Модуль упругости                                                           ");
printf("\n        Ролик .............................................. /кг/мм2/   %9.0f  ",xx_min[48]); if (priz_var_param[48]) printf("    %9.0f : ",xx_max[48]);	
printf("\n        Внутреннее кольцо .................................. /кг/мм2/   %9.0f  ",xx_min[49]); if (priz_var_param[49]) printf("    %9.0f : ",xx_max[49]);	
printf("\n        Наружное кольцо .................................... /кг/мм2/   %9.0f  ",xx_min[50]); if (priz_var_param[50]) printf("    %9.0f : ",xx_max[50]);	
printf("\n        Сепаратор........................................... /кг/мм2/   %9.0f  ",xx_min[51]); if (priz_var_param[51]) printf("    %9.0f : ",xx_max[51]);	
printf("\n        Вал ................................................ /кг/мм2/   %9.0f  ",xx_min[52]); if (priz_var_param[52]) printf("    %9.0f : ",xx_max[52]);	
printf("\n        Корпус ............................................. /кг/мм2/   %9.0f  ",xx_min[53]); if (priz_var_param[53]) printf("    %9.0f : ",xx_max[53]);	
printf("\n                                                                               ");
printf("\n    Коэффициенты Пуассона                                                      ");
printf("\n        Ролик .......................................................   %9.3f  ",xx_min[54]); if (priz_var_param[54]) printf("    %9.3f : ",xx_max[54]);	
printf("\n        Внутреннее кольцо ...........................................   %9.3f  ",xx_min[55]); if (priz_var_param[55]) printf("    %9.3f : ",xx_max[55]);	
printf("\n        Наружное кольцо .............................................   %9.3f  ",xx_min[56]); if (priz_var_param[56]) printf("    %9.3f : ",xx_max[56]);	
printf("\n        Сепаратор....................................................   %9.3f  ",xx_min[57]); if (priz_var_param[57]) printf("    %9.3f : ",xx_max[57]);	
printf("\n        Вал .........................................................   %9.3f  ",xx_min[58]); if (priz_var_param[58]) printf("    %9.3f : ",xx_max[58]);	
printf("\n        Корпус ......................................................   %9.3f  ",xx_min[59]); if (priz_var_param[59]) printf("    %9.3f : ",xx_max[59]);	
printf("\n                                                                               ");
printf("\n    Коэффициент теплового расширения                                           ");
printf("\n        Ролик ........................................... /Градус -1/   %9.7f  ",xx_min[60]); if (priz_var_param[60]) printf("    %9.7f : ",xx_max[60]);	
printf("\n        Внутреннее кольцо ................................/Градус -1/   %9.7f  ",xx_min[61]); if (priz_var_param[61]) printf("    %9.7f : ",xx_max[61]);	
printf("\n        Наружное кольцо ................................../Градус -1/   %9.7f  ",xx_min[62]); if (priz_var_param[62]) printf("    %9.7f : ",xx_max[62]);	
printf("\n        Сепаратор........................................./Градус -1/   %9.7f  ",xx_min[63]); if (priz_var_param[63]) printf("    %9.7f : ",xx_max[63]);	
printf("\n        Вал ............................................../Градус -1/   %9.7f  ",xx_min[64]); if (priz_var_param[64]) printf("    %9.7f : ",xx_max[64]);	
printf("\n        Корпус .........................................../Градус -1/   %9.7f  ",xx_min[65]); if (priz_var_param[65]) printf("    %9.7f : ",xx_max[65]);	
printf("\n                                                                               ");
printf("\n  НАТЯГИ В СОЕДИНЕНИЯХ ПРИ МОНТАЖЕ                                             ");
printf("\n    Вал-подшипник .............................................../мм/  %9.3f   ",xx_min[66]); if (priz_var_param[66]) printf("    %9.3f : ",xx_max[66]);	
printf("\n    Подшипник-корпус............................................./мм/  %9.3f   ",xx_min[67]); if (priz_var_param[67]) printf("    %9.3f : ",xx_max[67]);	
printf("\n                                                                               ");
printf("\n  ЧИСТОТА ОБРАБОТКИ ПОВЕРХНОСТИ                                                ");
printf("\n    Вала ......................................................../мм/  %9.5f   ",xx_min[68]); if (priz_var_param[68]) printf("    %9.5f : ",xx_max[68]);	
printf("\n    Корпуса ...................................................../мм/  %9.5f   ",xx_min[69]); if (priz_var_param[69]) printf("    %9.5f : ",xx_max[69]);	
printf("\n                                                                               ");
printf("\n  РАБОЧИЕ УСЛОВИЯ                                                              ");
printf("\n    Частота вращения внутреннего кольца и вала ............. /об/мин/  %9.0f   ",xx_min[70]); if (priz_var_param[70]) printf("    %9.0f : ",xx_max[70]);	
printf("\n    Частота вращения вала и корпуса ........................ /об/мин/  %9.0f   ",xx_min[71]); if (priz_var_param[71]) printf("    %9.0f : ",xx_max[71]);	
printf("\n    Pадиальная нагрузка ....................................... /кгс/  %9.1f   ",xx_min[72]); if (priz_var_param[72]) printf("    %9.1f : ",xx_max[72]);	
printf("\n    Осевая нагрузка ........................................... /кгс/  %9.1f   ",xx_min[73]); if (priz_var_param[73]) printf("    %9.1f : ",xx_max[73]);	
printf("\n    Угол перекоса дорожки качения внутреннего кольца .......... /MИH/  %9.1f   ",xx_min[74]); if (priz_var_param[74]) printf("    %9.1f : ",xx_max[74]);	
printf("\n    Доля масла в масловоздушной смеси ..............................   %9.3f   ",xx_min[75]); if (priz_var_param[75]) printf("    %9.3f : ",xx_max[75]);	
printf("\n                                                                               ");
printf("\n  РАБОЧАЯ ТЕМПЕРАТУРА                                                          ");
printf("\n      Ролик ........................................ /Градус Цельсия/  %9.1f   ",xx_min[76]); if (priz_var_param[76]) printf("    %9.1f : ",xx_max[76]);	
printf("\n      Внутреннее кольцо ............................ /Градус Цельсия/  %9.1f   ",xx_min[77]); if (priz_var_param[77]) printf("    %9.1f : ",xx_max[77]);	
printf("\n      Наружное кольцо .............................. /Градус Цельсия/  %9.1f   ",xx_min[78]); if (priz_var_param[78]) printf("    %9.1f : ",xx_max[78]);	
printf("\n      Вал .......................................... /Градус Цельсия/  %9.1f   ",xx_min[79]); if (priz_var_param[79]) printf("    %9.1f : ",xx_max[79]);	
printf("\n      Корпус ....................................... /Градус Цельсия/  %9.1f   ",xx_min[80]); if (priz_var_param[80]) printf("    %9.1f : ",xx_max[80]);	
printf("\n      Масла на входе ..............................  /Градус Цельсия/  %9.1f   ",xx_min[81]); if (priz_var_param[81]) printf("    %9.1f : ",xx_max[81]);	
printf("\n                                                                               ");
printf("\n  ТЕМПЕРАТУРА МОНТАЖА ПОДШИПНИКА.................... /Градус Цельсия/  %9.1f   ",xx_min[82]); if (priz_var_param[82]) printf("    %9.1f : ",xx_max[82]);	

switch ((int) xx_min[83])
{
	case 1:
		// Для смазки № 1. Выдать наименование смазки.
		printf("\n  СМАЗКА № 1   МС-20                                                             ");
		break;
	case 2:
		// Для смазки № 2. Выдать наименование смазки.
		printf("\n  СМАЗКА № 2   75% МС-20 + 25% трансформаторного                                 ");
		break;	
	case 3:
		// Для смазки № 3. Выдать наименование смазки.
		printf("\n  СМАЗКА № 3   50% МС-20 + 50% трансформаторного                                 ");
		break;
	case 4:
		// Для смазки № 4. Выдать наименование смазки.
		printf("\n  СМАЗКА № 4   25% МС-20 + 75% трансформаторного                                 ");
		break;
	case 5:
		// Для смазки № 5. Выдать наименование смазки.
		printf("\n  СМАЗКА № 5   Веретенное 2                                                      ");
		break;
	case 6:
		// Для смазки № 6. Выдать наименование смазки.
		printf("\n  СМАЗКА № 6   МК-8                                                              ");
		break;
	case 7:
		// Для смазки № 7. Выдать наименование смазки.
		printf("\n  СМАЗКА № 7   Трансформаторное                                                  ");
		break;
	case 8:
		// Для смазки № 8. Выдать наименование смазки.
		printf("\n  СМАЗКА № 8   МН 7-5                                                            ");
		break;
	case 9:
		// Для смазки № 9. Выдать наименование смазки.
		printf("\n  СМАЗКА № 9   ВНИИНП-7                                                          ");
		break;
	case 10:
		// Для смазки № 10. Выдать наименование смазки.
		printf("\n  СМАЗКА № 10  Б-38                                                              ");
		break;
	case 11:
		// Для смазки № 11. Выдать наименование смазки.
		printf("\n  СМАЗКА № 11  ЛНМ3-36/1-K                                                       ");
		break;
	case 12:
		// Для смазки № 12. Выдать наименование смазки.
		printf("\n  СМАЗКА № 12  50-1-4Ф                                                           ");
		break;
	case 13:
		// Для смазки № 13 (произвольная задаваемая с помощью формулы Роландса).	
		printf("\n  РЕОЛОГИЧЕСКИЕ ХАРАКТЕРИСТИКИ СМАЗКИ N 13  ( Вязкость по Роландсу )             ");
		printf("\n      Динам.вязкость масла при давлении=0 и темп=T0 ......./кг*с/мм2/  %10.9f  ",xx_min[85]); if (priz_var_param[85]) fprintf(f2,"    %10.9f : ",xx_max[85]);	
		printf("\n      Плотность масла при температуре=T0 ..................../кг/мм3/  %10.9f  ",xx_min[86]); if (priz_var_param[86]) fprintf(f2,"    %10.9f : ",xx_max[86]);	
		printf("\n      Температура T0 при которой задана дин.вязкость /Градус Кельвина/ %9.2f   ",xx_min[87]); if (priz_var_param[87]) fprintf(f2,"    %9.2f : ", xx_max[87]);	
		printf("\n      Пъезовязкостный параметр ( Z1 ) ................................ %9.3f   ",xx_min[88]); if (priz_var_param[88]) fprintf(f2,"    %9.3f : ", xx_max[88]);	
		printf("\n      Модуль сдвига смазки ( G сдвиг ) ............................... %9.3f   ",xx_min[89]); if (priz_var_param[89]) fprintf(f2,"    %9.3f : ", xx_max[89]);	
		printf("\n      Термовязкостный параметр ( SS0 )  .............................. %9.3f   ",xx_min[90]); if (priz_var_param[90]) fprintf(f2,"    %9.3f : ", xx_max[90]);	
		printf("\n      Пъезокоэффициент вязкости смазки  .............................. %9.3f   ",xx_min[91]); if (priz_var_param[91]) fprintf(f2,"    %9.3f : ", xx_max[91]);	
		break;
	default:
		// Для других видов смазки. Выдать наименование смазки.
		printf("\n  ОШИБКА !!! УКАЗАН НЕИЗВЕСТНЫЙ ВИД СМАЗКИ !!!                              ");
		break;
}

printf("\n                                                                               ");

switch ((int) xx_min[84])
{
	case 1:
		// Для случая апроксимации таблицы вязкости полиномом Лагранжа.
		printf("\n  Таблица вязкости апроксимируется полиномом ЛАГРАНЖА");
		break;
	case 2:
		// Для случая апроксимации таблицы вязкости формулой Баруса.
		printf("\n  Таблица вязкости апроксимируется формулой БАРУСА");
		break;
	case 3:
		// Для случая апроксимации таблицы вязкости формулой Роландса.
		printf("\n  Таблица вязкости апроксимируется формулой РОЛАНДСА");
		break;
	default:
		// Для других видов апроксимации.
		printf("\n  ОШИБКА !!! УКАЗАН НЕИЗВЕСТНЫЙ СПОСОБ АПРОКСИМАЦИИ !!! ");	
		break;
}

printf("\n                                                                               ");
printf("\n                                                                               ");
printf("\n  КОЭФФИЦИЕНТ ДЛЯ РАСЧЁТА ДОЛГОВЕЧНОСТИ............. /Градус Цельсия/  %9.3f   ",xx_min[92]);  if (priz_var_param[92]) printf("    %9.3f  : ",xx_max[92]);	
printf("\n                                                                               ");
printf("\n  НАСТРОЙКИ ПРОГРАММЫ                                                          ");
printf("\n    Kол-во участков на которые разбивается полная длина ролика ......   %3d    ",(int) xx_min[93]); if (priz_var_param[93]) printf("    %3d : ",(int) xx_max[93]);	


if ( (int) xx_min[94] == 1)  
	printf("\n    НЕРАВНОМЕРНАЯ СЕТКА ДЛЯ УВЕЛИЧЕНИЯ СКОРОСТИ ВЫЧИСЛЕНИЙ         ");
else
	printf("\n    РАВНОМЕРНАЯ СЕТКА                                              ");


if ( (int) xx_min[95] == 1 )
	printf("\n    ВЫПОЛНЯЕТСЯ РАСЧЕТ КОНЦЕНТРАТОРОВ НАПРЯЖЕНИЙ НА КРАЯХ РОЛИКА        ");
else
	printf("\n    БЕЗ РАСЧЕТА КОНЦЕНТРАТОВ НАПРЯЖЕНИЙ НА КРАЯХ РОЛИКА                 ");

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///

if ( (int) xx_min[96] == 1 )
	printf("\n    БЕРЁМ ПРОФИЛЬ ДОРОЖКИ КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА ИЗ ФАЙЛА PROF_NK.DAT  %3d ТОЧЕК ", kol_toch_profil_nk);
else
	printf("\n    КРУГЛАЯ ДОРОЖКА КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА ");

///
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

printf("\n    Коэффициенты умножения шага при решении методом Ньютона :                   ");
printf("\n    Уравнений равновесия ролика .....................................    %9.1f  ",xx_min[97]); if (priz_var_param[97]) printf("    %9.1f : ",xx_max[97]);	
printf("\n    Уравнений равновесия внутреннего кольца .........................    %9.1f  ",xx_min[98]); if (priz_var_param[98]) printf("    %9.1f : ",xx_max[98]);	
printf("\n    Поиск распределения напряжений в контакте ролика с кольцом ......    %9.1f  ",xx_min[99]); if (priz_var_param[99]) printf("    %9.1f : ",xx_max[99]);	

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///

if ( (int) xx_min[96] == 1 )
{
	/// Выдать профиль дорожки качения наружного кольца
	printf("\n                                                    ");
	printf("\n     ПРОФИЛЬ ДОРОЖКИ КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА       ");
	printf("\n                                                    ");
	printf("\n -------------------------------------------------- ");
	printf("\n | № отсчета  | Угол в градусах   |  Радиус в мм  | ");
	printf("\n -------------------------------------------------- ");

	for (k=0; k < kol_toch_profil_nk; k++)
	{
		tek_ugol_gradus = 360.0 * (double) k / (double) kol_toch_profil_nk;
		printf("\n |    %4d    |  %10.3f       | %13.8f |", k, tek_ugol_gradus, *(profil_nk+k));
	}

	printf("\n -------------------------------------------------- ");
	printf("\n                                                    ");
	printf("\n                                                    ");

	/// Выдать результаты БПФ
	printf("\n ---------------------------------------------------------------------------------------------------- ");
	printf("\n                                                                    ");
	printf("\n   РЯД ФУРЬЕ ОПИСЫВАЮЩИЙ ПРОФИЛЬ ДОРОЖКИ КАЧЕНИЯ НАРУЖНОГО КОЛЬЦА   ");
	printf("\n                                                                    ");
	printf("\n Результат( k ) =  %15.8f ", aa[0]/2.0 );

	for (k=1; k<kol_toch_profil_nk/2; k++)
	{
		if (aa[k*2] >= 0) 
		{
			char_sign_1 = '+';
		}
		else
		{
			char_sign_1 = '-';
		}

		if (aa[k*2+1] >= 0) 
		{
			char_sign_2 = '+';
		}
		else
		{
			char_sign_2 = '-';
		}
	
		printf("\n                    %c%13.8f * cos( 2*pi/%3d * k *%3d ) %c%13.8f * sin( 2*pi/%3d * k *%3d ) ", char_sign_1, fabs(aa[k*2]), kol_toch_profil_nk, k,   char_sign_2, fabs(aa[k*2+1]), kol_toch_profil_nk, k);
	}

	printf("\n												");
	printf("\n   СРАВНЕНИЕ ИСХОДНОГО ПРОФИЛЯ ДОРОЖКИ КАЧЕНИЯ И ЕГО АПРОКСИМАЦИИ РЯДОМ ФУРЬЕ  		");
	printf("\n												");
	printf("\n ------------------------------------------------------------------ ");
	printf("\n |            |                   |Радиус профиля | Апроксимация  | ");
	printf("\n | № отсчета  | Угол в градусах   |дорожки качения|   профиля     | ");
	printf("\n |            |                   |     в мм      | рядом Фурье   | ");
	printf("\n |            |                   |               |               | ");
	printf("\n ------------------------------------------------------------------ ");

	for (k=0; k<kol_toch_profil_nk; k++)
	{
		tek_ugol_gradus = 360.0  * (double) k / (double) kol_toch_profil_nk;								// Определить текущий угол в градусах
		printf("\n |    %4d    |  %10.5f       | %13.8f | %13.8f | ", k, tek_ugol_gradus, *(profil_nk+k), *(sum_fure_profil_nk+k) );	// Выдать угол в градусах, радиус дорожки качения, сумму ряда Фурье
	}

	printf("\n ---------------------------------------------------------------------------------------------");
	printf("\n                                                                                      	");
	printf("\n                                                                                      	");
}

///
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// Обнулить счетчик вычислений целевой функции
kol_wych_Y_cel = 0;

// Обнулить счетчик попыток вычислить целевую функцию
kol_popyt_wych_Y_cel = 0;

// Установить в NULL указатель на начало списка значений целевой функции.
u_nach = NULL;

// Задаем начальное значение координат базовой точки
for (i=0; i<Kol_Param; i++)  *(xx_b+i)=(*(xx_max+i)+*(xx_min+i))/2;

// Задаем начальное значение шага.
for (i=0; i<Kol_Param; i++) *(hh+i) = (*(xx_max+i)-*(xx_min+i))/20;

// Найти значение целевой функции в базовой точке.
//
//	Входные параметры  :   xx_b - Массив координат точки в которой надо получить значение целевой функции
//	Выходные параметры : Yb_cel - Значение целевой функции	
//
Yb_cel = f_cel1(xx_b);

if (Kol_Var_Param > 0)
{
	// Количество варьируемых параметров больше 0. 
	// Проводить оптимизацию.

	// Цикл поиска минимума целевой функции

	while (1)
	{
		//  Исследование окрестности базовой точки и выбор координаты и направления движения.
		//
		//
		//     Выходные параметры :	 n_coord - Номер координаты по которой надо шагать (0 - Kol_Param-1)	
		//				    napr - Направление шагания (0 - Вперед , 1 - Назад)
		//
		wybor_coord_napr( &n_coord, &napr);
	
		if (Y_cel < Yb_cel)
		{
			// Найдена координата и направление уменьшения целевой функции.	

			// Движение по найденной координате и направлению.
			while (1)
			{
				// Текущую точку сделать базовой.
				for (i=0; i<Kol_Param; i++) *(xx_b+i)=*(xx+i);
				Yb_cel = Y_cel;

				// Сделать шаг в выбранном направлении и получить координаты новой текущей точки.
				if (napr == 0)	
				{
					*(xx+n_coord) -= *(hh+n_coord); 			
				}
				else
				{
					*(xx+n_coord) += *(hh+n_coord); 			
				}	

				// Найти значение целевой функции в текущей точке
				//
				//	Входные параметры :  	 xx - Массив координат текущей точки в которой надо получить значение целевой функции
				//	Выходные параметры :  Y_cel - Значение целевой функции 
				//

				Y_cel = f_cel1(xx);

				// Если значение целевой функции в новой текущей точке больше значения целевой функции в базовой точке
				// тогда двигаться по данному направлению по данной координате нельзя.
				// Выход из цикла движения по координате и направлению.
				if (Y_cel > Yb_cel) break;
			}
		}
		else	
		{
			// Не найдена координата и направление в котором бы уменьшалось бы целевая функция.

			if (*(hh+nom_var_param) < (*(xx_max+nom_var_param)-*(xx_min+nom_var_param))/1000)
			{
				// Шаг по координате № "nom_var_param" достачно мал.

				// Найдены координаты точки в которой целевая функция достигает минимума. 

				// Выдать значение целевой функции и координаты точки в которой она достигает минимума.
				fprintf(f2,"\n\n  Найден минимум целевой функции = %10.3f ",Yb_cel);
				fprintf(f2,"\n    В точке с координатами ");
				for (i=0; i<Kol_Param; i++) 
				{
					if (priz_var_param[i]) symb1 = '*'; else symb1 = ' ';
					fprintf(f2,"\n %c xx[%d] = %15.9f ",symb1, i ,*(xx_b+i));
				}
				fprintf(f2,"\n\n\n   Количество вычислений целевой функции = %d ", kol_wych_Y_cel);
				fprintf(f2,"\n   Количество попыток вычиcлений целевой функции = %d ", kol_popyt_wych_Y_cel);


				// Выход из цикла поиска минимума целевой функции
				break;
			}
			else
			{
				// Шаг по координате № 0 не достаточно мал.
				// Уменьшить величину шага в 10 раз.
				for (i=0; i<Kol_Param; i++) *(hh+i) /= 10;
			}	
		}

	}

}

////////////////////////////////////////////////////////////////////////
///
if (sum_fure_profil_nk != NULL) free(sum_fure_profil_nk);	/// Освободить область памяти выделенную для массива хранящего сумму ряда Фурье описывающего  профиль дорожки качения наружного кольца
if (aa != NULL) free(aa);					/// Освободить область памяти выделенную для массвива коэффициентов ряда Фурье
if (profil_nk != NULL) free(profil_nk);				/// Освободить область памяти выделенную хранения массива описывающего профильдорожки качения наружного кольца
///
///////////////////////////////////////////////////////////////////////

free_spisok(u_nach);	/// Освободить область памяти выделенную для хранения списка значений целевой функции
fclose(f3);		/// Закрыть файл в который записаны протокола расчета. 
fclose(f2);		/// Закрыть файл в который записаны результаты расчетов. 
free(priz_var_param);	/// Освободить область памяти выделенную для хранения массива "priz_var_param[]" (Признак варируемого параметра). 
free(hh);		/// Освободить область памяти выделенную для хранения массива "hh[]" (Величина шага вдоль координат)
free(xx_b);		/// Освободить область памяти выделенную для хранения массива "xx_b[]" (Базовые значения параметров).
free(xx);		/// Освободить область памяти выделенную для хранения массива "xx[]" (Текущие значения параметров).
free(xx_min);		/// Освободить область памяти выделенную для хранения массива "xx_min[]" (Нижние границы параметров).
free(xx_max);		/// Освободить область памяти выделенную для хранения массива "xx_max[]" (Верхние границы параметров).
free(Name_Stroka);	/// Освободить блок памяти выделенный для строки хранящей наименование подшипника.

// Выход из программы м признаком нормального завершения
return 0;


}

